<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ansiz</title>
  
  <subtitle>迎风向前是唯一的方法</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zxh.site/"/>
  <updated>2018-07-17T12:11:06.144Z</updated>
  <id>http://zxh.site/</id>
  
  <author>
    <name>张稀虹</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://zxh.site/2018/07/17/Singularity/"/>
    <id>http://zxh.site/2018/07/17/Singularity/</id>
    <published>2018-07-17T12:11:06.144Z</published>
    <updated>2018-07-17T12:11:06.144Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://zxh.site/2018/07/17/slurm-singularity/"/>
    <id>http://zxh.site/2018/07/17/slurm-singularity/</id>
    <published>2018-07-17T12:11:06.144Z</published>
    <updated>2018-07-17T12:11:06.144Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://zxh.site/2018/07/17/docker-on-cluster/"/>
    <id>http://zxh.site/2018/07/17/docker-on-cluster/</id>
    <published>2018-07-17T12:11:06.144Z</published>
    <updated>2018-07-17T12:11:06.144Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://zxh.site/2018/07/17/x11/"/>
    <id>http://zxh.site/2018/07/17/x11/</id>
    <published>2018-07-17T12:11:06.144Z</published>
    <updated>2018-07-17T12:11:06.144Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>在Deepin上安装TensorFlow</title>
    <link href="http://zxh.site/2018/07/15/%E5%9C%A8Deepin%E4%B8%8A%E5%AE%89%E8%A3%85TensorFlow/"/>
    <id>http://zxh.site/2018/07/15/在Deepin上安装TensorFlow/</id>
    <published>2018-07-15T11:51:33.000Z</published>
    <updated>2018-07-15T13:19:53.400Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/tensorflowdeepin.png" alt="NVIDIA-SMI"><br>Tensorflow是目前热门的深度学习框架，官方提供了较为详细的安装文档，不过是针对主流操作系统的，并不包含Deepin这种国产发行版，所以在安装过程中遇到一些问题，这里简单记录一下安装流程。<a id="more"></a></p><h2 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h2><ul><li>Deepin 15.6桌面版</li><li>NVIDIA 1060GTX</li><li>显卡驱动版本：387.34-3deepin</li><li>CUDA版本：8.0</li><li>Tensorflow版本：Tensorflow-GPU(1.4.1)</li><li>cuDNN版本：6.0</li></ul><blockquote><p>注意：请务必注意上述版本，Tensorflow安装最大的坑就在于官方文档总是提供最新的版本，而实际上最新的版本不一定适应于你当前的硬件！</p></blockquote><h2 id="安装NVIDIA显卡驱动"><a href="#安装NVIDIA显卡驱动" class="headerlink" title="安装NVIDIA显卡驱动"></a>安装NVIDIA显卡驱动</h2><p>Deepin默认使用的是开源驱动，该驱动兼容性较好但是性能比NVIDIA原生闭源驱动要差。所以我们要先切换一下驱动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nvidia-driver <span class="comment">#安装驱动包</span></span><br></pre></td></tr></table></figure><p>安装完成后重启系统，在终端中执行nvidia-smi将会看到类似输出：</p><p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/nvidia-smi.png" alt="NVIDIA-SMI"></p><blockquote><p>注意: NVIDIA官网目前提供的最新驱动版本是390，但我安装之后导致系统黑屏驱动无法工作，如无必要不建议安装NVIDIA官网提供的最新版本。</p></blockquote><h2 id="安装CUDA"><a href="#安装CUDA" class="headerlink" title="安装CUDA"></a>安装CUDA</h2><p>因为Deepin和Ubuntu实际上都是基于Debian的，所以我们可以看Tensorflow中Ubuntu的文档进行安装，根据Tensorflow官网提供的链接，NVIDIA将建议安装CUDA9.2，不过这里我们直接用源内提供的8.0版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install nvidia-cuda-dev nvidia-cuda-toolkit nvidia-nsight nvidia-visual-profiler</span><br></pre></td></tr></table></figure><h2 id="安装cuDNN"><a href="#安装cuDNN" class="headerlink" title="安装cuDNN"></a>安装cuDNN</h2><p>安装cuDNN需要进行简单的注册并填写一个简单的调查问卷，注册完成之后即可下载。</p><p>cuDNN也要分很多版本（<a href="https://developer.nvidia.com/rdp/cudnn-archive" target="_blank" rel="noopener">版本列表</a>），这里我们选择<code>cuDNN v6.0 (April 27, 2017), for CUDA 8.0</code>这个版本。直接下载压缩包(<a href="https://developer.nvidia.com/compute/machine-learning/cudnn/secure/v6/prod/8.0_20170307/cudnn-8.0-linux-x64-v6.0-tgz" target="_blank" rel="noopener">cuDNN v6.0 Library for Linux</a>)解压就好：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.<span class="built_in">local</span> <span class="comment"># 如果没有这个文件夹请手动新建</span></span><br><span class="line">tar zxvf ~/Software/cudnn-8.0-linux-x64-v6.0.tgz</span><br></pre></td></tr></table></figure><p>配置LD_LIBRARY_PATH：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建议直接将这个写到bashrc或者zshrc中</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=~/.<span class="built_in">local</span>/cuda/lib64</span><br></pre></td></tr></table></figure><h2 id="安装Tensorflow"><a href="#安装Tensorflow" class="headerlink" title="安装Tensorflow"></a>安装Tensorflow</h2><p>首先安装python和pip，然后执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install tensorflow-gpu==1.4.1</span><br></pre></td></tr></table></figure><p>验证一下安装情况，在python交互模式中输入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow</span><br></pre></td></tr></table></figure><p>如果没有任何报错就说明安装好了，跑一个官网最简单的<a href="https://www.tensorflow.org/get_started/get_started_for_beginners?hl=zh-cn" target="_blank" rel="noopener">对鸢尾花进行分类</a>的demo试试吧，你将看到类似这样的输出：</p><p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/demo.png" alt="NVIDIA-SMI"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o6sdpimwf.bkt.clouddn.com/2018/07/tensorflowdeepin.png&quot; alt=&quot;NVIDIA-SMI&quot;&gt;&lt;br&gt;Tensorflow是目前热门的深度学习框架，官方提供了较为详细的安装文档，不过是针对主流操作系统的，并不包含Deepin这种国产发行版，所以在安装过程中遇到一些问题，这里简单记录一下安装流程。
    
    </summary>
    
      <category term="Linux" scheme="http://zxh.site/categories/Linux/"/>
    
      <category term="深度学习" scheme="http://zxh.site/categories/Linux/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Linux" scheme="http://zxh.site/tags/Linux/"/>
    
      <category term="深度学习" scheme="http://zxh.site/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Deepin——优秀的国产Linux发行版</title>
    <link href="http://zxh.site/2018/07/15/Deepin-%E4%BC%98%E7%A7%80%E7%9A%84%E5%9B%BD%E4%BA%A7Linux%E5%8F%91%E8%A1%8C%E7%89%88/"/>
    <id>http://zxh.site/2018/07/15/Deepin-优秀的国产Linux发行版/</id>
    <published>2018-07-15T04:01:27.000Z</published>
    <updated>2018-07-15T08:26:00.344Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/desktop.png" alt="Desktop"></p><p>最近想接触一下深度学习相关的东西，需要用到高性能的GPU做支持，家里吃灰大半年的PC终于有机会重新发光发热了。之前购买这台PC主要是为了玩一些大型的单机游戏，配置还算凑合，有1060GTX的显卡+双固态硬盘，装的当然是Window的操作系统。不过Windows真的不太适合用来做这方面的开发，所以就打算在第二块移动硬盘上安装Linux的操作系统。</p><p>我平时做开发都是在Linux下，所以对Linux还算比较熟悉，但是平时几乎从来不用桌面环境，不过这次需要比较直观的图像输出，就选了Deepin这款基于Debian的国产桌面操作系统。<a id="more"></a>事实上我在15年就在一台笔记本上安装体验了Deepin，那时候体验就已经不错了，不过系统中存在一些小bug，稳定性一般，加上当时开发的东西主要在CentOS上运行，就没有再深入体验。这两天我花了一些时间搭建开发环境，顺便把它弄得更顺手，这个过程中Deepin总体的使用体验远超我的预期。两年的时间，Deepin已经成熟。</p><h2 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h2><p>在这个颜值即正义的时代，检验一个桌面操作系统是否优秀的第一关就是外观，Deepin吸收借鉴了macOS和Windows的很多优秀设计，又将它们各自的槽点进行了改进，形成了一套相当好用的桌面环境。例如多工作区、Dock栏以及多任务视图借鉴了macOS，而文件管理器及菜单中的很多操作更接近于Windows。</p><p>有一些人吐槽说这是抄袭，我不太认可这样的观点，我认为原封不动的照搬才是抄袭，而懂得取舍和改进应该算作创新。</p><h3 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h3><p>Deepin的菜单有三种不同的展示方式，缩小可以变成类似Windows的菜单，放大后类似macOS将所有应用平铺在屏幕中，此外还可以按类别来展示。我个人更喜欢Windows那样的，按下菜单键后可以直接输入应用名打开程序，比较高效。</p><p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/menu-win.png" alt="Win"></p><p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/menu.png" alt="Menu"></p><h3 id="侧边栏"><a href="#侧边栏" class="headerlink" title="侧边栏"></a>侧边栏</h3><p>如今macOS和Windows10都有侧边栏，一个好用的侧边栏会让系统体验更好。Deepin也弄了一个侧边栏，设计还算简洁，不过目前功能比较简单，类似一个微缩的控制面板，而且貌似暂不支持小插件。上半部分是一个可以切换的区域，通知被折叠到了第三页，天气放在第二页。使用体验上不如macOS从上往下滚动舒服，但是比windows的要强一点点，这部分还有较大的优化空间。</p><p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/desktop.png" alt="桌面"></p><h3 id="多工作区"><a href="#多工作区" class="headerlink" title="多工作区"></a>多工作区</h3><p>熟悉macOS的用户应该都非常喜欢macOS的多桌面设计，你可以将不同的软件放到不同的桌面并且可以通过触控板上的手势操作快速切换，macOS可以说把多桌面体验做到了机制。Deepin在这一点上与macOS非常相似，整体使用下来感觉只差一个带手势操作的触控板了。</p><p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/multi-tasks.png" alt="多任务"></p><p>按下Super+s（Super即常见键盘的Win键），就可以快速呼出所有的应用，你可以轻易的将它们排列和切换。</p><p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/multi-workspace.png" alt="多工作区"></p><p> 按下Super+方向键，可以快速在相邻的工作区切换，操作非常方便。与macOS最大的不同是应用最大化之后，macOS中该最大化的应用会独占整个工作区，而Deepin支持多个最大化的应用在同一个工作区。这一点上我个人更喜欢macOS的设计，软件最大化后连菜单栏都会收缩起来，让你可以获得沉浸式的工作体验。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>Deepin的外观设计我个人还是很满意的，不过真正让我觉得惊喜的是它的一些特点和以代码开发人员的思维所做出的一些高效设计。</p><h3 id="兼容常用Windows软件"><a href="#兼容常用Windows软件" class="headerlink" title="兼容常用Windows软件"></a>兼容常用Windows软件</h3><p>Linux在桌面市场上之所以不够流行，其主要原因是桌面软件对Linux支持较少，而Deepin通过精心改造的wine让一些常用的Windows软件可以在系统中运行。例如我们常用的微信桌面版、QQ、网易云音乐、迅雷等等，都可以从Deepin的应用商店里直接安装使用，这解决了很多用户的一大痛点。</p><p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/store.png" alt="多工作区"></p><h3 id="为普通人做的设计"><a href="#为普通人做的设计" class="headerlink" title="为普通人做的设计"></a>为普通人做的设计</h3><p>内置常用软件，提供常用软件的应用商店，内置中文输入法极大降低了普通用户上手Linux的使用成本。国人大多数都是更习惯Windows的操作方式，例如打开“计算机”应该看到磁盘分区，<code>Ctrl+X/C/V</code>分别对应剪切、复制和粘贴。坦白说尽管我欣赏macOS的很多设计，但是在文件管理器上macOS的体验真的算不上优秀，而类windows的操作效率会更高一些。</p><h3 id="为程序员做的设计"><a href="#为程序员做的设计" class="headerlink" title="为程序员做的设计"></a>为程序员做的设计</h3><p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/terminal.png" alt="终端"></p><p>除了照顾普通大众，Deepin针对程序员也做了一些优化，例如尽可能多的快捷键，其中包括<code>Alt+F2</code>快速启动终端、内置快速截图、菜单中就可以设置软件安装源、内置优秀的终端软件等等，这些就算对有经验的Linux用户来说也是一种便利。</p><p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/source.png" alt="软件源"></p><h2 id="配置技巧"><a href="#配置技巧" class="headerlink" title="配置技巧"></a>配置技巧</h2><p>我花了一整天的时间将Deepin打造得更符合我的使用习惯，这里简单分享一下一些优化和遇到的坑</p><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>推荐直接安装应用商店中的shadowsocks-qt,然后配合genpac实现智能代理，再安装上glider实现HTTP代理，这几款软件的安装和使用都非常简单，这里我分享一下我的glider服务配置：<a href="https://gist.github.com/ansiz/5ed26da1dbad594fb09ceca3fa927eb7" target="_blank" rel="noopener">GitHubGist</a></p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>系统默认的字体不算好看，我目前使用的是苹方字体，等宽字体推荐Noto Mono，终端字体我用的<a href="https://github.com/tonsky/FiraCode" target="_blank" rel="noopener">Fira Code Retina</a>，系统对Emoji的支持也比较差，如果你用chrome作为浏览器并且希望能看到彩色的emoji的话，我建议不要各种折腾emoji字体了，直接安装chromoji这个插件。一定要安装emoji字体的话，推荐<a href="https://github.com/emojione/emojione" target="_blank" rel="noopener">emojione</a></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="窗口特效开启失败"><a href="#窗口特效开启失败" class="headerlink" title="窗口特效开启失败"></a>窗口特效开启失败</h4><p>开启窗口特效后会减少画面的撕裂感，显示更为流畅，但需要更多的系统资源。安装完闭源显卡驱动后开启窗口特效失败，需要手动修改<code>~/.config/deepin/deepin-wm-switcher/config.json</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;allow_switch&quot;:true,&quot;last_wm&quot;:&quot;deepin-wm&quot;&#125;</span><br></pre></td></tr></table></figure><h4 id="终端配置选中即复制"><a href="#终端配置选中即复制" class="headerlink" title="终端配置选中即复制"></a>终端配置选中即复制</h4><p>终端选中即复制默认未打开，需要手动配置copy_on_select：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.config/deepin/deepin-terminal/config.conf</span><br><span class="line"></span><br><span class="line">copy_on_select=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>Tips：按鼠标中键就是粘贴</p><h4 id="Vim禁用鼠标"><a href="#Vim禁用鼠标" class="headerlink" title="Vim禁用鼠标"></a>Vim禁用鼠标</h4><p><code>Vim</code>会自动进入鼠标模式，影响内容复制，请手动配置<code>~/.vimrc</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set mouse=</span><br></pre></td></tr></table></figure><h2 id="目前发现的问题"><a href="#目前发现的问题" class="headerlink" title="目前发现的问题"></a>目前发现的问题</h2><ul><li>侧边栏弹出的逻辑不清晰，响应不及时</li><li>拖动操作bug，无论是拖动终端中的Tab还是拖动文件夹中的文件重新排布顺序都无法实现</li><li>字体支持不完整，Emoji支持较差</li><li>暂不支持NVIDIA最新驱动，安装最新的390驱动会导致系统无法启动，目前可以使用387版</li><li>偶尔会出现假死机的情况，现象是鼠标点击无效，键盘操作正常，<a href="https://wiki.deepin.org/index.php?title=%E7%B3%BB%E7%BB%9F%E6%AD%BB%E6%9C%BA" target="_blank" rel="noopener">官方文档</a>也有提到该问题，希望能尽快改善减少。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说Deepin是一款非常优秀的桌面Linux系统，经过多年的打磨，各方面都已经日趋完善，是一款能够满足办公娱乐及开发的桌面系统。</p><p>我还在上小学的时候连音像店都会卖深度快速装机光盘，那是深度起家的黑历史，难以想象当初靠盗版起家的深度自主研发的操作系统能做到这个水准。吸收了很多macOS和Windows的优秀设计，又摒弃了它们的一些槽点，很多细节都是按照开发人员的思维设计的，一些细节上甚至会给人惊喜。令人担心的是深度的CTO兼创始人上个月离职了，希望不要因此而停止这个国产优秀系统的开发，期待更加优秀的Deepin。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o6sdpimwf.bkt.clouddn.com/2018/07/desktop.png&quot; alt=&quot;Desktop&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近想接触一下深度学习相关的东西，需要用到高性能的GPU做支持，家里吃灰大半年的PC终于有机会重新发光发热了。之前购买这台PC主要是为了玩一些大型的单机游戏，配置还算凑合，有1060GTX的显卡+双固态硬盘，装的当然是Window的操作系统。不过Windows真的不太适合用来做这方面的开发，所以就打算在第二块移动硬盘上安装Linux的操作系统。&lt;/p&gt;
&lt;p&gt;我平时做开发都是在Linux下，所以对Linux还算比较熟悉，但是平时几乎从来不用桌面环境，不过这次需要比较直观的图像输出，就选了Deepin这款基于Debian的国产桌面操作系统。
    
    </summary>
    
      <category term="Linux" scheme="http://zxh.site/categories/Linux/"/>
    
      <category term="评测" scheme="http://zxh.site/categories/Linux/%E8%AF%84%E6%B5%8B/"/>
    
    
      <category term="Linux" scheme="http://zxh.site/tags/Linux/"/>
    
      <category term="评测" scheme="http://zxh.site/tags/%E8%AF%84%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>安全的SOCKS5协议</title>
    <link href="http://zxh.site/2018/07/08/%E5%AE%89%E5%85%A8%E7%9A%84socks5%E5%8D%8F%E8%AE%AE/"/>
    <id>http://zxh.site/2018/07/08/安全的socks5协议/</id>
    <published>2018-07-08T07:27:48.000Z</published>
    <updated>2018-07-17T12:11:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/malicious.png" alt="malicious"></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在<code>HTTP</code>/<code>HTTPS</code>的世界里，<code>TCP/IP</code>数据包的源和目标是公开的。恶意的第三方可以干扰网络连接，将污染过的数据包发送给请求源，从而实现阻止或中断连接。<a id="more"></a></p><p>目前已知的攻击手段包括：</p><ul><li>IP封锁 - 对指定IP地址的任何连接尝试都会被恶意的第三方阻止。</li><li>DNS欺骗 - 返回错误的IP地址。</li><li>包过滤 - 当包中被检测到特定的词句时该数据包将会被阻止或丢弃。</li><li>TCP RST - 对在黑名单中的目的地址进行访问时会发送<code>RST</code>包，TCP连接将会立即中断。</li><li>深度学习 - 利用集群深度学习，恶意方可以快速找到可疑的IP地址。</li></ul><p>在这样的封锁下，想要在自由的网络中呼吸新鲜空气听起来像是在做梦。但是极客们显然不愿意因此丢失任何一个数据包。</p><p>解决方案是利用强加密算法的<a href="https://zh.wikipedia.org/wiki/SOCKS" target="_blank" rel="noopener">SOCKS5</a>协议。</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ul><li>穿透防火墙封锁</li><li>隐藏所有数据包数据，包括源，目标，载荷等</li></ul><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>下面介绍常见的安全SOCKS5代理的开发技术及其工作原理</p><h3 id="工作模式介绍"><a href="#工作模式介绍" class="headerlink" title="工作模式介绍"></a>工作模式介绍</h3><h4 id="自由网络"><a href="#自由网络" class="headerlink" title="自由网络"></a>自由网络</h4><p>在没有恶意攻击者的情况下，客户端与服务器端可以正常通讯。</p><p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/free-client-server.gif" alt="free"></p><h4 id="被封锁的网络"><a href="#被封锁的网络" class="headerlink" title="被封锁的网络"></a>被封锁的网络</h4><p>恶意攻击者可以在客户端和服务器之间部署类似防火墙的系统，这样任何请求都不会到达服务器。因此，最终用户无法从服务器获取任何数据。</p><p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/blocking.gif" alt="blocked"></p><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>一种合理的方法是在防火墙之外设置代理服务器。所有流量都需要先通过代理服务器，然后由代理服务器中继。目前代理技术包括HTTP代理，Socks服务，VPN服务，SSH隧道等。SOCKS5也是其中一种代理协议。</p><p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/proxying.gif" alt="proxy"></p><p>举个例子，当请求通过SSH隧道传输时，防火墙无法识别流量，因为数据已加密。但问题是，在创建隧道时进行SSH握手时，很可能会发现代理服务器被用作代理。因此防火墙可以阻止SSH隧道创建步骤的网络连接。</p><h4 id="安全代理"><a href="#安全代理" class="headerlink" title="安全代理"></a>安全代理</h4><p>安全的socks代理不应向防火墙公开以下信息：</p><ul><li>任何表明它被用作代理的特征</li><li>任何真实传输的数据</li></ul><p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/secure-proxy.gif" alt="secure-proxy"></p><p>要解决上述模型中存在的问题，<code>SOCKS5</code>需要进行改进。我们可以把<code>SOCKS5</code>拆分成两部分，<code>socks5-local</code>和<code>socks5-remote</code></p><p>上图中SOCKS5的工作原理主要可以概括为以下几步：</p><ul><li>客户端通过<code>SOCKS5</code>协议向本地代理发送请求。</li><li>本地代理通过<code>HTTP</code>协议发送加密后的请求数据。</li><li>因为HTTP协议没有明显的特征，并且远程代理服务器尚未被识别为代理，因此请求可以穿透防火墙。</li><li>远程代理服务器解密数据后中继到真实服务。</li><li>真实服务将响应返回到远程代理服务器，并通过相同的路径传播回客户端。</li></ul><h3 id="使用SOCKS5作为本地代理协议"><a href="#使用SOCKS5作为本地代理协议" class="headerlink" title="使用SOCKS5作为本地代理协议"></a>使用SOCKS5作为本地代理协议</h3><p><code>SOCKS5</code>在客户端有广泛的支持。我们很容易得到通过SOCKS5从客户端传输数据到本地代理服务器的好处。 SOCKS5在第5层上执行数据传输。</p><p>下面的curl命令演示了客户端能够使用SOCKS5连接到SOCKS5代理服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --socks5 127.0.0.1:1080 https://google.com</span><br></pre></td></tr></table></figure><h3 id="为什么使用HTTP作为传输协议"><a href="#为什么使用HTTP作为传输协议" class="headerlink" title="为什么使用HTTP作为传输协议"></a>为什么使用HTTP作为传输协议</h3><p>HTTP可能是整个互联网上最常见的流量类型。选择HTTP作为传输协议以突破防火墙使得数据包和服务器不太可能被识别用于代理使用。</p><p>HTTPS不适合防火墙突破。因为HTTPS的设计目的是：</p><ul><li>避免恶意方改变内容</li><li>避免恶意方伪装成目标服务器</li><li>数据加密</li></ul><p>而代理软件的目的应满足以下要求：</p><ul><li>避免目标服务器被识别</li><li>避免代理服务器被识别为代理</li><li>数据加密</li></ul><p>基于以上原因，HTTP是突破防火墙比HTTPS或任何其他协议更好的选择。</p><h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><p>密码算法对数据进行加密和解密，这样任何人都无法从加密流中读取数据，除了LocalProxy和RemoteProxy。由于<code>AEAD</code>密码同时提供机密性，完整性和真实性，建议选择下面列出的AEAD系列之一作为在本地代理和远程代理中使用的密码算法：</p><ul><li>chacha20-ietf-poly1305</li><li>aes-256-gcm</li><li>aes-128-gcm</li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>Shadowsocks是一款出色的安全socks5代理解决方案。查看其<a href="https://shadowsocks.org/en/index.html" target="_blank" rel="noopener">官方网站</a>了解更多信息。</p><h2 id="挑战和风险"><a href="#挑战和风险" class="headerlink" title="挑战和风险"></a>挑战和风险</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ul><li>恶意方可以在客户端安装干扰软件，以阻止本地软件和LocalProxy之间的连接。<ul><li>这可以通过强制安装来实现</li><li>它也可以通过嵌入广泛安装的软件来实现</li></ul></li><li>恶意方可能会强制该人卸载LocalProxy</li></ul><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>必须将服务器端部署到没有防火墙阻止的环境中</p><ul><li>恶意方可以强制云提供商或潜入云服务器做以下事情：<ul><li>窃取服务器日志文件</li><li>杀死ServerProxy进程</li></ul></li><li>恶意方也可以是云提供商</li></ul><h3 id="不安全的加密算法"><a href="#不安全的加密算法" class="headerlink" title="不安全的加密算法"></a>不安全的加密算法</h3><p>使用何种加密算法取决于用户，如果最终用户选择不安全的密码算法，可能会增加服务器被识别为代理服务器的风险。提供代理服务的服务器将被封锁。</p><h3 id="IP白名单限制"><a href="#IP白名单限制" class="headerlink" title="IP白名单限制"></a>IP白名单限制</h3><p>如果最终用户只能连接到选定范围的IP列表（即IP白名单），则用户无法使用SOCKS5服务器，因为SOCKS5服务器IP不太可能包含在IP白名单中。</p><h3 id="进一步的风险"><a href="#进一步的风险" class="headerlink" title="进一步的风险"></a>进一步的风险</h3><p>当最终用户泄露密码密钥和流量历史记录时，恶意方可以解密过去的所有流量。</p><h3 id="执法监管"><a href="#执法监管" class="headerlink" title="执法监管"></a>执法监管</h3><p>即使使用安全的SOCKS5代理，也要注意不要泄露任何个人信息。卸载掉那些不可信任的安全证书和软件，据说<code>Shadowsocks</code>的发明者因为通过QQ与朋友聊天最后被“喝茶”。 :)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过秘密部署安全的SOCKS5代理服务器并选择强密码算法，人们可以突破严重的网络封锁。 <code>Shadowsocks</code>可能是您的首选。</p><hr><p>本文翻译自<a href="https://enqueuezero.com/secure-socks5-proxy.html" target="_blank" rel="noopener">secure-socks5-proxy</a>，包含少量修改。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://enqueuezero.com/secure-socks5-proxy.html" target="_blank" rel="noopener">原文</a></li><li><a href="https://zhuanlan.zhihu.com/p/28566058" target="_blank" rel="noopener">什么是AEAD加密</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o6sdpimwf.bkt.clouddn.com/2018/07/malicious.png&quot; alt=&quot;malicious&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在&lt;code&gt;HTTP&lt;/code&gt;/&lt;code&gt;HTTPS&lt;/code&gt;的世界里，&lt;code&gt;TCP/IP&lt;/code&gt;数据包的源和目标是公开的。恶意的第三方可以干扰网络连接，将污染过的数据包发送给请求源，从而实现阻止或中断连接。
    
    </summary>
    
      <category term="网络" scheme="http://zxh.site/categories/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="译文" scheme="http://zxh.site/categories/%E7%BD%91%E7%BB%9C/%E8%AF%91%E6%96%87/"/>
    
    
      <category term="网络" scheme="http://zxh.site/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="译文" scheme="http://zxh.site/tags/%E8%AF%91%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Docker in LXC踩坑</title>
    <link href="http://zxh.site/2018/02/28/Docker-in-LXC%E8%B8%A9%E5%9D%91/"/>
    <id>http://zxh.site/2018/02/28/Docker-in-LXC踩坑/</id>
    <published>2018-02-28T04:30:22.000Z</published>
    <updated>2018-05-27T02:02:03.381Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o6sdpimwf.bkt.clouddn.com/LXC-Docker.png" alt="LXC-Docker"></p><p>我们知道Docker是如今炙手可热的应用级容器，而LXC可以看作是系统级的容器。那么问题来了，是否可以在一个系统级的容器里面运行一个应用级的容器呢？答案是可以的，不过过程并没有想象的那么容易，百般折腾后部署成功了，在这个过程中也发现了一些问题。<a id="more"></a></p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ol><li>Docker无法启动</li><li>Docker中无法pull镜像</li><li>配置文件中配置项升级后不兼容</li><li>容器内Redis无法启动</li></ol><h3 id="Docker无法启动"><a href="#Docker无法启动" class="headerlink" title="Docker无法启动"></a>Docker无法启动</h3><p>在LXC容器中安装Docker后始终无法启动，最后发现是系统的问题，这里不是宿主机的系统有问题，而是LXC的系统。测试发现Ubuntu系统可以正常启动Docker，而CentOS则不行</p><h3 id="Docker中无法pull镜像"><a href="#Docker中无法pull镜像" class="headerlink" title="Docker中无法pull镜像"></a>Docker中无法pull镜像</h3><p>使用docker pull命令拉取镜像，当镜像下载完成后会提示<code>failed to register layer: ApplyLayer exit status 1 stdout:  stderr: permission denied</code>导致无法完成镜像的下载。造成这个问题的原因是没有解除apparmor限制，在启动lxc容器之后，需要执行下列命令：</p><blockquote><p>NOTE: $HOST修改为对应的容器主机名</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;&gt;/var/lib/lxc/<span class="variable">$HOST</span>/config &lt;&lt;EnD</span><br><span class="line">lxc.aa_profile = unconfined</span><br><span class="line">lxc.cgroup.devices.allow = a</span><br><span class="line">lxc.cap.drop =</span><br><span class="line">EnD</span><br></pre></td></tr></table></figure><blockquote><p>NOTE: lxc.aa_profile = unconfined应该更正为lxc.apparmor.profile = unconfined，下文会提到</p></blockquote><p>然后修改<code>/etc/pve/lxc/$HOST.conf</code>文件，在文件末尾加上以下内容:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lxc.hook.mount =</span><br><span class="line">lxc.hook.post-stop =</span><br></pre></td></tr></table></figure><h3 id="配置文件中配置项升级后不兼容"><a href="#配置文件中配置项升级后不兼容" class="headerlink" title="配置文件中配置项升级后不兼容"></a>配置文件中配置项升级后不兼容</h3><p>LXC配置文件中配置项名称发生了变化，导致启动报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The configuration file contains legacy configuration keys.</span><br><span class="line">Please update your configuration file!</span><br></pre></td></tr></table></figure><p>好在LXC为我们提供了自动升级配置文件的工具<code>lxc-update-config</code>，切换到容器对应的配置文件目录下: <code>cd /var/lib/lxc/$HOST</code>。使用命令对配置文件进行升级:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc-update-config -c config</span><br></pre></td></tr></table></figure><p>其中<code>lxc.aa_profile = unconfined</code>被自动更正为了<code>lxc.apparmor.profile = unconfined</code></p><h3 id="Redis无法启动"><a href="#Redis无法启动" class="headerlink" title="Redis无法启动"></a>Redis无法启动</h3><p>造成该问题的原因是redis的systemd启动脚本中试图使用一些高级权限，修改/etc/systemd/system/redis.service脚本中下列内容后即可正常使用：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PrivateTmp</span>=<span class="literal">no</span></span><br><span class="line"><span class="attr">PrivateDevices</span>=<span class="literal">no</span></span><br><span class="line"><span class="attr">ProtectHome</span>=<span class="literal">no</span></span><br></pre></td></tr></table></figure><hr><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>那在LXC中运行docker性能如何呢？找了几个常见的工具进行性能测试，UnixBench综合测试性能几乎完全一致，fio磁盘测试性能几乎无损耗，性能差距仅1%，Redis-benchmark数据降低约10%（结果仅供参考）</p><h3 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h3><ul><li>UnixBench:</li></ul><p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/05/UnixBench.png" alt="UnixBench"></p><ul><li>fio</li></ul><p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/05/FIO.png" alt="FIO"></p><ul><li>redis-benchmark</li></ul><p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/05/Redis-benchmark.png" alt="Redis-benchmark"></p><blockquote><p>性能测试方案参考：<a href="https://serverscope.io/trials/GdEN#network" target="_blank" rel="noopener">https://serverscope.io/trials/GdEN#network</a></p></blockquote><hr><h2 id="LXC的缺点"><a href="#LXC的缺点" class="headerlink" title="LXC的缺点"></a>LXC的缺点</h2><ul><li>LXC社区热度远不如Docker，这导致除了问题能查询的有效资料并不如Docker丰富，当然也没有像Docker那么丰富的镜像资源。</li><li>LXC还存在跨不同Linux发行版的功能支持不一致，LXC主要在Ubuntu平台上进行维护和开发。例如目前只有Ubuntu上通过<code>apt-get install docker.io</code>安装的Docker能无需加载任何内核补丁正常运行。</li><li>LXC的官方文档不够详细，学习成本比Docker高。</li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://github.com/moby/moby/issues/6783" target="_blank" rel="noopener">GitHub Issues - Unable to run Docker 1.0 inside LXC</a></li><li><a href="https://github.com/lxc/lxd/issues/3845" target="_blank" rel="noopener">GitHub Issues - All containers emit “The configuration file contains legacy configuration keys” after minor LXD upgrade</a></li><li><a href="https://github.com/lxc/lxd/issues/3799" target="_blank" rel="noopener">GitHub Issues - cant install redis-server on a debian/buster container</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o6sdpimwf.bkt.clouddn.com/LXC-Docker.png&quot; alt=&quot;LXC-Docker&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们知道Docker是如今炙手可热的应用级容器，而LXC可以看作是系统级的容器。那么问题来了，是否可以在一个系统级的容器里面运行一个应用级的容器呢？答案是可以的，不过过程并没有想象的那么容易，百般折腾后部署成功了，在这个过程中也发现了一些问题。
    
    </summary>
    
      <category term="虚拟化" scheme="http://zxh.site/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="容器" scheme="http://zxh.site/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="虚拟化" scheme="http://zxh.site/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="容器" scheme="http://zxh.site/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="LXC" scheme="http://zxh.site/tags/LXC/"/>
    
  </entry>
  
  <entry>
    <title>Linux定制化镜像制作指南</title>
    <link href="http://zxh.site/2018/02/16/Linux%E5%AE%9A%E5%88%B6%E5%8C%96%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%8C%87%E5%8D%97/"/>
    <id>http://zxh.site/2018/02/16/Linux定制化镜像制作指南/</id>
    <published>2018-02-16T13:29:09.000Z</published>
    <updated>2018-05-26T04:19:20.306Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o6sdpimwf.bkt.clouddn.com/customized-cd-3.png" alt="image3"></p><h2 id="为什么需要定制化？"><a href="#为什么需要定制化？" class="headerlink" title="为什么需要定制化？"></a>为什么需要定制化？</h2><p>一款软件的正式发布，往往需要完善各个细节。其中安装部署是否方便友好很大程度上会影响到用户对该产品的易用性的评价。所以我们往往会看到软件厂商会给用户提供安装包，用户只需要一股脑儿的下一步，就可以完成<del>垃圾</del>软件的安装了。但一套大型的系统软件往往会有很多依赖，所以我们不仅要封装软件，最好连运行环境都要进行打包。于是现在很流行给用户提供一个<code>Dockerfile</code>或者<code>docker-compose.yml</code>，让用户开箱即用。但是如果用户需要从裸机开始部署呢？既然连系统都没有，当然是做成安装光盘。系统、软件、依赖环境一股脑全部部署。我们从头说起。<a id="more"></a></p><h2 id="当我谈“定制化Linux安装镜像”，我在定制什么？"><a href="#当我谈“定制化Linux安装镜像”，我在定制什么？" class="headerlink" title="当我谈“定制化Linux安装镜像”，我在定制什么？"></a>当我谈“定制化Linux安装镜像”，我在定制什么？</h2><ul><li>安装界面定制化<ul><li>🎨  <code>Boot Menu</code>定制化</li><li>🎨  <code>Anaconda</code>图形界面定制化</li></ul></li><li>📃  自定义安装信息收集</li><li>📦  配套软件打包</li><li>🤖️  安装自动化</li></ul><h2 id="Linux安装光盘分析"><a href="#Linux安装光盘分析" class="headerlink" title="Linux安装光盘分析"></a>Linux安装光盘分析</h2><p>在网上下载一个Linux系统安装镜像，这里我用的是<code>CentOS-7-x86_64-Minimal-1511.iso</code>，将镜像挂载到开发环境中</p><ul><li>Linux:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/CentOS7</span><br><span class="line">mount -t iso9660 ./CentOS-7-x86_64-Minimal-1511.iso /tmp/CentOS7</span><br></pre></td></tr></table></figure><ul><li>Mac:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/CentOS7</span><br><span class="line">hdiutil attach -nomount ./CentOS-7-x86_64-Minimal-1511.iso</span><br><span class="line">mount -t cd9660 /dev/disk4 /tmp/CentOS7</span><br></pre></td></tr></table></figure><p><img src="http://o6sdpimwf.bkt.clouddn.com/customized-cd-1.png" alt="image1"></p><p>上图即该镜像包含的所有文件，分别介绍一下：</p><ul><li>EFI 负责引导的，包含bootloader</li><li>images PXE安装时需要的内核和引导程序（其实和isolinux中的内核及引导程序是相同的，不知道为啥放两个…）</li></ul><p><img src="http://o6sdpimwf.bkt.clouddn.com/customized-cd-2.png" alt="image2"></p><ul><li>isolinux 系统内核及引导程序</li><li>LiveOS 包含了压缩的rootfs.img</li><li>Packages rpm包</li><li>repodata 安装包源信息</li></ul><p>对于光盘的定制化，我们通常不需要对EFI/images进行任何操作，需要定制的是isolinux、LiveOS中的rootfs.img以及Packages，isolinux影响到进入安装的第一步，rootfs中包含的文件影响安装过程，Packages则是放我们所需要的第三方软件rpm安装包。</p><hr><h2 id="Linux安装流程分析"><a href="#Linux安装流程分析" class="headerlink" title="Linux安装流程分析"></a>Linux安装流程分析</h2><blockquote><p>以下实验环境为CentOS(7.2.1511)，其他发行版本可能略有区别</p></blockquote><p>当我们启动安装光盘时，我们看到的是什么？<br>首先是ISOLINUX Boot Menu</p><p><img src="http://o6sdpimwf.bkt.clouddn.com/customized-cd-3.png" alt="image3"></p><p>然后是Anaconda</p><blockquote><p>Anaconda is the installer used by Red Hat Enterprise Linux, Fedora, and their derivatives.</p></blockquote><p><img src="http://o6sdpimwf.bkt.clouddn.com/customized-cd-4.png" alt="image"></p><p>从光盘加载到系统安装完成经历了什么呢？</p><ol><li>开机</li><li>BIOS检测（硬件检测、引导顺序等）</li><li>读取并运行装置内 MBR 的 boot Loader</li><li>加载内核</li><li>启动liveCD或Anaconda</li><li>由用户配置安装选项或解析kickstart配置</li><li>分区并挂载文件系统</li><li>完成安装，重启</li></ol><blockquote><p>NOTE: 步骤7时的rootfs是LiveOS/squashfs.img中的rootfs.img，而完成安装后的rootfs目前在/mnt/sysimage中</p></blockquote><p>⚠️ <strong>但是我们缺少了重要的“定制化安装信息收集”</strong>，从上面的流程分析可知，可以在Boot Menu和Anaconda之间插一脚（4～5步骤中增加一步），额外收集一些用户提供的安装信息。</p><p>我们需要先找到Anaconda的启动入口，上面已经介绍了如何挂载光盘，接下来我们需要把光盘里面的文件继续展开。因为挂载的ISO是只读的，所以我们需要将文件复制出来，分析修改完文件之后，再重新打包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 挂载光盘💿</span></span><br><span class="line">mkdir /tmp/CentOS7</span><br><span class="line">hdiutil attach -nomount ./CentOS-7-x86_64-Minimal-1511.iso</span><br><span class="line">mount -t cd9660 /dev/disk4 /tmp/CentOS7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制文件</span></span><br><span class="line">mkdir CentOS-7-x86_64-Minimal-1511</span><br><span class="line">rsync -avz /tmp/CentOS7/ CentOS-7-x86_64-Minimal-1511</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制LiveOS</span></span><br><span class="line">cp -r CentOS-7-x86_64-Minimal-1511/LiveOS ./LiveOS</span><br></pre></td></tr></table></figure><p>现在得到了一个包含了squashfs.img的LiveOS文件夹，squashfs.img是干啥的？简单的说它是一个高压缩率的压缩文件，压缩了整个rootfs，看上去只有200多MB，实际上有2GB</p><blockquote><p>Squashfs is a compressed read-only file system for Linux. Squashfs compresses files, inodes and directories, and supports block sizes up to 1 MB for greater compression. Several compression algorithms are supported. Squashfs is also the name of free software, licensed under the GPL, for accessing Squashfs filesystems.</p></blockquote><p>执行命令解压开，你会得到一个包含了<code>LiveOS/rootfs.img</code>的名为<code>squashfs-root</code>的文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsquashfs squashfs.img</span><br></pre></td></tr></table></figure><p><img src="http://o6sdpimwf.bkt.clouddn.com/customized-cd-5.png" alt="image"><br>可以看到该文件其实是<code>ext4</code>的文件系统，启动一个Linux环境，挂载该文件，就能看到里面的所有东西了。这里我用docker启动了一个centos7环境<br><img src="http://o6sdpimwf.bkt.clouddn.com/customized-cd-6.png" alt="image"><br>是不是跟Linux的根目录文件一样？这就是在安装时系统加载的rootfs，而Anaconda的入口文件就是usr/sbin/anaconda，这是一个Python脚本。我们打开它找到它的入口，在这里调用其他的脚本或者程序，就可以在Anaconda之前插一脚了。这里我自己写了一个小程序来收集用户的信息，在anaconda的入口处先调用这个程序。<br><img src="http://o6sdpimwf.bkt.clouddn.com/customized-cd-7.png" alt="image"></p><p>修改完毕之后，我们需要重新压缩squashfs.img</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mksquashfs squashfs-root squashfs.img -b 1024k -comp xz</span><br></pre></td></tr></table></figure><p>把新的squashfs.img替换复制出来的光盘镜像文件中的squashfs.img。用dd命令将原来的iso引导信息导出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo cp squashfs.img CentOS-7-x86_64-Minimal-1511/LiveOS/</span><br><span class="line">dd <span class="keyword">if</span>=CentOS-7-x86_64-Minimal-1511.iso bs=512 count=1 of=boot.mbr</span><br></pre></td></tr></table></figure><p>最后重新制作iso镜像，这里我用的是<code>xorriso</code>，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xorriso -pathspecs as_mkisofs -as mkisofs -iso-level 3 -full-iso9660-filenames -volid <span class="string">"CentOS 7 x86_64"</span> -appid  -publisher  -preparer <span class="string">"prepared by me"</span> -eltorito-boot isolinux/isolinux.bin -eltorito-catalog isolinux/boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table -isohybrid-mbr ../boot.mbr -eltorito-alt-boot -e images/efiboot.img -no-emul-boot -isohybrid-gpt-basdat -output ../repacked.iso .</span><br></pre></td></tr></table></figure><p>现在让我们看看repacked.iso运行起来是什么样的吧：<br><img src="http://o6sdpimwf.bkt.clouddn.com/customized-cd-8.png" alt="image"></p><hr><h2 id="界面定制化"><a href="#界面定制化" class="headerlink" title="界面定制化"></a>界面定制化</h2><h3 id="Boot-Menu定制"><a href="#Boot-Menu定制" class="headerlink" title="Boot Menu定制"></a>Boot Menu定制</h3><p>只需要修改isolinux/isolinux.cfg文件，文档参考：<a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/anaconda_customization_guide/sect-boot-menu-customization" target="_blank" rel="noopener">boot-menu-customization</a> </p><h3 id="Anaconda界面定制"><a href="#Anaconda界面定制" class="headerlink" title="Anaconda界面定制"></a>Anaconda界面定制</h3><p>Anaconda界面定制的修改稍微复杂一些，需要修改css文件，文档参考：<a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/anaconda_customization_guide/sect-anaconda-visuals#sect-anaconda-visuals-graphics" target="_blank" rel="noopener">customized-anaconda</a></p><hr><h2 id="自动化脚本（未完待续）"><a href="#自动化脚本（未完待续）" class="headerlink" title="自动化脚本（未完待续）"></a>自动化脚本（未完待续）</h2><h3 id="kickstart"><a href="#kickstart" class="headerlink" title="kickstart"></a>kickstart</h3><h3 id="程序部署脚本"><a href="#程序部署脚本" class="headerlink" title="程序部署脚本"></a>程序部署脚本</h3><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/anaconda_customization_guide/" target="_blank" rel="noopener">ANACONDA CUSTOMIZATION GUIDE</a> </li><li><a href="https://anaconda-installer.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">anaconda文档</a></li><li><a href="http://blog.csdn.net/trochiluses/article/details/17674415" target="_blank" rel="noopener">Linux安装过程分析</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/1306_qinzl_squashfs/" target="_blank" rel="noopener">基于 SquashFS 构建 Linux 可读写文件系统</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o6sdpimwf.bkt.clouddn.com/customized-cd-3.png&quot; alt=&quot;image3&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;为什么需要定制化？&quot;&gt;&lt;a href=&quot;#为什么需要定制化？&quot; class=&quot;headerlink&quot; title=&quot;为什么需要定制化？&quot;&gt;&lt;/a&gt;为什么需要定制化？&lt;/h2&gt;&lt;p&gt;一款软件的正式发布，往往需要完善各个细节。其中安装部署是否方便友好很大程度上会影响到用户对该产品的易用性的评价。所以我们往往会看到软件厂商会给用户提供安装包，用户只需要一股脑儿的下一步，就可以完成&lt;del&gt;垃圾&lt;/del&gt;软件的安装了。但一套大型的系统软件往往会有很多依赖，所以我们不仅要封装软件，最好连运行环境都要进行打包。于是现在很流行给用户提供一个&lt;code&gt;Dockerfile&lt;/code&gt;或者&lt;code&gt;docker-compose.yml&lt;/code&gt;，让用户开箱即用。但是如果用户需要从裸机开始部署呢？既然连系统都没有，当然是做成安装光盘。系统、软件、依赖环境一股脑全部部署。我们从头说起。
    
    </summary>
    
      <category term="Linux" scheme="http://zxh.site/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://zxh.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>简单聊聊元编程</title>
    <link href="http://zxh.site/2018/02/01/meta-programming/"/>
    <id>http://zxh.site/2018/02/01/meta-programming/</id>
    <published>2018-02-01T13:48:10.000Z</published>
    <updated>2018-05-26T04:19:54.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o6sdpimwf.bkt.clouddn.com/blog/2017-02-01/code.png" alt="auto"></p><h2 id="什么是元编程"><a href="#什么是元编程" class="headerlink" title="什么是元编程"></a>什么是元编程</h2><p>编程，字面意思即编写程序。</p><p>那什么是元编程呢？广义的看，我认为让任何事物按照特定的指令执行特定的动作，就可以算作编程。如果我是一个教官，组织一百号人军训，我让所有人报数，其实也算编程。不过因为人很聪明，所以我只需要一个简单的指令，就完成了这次“编程”。每一个人，我们都可以认为是一个元，Ta能够自动生成剩余的指令。元编程，其实就是一种高级抽象，让代码去写代码，让指令自动转化成代码。<a id="more"></a>实际上我们绝大多数人写的代码都是高级语言，编译器或者解释器会翻译代码，生成大量的机器指令，让电脑去做正确的事。再以前端开发来说，现在炙手可热的各大框架，实际上都有元编程的思想。模版、组件化等等技术其实都是利用了这个思想。所以可以说元编程就在我们身边。</p><hr><h2 id="了解元编程有什么用？"><a href="#了解元编程有什么用？" class="headerlink" title="了解元编程有什么用？"></a>了解元编程有什么用？</h2><p>简单的说就四个字——“少写代码”。</p><h2 id="如何进行元编程？"><a href="#如何进行元编程？" class="headerlink" title="如何进行元编程？"></a>如何进行元编程？</h2><p>其实我们也许在不经意间用过很多次，但是我们没有重视。我想起一本名为《写给大家看的设计书》中提到的“约书亚树”，其中有一段话是这么说的：</p><blockquote><p>一旦能够说出什么东西的名字，就会很容易注意到它。你就会掌握它，拥有它，让它受你所控。</p></blockquote><p>这两天我自己写了一个用来收集用户提供的配置信息的小程序，由于我们的运维工程师不懂代码，但是这个东西又需要由他来完善，于是我将那部分代码提出来，做成了一个JSON文件，当他希望这个程序收集更多用户信息时，只需要改这个文件，我的程序就会自动生成相应的交互。这里贴一点点代码。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run starts the installer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ......</span><br><span class="line">data, err := ioutil.ReadFile(*optionsJSON)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"can't read options.json file: %v"</span>, err))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dataJSON []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">err = json.Unmarshal(data, &amp;dataJSON)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"can't parse JSON file: %v"</span>, err))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, d := <span class="keyword">range</span> dataJSON &#123;</span><br><span class="line">option, err := parseOption(d)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"can't parse JSON file: %v"</span>, err))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> opt, ok := option.(Option); ok &#123;</span><br><span class="line">m.GetInput(opt)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> opt, ok := option.(Options); ok &#123;</span><br><span class="line">m.GetSelect(opt)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetSelect gets users select in given options.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">GetSelect</span><span class="params">(opts Options)</span></span> &#123;</span><br><span class="line">printOptionsHint(opts)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Scanf(<span class="string">"%d"</span>, &amp;opts.Index)</span><br><span class="line"><span class="keyword">if</span> opts.Index &gt; <span class="built_in">len</span>(opts.Opts)+<span class="number">1</span> || opts.Index &lt;= <span class="number">0</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"invalid input(%d), retry please\n"</span>, opts.Index)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Selected: %s\n"</span>, opts.Opts[opts.Index<span class="number">-1</span>].Desc)</span><br><span class="line">m.result = <span class="built_in">append</span>(m.result, Configuration&#123;</span><br><span class="line">Desc:  opts.Desc,</span><br><span class="line">Key:   opts.Key,</span><br><span class="line">Value: opts.Opts[opts.Index<span class="number">-1</span>].Value,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printOptionsHint</span><span class="params">(opts Options)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Please select %s:\n"</span>, opts.Desc)</span><br><span class="line"><span class="keyword">for</span> index, opt := <span class="keyword">range</span> opts.Opts &#123;</span><br><span class="line">fmt.Printf(<span class="string">"[%d]: %s\n"</span>, index+<span class="number">1</span>, opt.Desc)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> opts.Index != <span class="number">0</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Default value is: %s\n"</span>, opts.Opts[opts.Index<span class="number">-1</span>].Desc)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printOptionHint</span><span class="params">(opt Option)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Please set %s:\n"</span>, opt.Desc)</span><br><span class="line"><span class="keyword">if</span> opt.Value != <span class="string">""</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Default value is: %s\n"</span>, opt.Value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetInput gets users input.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">GetInput</span><span class="params">(opt Option)</span></span> &#123;</span><br><span class="line">printOptionHint(opt)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> temp <span class="keyword">string</span></span><br><span class="line">fmt.Scanf(<span class="string">"%s"</span>, &amp;temp)</span><br><span class="line"><span class="keyword">if</span> temp != <span class="string">""</span> &#123;</span><br><span class="line">opt.Value = temp</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> opt.Tag != <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := valid.Var(opt.Value, opt.Tag); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"invalid input(%s), retry please\n"</span>, opt.Value)</span><br><span class="line">opt.Value = <span class="string">""</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Set %s:%s\n"</span>, opt.Desc, opt.Value)</span><br><span class="line">m.result = <span class="built_in">append</span>(m.result, Configuration&#123;</span><br><span class="line">Desc:  opt.Desc,</span><br><span class="line">Key:   opt.Key,</span><br><span class="line">Value: opt.Value,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部分JSON文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"Desc"</span>: <span class="string">"Authorization suite"</span>,</span><br><span class="line">        <span class="attr">"Key"</span>: <span class="string">"AuthProvider"</span>,</span><br><span class="line">        <span class="attr">"Index"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"Opts"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"Desc"</span>: <span class="string">"Basic (Standard Linux PAM)"</span>,</span><br><span class="line">                <span class="attr">"Value"</span>: <span class="string">"Basic"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"Desc"</span>: <span class="string">"NIS (Network Information Service)"</span>,</span><br><span class="line">                <span class="attr">"Value"</span>: <span class="string">"NIS"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"Desc"</span>: <span class="string">"LDAP (Lightweight Directory Access Protocol)"</span>,</span><br><span class="line">                <span class="attr">"Value"</span>: <span class="string">"LDAP"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line"><span class="attr">"Key"</span>:   <span class="string">"InterfaceHost"</span>,</span><br><span class="line"><span class="attr">"Desc"</span>:  <span class="string">"Host network interface name(eg: eth0)"</span>,</span><br><span class="line"><span class="attr">"Value"</span>: <span class="string">""</span>,</span><br><span class="line"><span class="attr">"Tag"</span>:   <span class="string">"required"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>运行效果：<br><img src="http://o6sdpimwf.bkt.clouddn.com/2017-02-01.png" alt="auto"></p><p>这里并不是要用代码来介绍元编程，而是在这里抛砖引玉让大家了解这个概念，记住这个概念，应用到自己的代码里。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o6sdpimwf.bkt.clouddn.com/blog/2017-02-01/code.png&quot; alt=&quot;auto&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是元编程&quot;&gt;&lt;a href=&quot;#什么是元编程&quot; class=&quot;headerlink&quot; title=&quot;什么是元编程&quot;&gt;&lt;/a&gt;什么是元编程&lt;/h2&gt;&lt;p&gt;编程，字面意思即编写程序。&lt;/p&gt;
&lt;p&gt;那什么是元编程呢？广义的看，我认为让任何事物按照特定的指令执行特定的动作，就可以算作编程。如果我是一个教官，组织一百号人军训，我让所有人报数，其实也算编程。不过因为人很聪明，所以我只需要一个简单的指令，就完成了这次“编程”。每一个人，我们都可以认为是一个元，Ta能够自动生成剩余的指令。元编程，其实就是一种高级抽象，让代码去写代码，让指令自动转化成代码。
    
    </summary>
    
      <category term="经验&amp;技巧" scheme="http://zxh.site/categories/%E7%BB%8F%E9%AA%8C-%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="经验&amp;技巧" scheme="http://zxh.site/tags/%E7%BB%8F%E9%AA%8C-%E6%8A%80%E5%B7%A7/"/>
    
      <category term="元编程" scheme="http://zxh.site/tags/%E5%85%83%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Golang实现并行命令</title>
    <link href="http://zxh.site/2017/06/24/parallel-command/"/>
    <id>http://zxh.site/2017/06/24/parallel-command/</id>
    <published>2017-06-24T06:16:08.000Z</published>
    <updated>2018-05-26T03:56:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o6sdpimwf.bkt.clouddn.com/uploads/2017/06/parallel.jpg" alt="Gotty"> </p><p>在集群中经常我们会需要在多个节点上执行相同的操作，有不少的软件能帮助我们实现这样的需求，例如大名鼎鼎的Salt，或者更加轻量级的dsh。但是一方面如果在我们自己编写的程序里面再调用这些软件获取并行命令的输出结果，这个命令的执行其实是阻塞的，需要一直等待salt/dsh命令执行完毕后获取输出。<a id="more"></a>另一方面引入salt这样的软件会给部署和维护带来更大的成本，而实际上我们用到的功能仅仅是salt的一小部分，实在是有些得不偿失。如果我们想不依赖其他软件，自己实现一个简单的并行命令的功能，难度会如何呢？这篇文章就为大家介绍一下我是如何利用Redis和共享存储实现简单的并行命令的。</p><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><ul><li>支持异步批量执行命令<ul><li>命令执行</li><li>权限控制</li></ul></li><li>能实时查询执行结果<ul><li>结果输出</li><li>对命令输出做限制</li></ul></li><li>支持命令终止</li></ul><h2 id="大体思路"><a href="#大体思路" class="headerlink" title="大体思路"></a>大体思路</h2><p>MySQL存储命令的基本信息并生成ID，利用Redis分发消息。在集群环境中通常都会有共享存储（这里我们假设所有节点的/home目录均是共享存储），我们只需将命令执行结果以文件形式重定向到共享存储下，文件以一定的编码规律存放，例如<code>/home/pcm/$CommandID/$hostname.out</code>、<code>/home/pcm/$CommandID/$hostname.err</code>.这样查询命令输出结果时只需要遍历该命令ID路径下的所有输出结果即可。（大名鼎鼎的集群调度软件Slurm其实也是采用了类似的做法）为了实现命令终止以及获得可靠的命令执行结果判断，我们需要将pid记录回Redis，另外将所有的<code>exit code</code>记录到文件中以备查询。</p><h3 id="支持异步批量执行命令"><a href="#支持异步批量执行命令" class="headerlink" title="支持异步批量执行命令"></a>支持异步批量执行命令</h3><h4 id="插入命令"><a href="#插入命令" class="headerlink" title="插入命令"></a>插入命令</h4><p>这一步很简单，利用MySQL生成一个自增的ID，然后将命令丢给agent，agent会将消息经过Redis分发到节点上。具体代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start starts run parallel command on nodes, it returns the command ID if</span></span><br><span class="line"><span class="comment">// start successfully.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PcmManager)</span> <span class="title">Start</span><span class="params">(req *Req)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">command := mdef.Pcm&#123;</span><br><span class="line">UID:       req.UID,</span><br><span class="line">StartTime: time.Now().Unix(),</span><br><span class="line">Command:   req.Command,</span><br><span class="line">Nodes:     strings.Join(req.Nodes, <span class="string">","</span>),</span><br><span class="line">&#125;</span><br><span class="line">err = p.db.Insert(&amp;command)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">&#125;</span><br><span class="line">err = p.agent.DoPcm(command.ID, command.UID, req.Command, req.Nodes)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> command.ID, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="下发命令"><a href="#下发命令" class="headerlink" title="下发命令"></a>下发命令</h4><p>前端请求参数包含命令内容以及一个由节点名(hostname)构成的字符数组，收到请求后，将命令经过Redis下发。这里有两种不同的方式：</p><ol><li>利用Redis的Pub/Sub机制，所有的节点都订阅一个消息，例如$hostname:pcm，主机往这个key上发布消息，所有的节点都会收到这个消息然后处理。</li><li>利用list做消息队列，内容放入Redis的消息队列中，例如key是$hostname:pcm，主机使用LPUSH命令将消息压入，所有节点均由一个goroutine利用BRPOP轮询。 </li></ol><p>两种方式没有优劣之分，只是根据需求来确定你需要的方式，方法1让所有在线的节点可以执行指令，但关机的节点不会执行。而方法二就算节点关机，一旦开机之后就可以执行之前的命令。这个根据自己需求选择即可。  </p><p>agent部分负责分发消息、监控消息，由于监控消息的方式有不同，具体大家自己去按自己的思路实现即可，这里只贴出分发的代码：  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DoPcm pushes command info into Redis, pcmExecutor will pop and execute it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">DoPcm</span><span class="params">(cid, uid <span class="keyword">int</span>, command <span class="keyword">string</span>, nodes []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">pcm := Pcm&#123;</span><br><span class="line">CID:     cid,</span><br><span class="line">UID:     uid,</span><br><span class="line">Command: command,</span><br><span class="line">Nodes:   nodes,</span><br><span class="line">&#125;</span><br><span class="line">data, err := json.Marshal(pcm)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(def.ErrGeneralJSONMarshal,</span><br><span class="line">fmt.Sprintf(<span class="string">"can't marshal JSON data:%v"</span>, err))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fails []<span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> _, node := <span class="keyword">range</span> nodes &#123;</span><br><span class="line">key := fmt.Sprintf(<span class="string">"agent:%s:pcm:todo"</span>, node)</span><br><span class="line">_, err := store.Do(<span class="string">"LPUSH"</span>, key, <span class="keyword">string</span>(data))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fails = <span class="built_in">append</span>(fails, node)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(fails) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(def.ErrAgentBatchExec,</span><br><span class="line">fmt.Sprintf(<span class="string">"failed to run cmd:%s on following nodes:%s"</span>,</span><br><span class="line">data, strings.Join(fails, <span class="string">","</span>)))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h4><p>节点拿到消息后调用exec.Command执行命令，但这里需要修改一下输出定向，记录pid以备终止命令时使用，将错误退出码记录到文件，以用户权限执行命令。具体范例代码如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">pcmExec</span><span class="params">(pcm *Pcm)</span></span> &#123;</span><br><span class="line">dir := fmt.Sprintf(<span class="string">"/home/pcm/%d"</span>, pcm.CID)</span><br><span class="line">hostName, err := os.Hostname()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logs.Error(<span class="string">"pcmExec can't get hostname: %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">err = os.MkdirAll(dir, <span class="number">0755</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logs.Error(<span class="string">"pcmExec can't create pcm execute directory: %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">stdoutFilename := fmt.Sprintf(<span class="string">"%s/%s.out"</span>, dir, hostName)</span><br><span class="line">stderrFilename := fmt.Sprintf(<span class="string">"%s/%s.err"</span>, dir, hostName)</span><br><span class="line">exitCodeFilename := fmt.Sprintf(<span class="string">"%s/%s.exit"</span>, dir, hostName)</span><br><span class="line">stdout, err := os.Create(stdoutFilename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logs.Error(<span class="string">"pcmExec can't create stdout file: %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">stderr, err := os.Create(stderrFilename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logs.Error(<span class="string">"pcmExec can't create stderr file: %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">exitFlag, err := os.Create(exitCodeFilename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logs.Error(<span class="string">"pcmExec can't create exit flag file: %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> exitFlag.Close()</span><br><span class="line">command, err := su.Command(pcm.UID, <span class="string">"bash"</span>, <span class="string">"-c"</span>, pcm.Command)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logs.Error(<span class="string">"pcmExec can't generate command in user's credential:%v"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">command.Stderr = stderr</span><br><span class="line">command.Stdout = stdout</span><br><span class="line">err = command.Start()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logs.Error(<span class="string">"pcmExec can't start command: %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">pid := command.Process.Pid</span><br><span class="line">c := m.redisPool.Get()</span><br><span class="line"><span class="keyword">defer</span> c.Close()</span><br><span class="line">key := fmt.Sprintf(<span class="string">"hpc:pcm:pids:%d"</span>, pcm.CID)</span><br><span class="line">_, err = c.Do(<span class="string">"HSET"</span>, key, hostName, pid)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logs.Error(<span class="string">"pcmExec can't write pid into Redis: %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := command.Wait(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> exiterr, ok := err.(*exec.ExitError); ok &#123;</span><br><span class="line"><span class="keyword">if</span> status, ok := exiterr.Sys().(syscall.WaitStatus); ok &#123;</span><br><span class="line">fmt.Fprintf(exitFlag, <span class="string">"%d"</span>, status.ExitStatus())</span><br><span class="line">logs.Error(<span class="string">"Pcm exit status: %d"</span>, status.ExitStatus())</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// unknown code 999</span></span><br><span class="line">fmt.Fprintf(exitFlag, <span class="string">"%d"</span>, <span class="number">999</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Fprintf(exitFlag, <span class="string">"%d"</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上内容中的<code>su.Command(pcm.UID, &quot;bash&quot;, &quot;-c&quot;, pcm.Command)</code>其实只是封装了一下Command命令，以特定的用户身份运行命令，具体代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Command creates a new exec.Cmd that will run with user privilege.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Command</span><span class="params">(uid <span class="keyword">int</span>, command <span class="keyword">string</span>, args ...<span class="keyword">string</span>)</span> <span class="params">(*exec.Cmd, error)</span></span> &#123;</span><br><span class="line">cred, err := getUserCred(uid)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">cmd := exec.Command(command, args...)</span><br><span class="line">cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;&#125;</span><br><span class="line">cmd.SysProcAttr.Credential = cred</span><br><span class="line"><span class="keyword">return</span> cmd, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="监控命令输出"><a href="#监控命令输出" class="headerlink" title="监控命令输出"></a>监控命令输出</h4><p>因为我们记录了pid到Redis，所以当命令执行完毕之后，应该清除掉这个pid。因为每条命令执行完毕之后，我都会将exit code记录到文件中，所以一旦有这个文件生成，则说明命令执行完毕了。这里我利用了’监听’共享存储的写入事件来确定一条命令执行完毕，而路径中已经包含了ID信息使得我可以方便的确定是哪条命令执行完毕了，使用到了<code>&quot;github.com/rjeczalik/notify&quot;</code>，大致代码如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Watch sets up a watchpoint on the cmdOutputDir, the command output will be</span></span><br><span class="line"><span class="comment">// redirected into cmdOutputDir as file, Watch catches the event, then deletes</span></span><br><span class="line"><span class="comment">// the pid which recorded in Redis.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PcmManager)</span> <span class="title">Watch</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> notify.EventInfo, p.chanBufferSize)</span><br><span class="line">err := notify.Watch(p.cmdOutputDir+<span class="string">"/..."</span>, c, notify.Write)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logs.Critical(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> notify.Stop(c)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">e := &lt;-c</span><br><span class="line">path := e.Path()</span><br><span class="line"><span class="keyword">if</span> !strings.Contains(path, <span class="string">".exit"</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">cid, hostname, err := p.parseHostnameAndCID(path)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logs.Error(<span class="string">"Pcm watcher catches an unexpected error: %v"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">key := fmt.Sprintf(<span class="string">"hpc:pcm:pids:%s"</span>, cid)</span><br><span class="line">_, err = store.Do(<span class="string">"HDEL"</span>, key, hostname)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logs.Error(<span class="string">"Pcm watcher can't remove pids cached in Redis: %v"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上则已经实现了一个并行命令的基本功能。接下来就是查询和终止命令。</p><h3 id="查询执行结果"><a href="#查询执行结果" class="headerlink" title="查询执行结果"></a>查询执行结果</h3><p>经过上面的步骤我们已经把各个节点的命令输出重定向到了特定的目录下，所以只需要知道命令ID，去遍历那个目录下的文件稍加解析，即可获取到这条命令的执行情况。这部分内容比较简单，大家自行实现即可。需要稍加注意的是有的命令可能输出内容很长，所以我们应该利用buffer读取特定长度的内容，而不是直接返回所有内容。大致代码如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PcmManager)</span> <span class="title">readOutputFile</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="params">(content <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">trimmed <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, p.maxOutput)</span><br><span class="line">f, err := os.Open(filename)</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">n, err := f.Read(buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != io.EOF &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> n &gt;= p.maxOutput &#123;</span><br><span class="line">trimmed = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">content = <span class="keyword">string</span>(buf[:n])</span><br><span class="line"><span class="keyword">return</span> content, trimmed, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="终止命令"><a href="#终止命令" class="headerlink" title="终止命令"></a>终止命令</h3><p>执行某些命令可能比较耗时，例如我执行一条命令<code>sleep 300 &amp;&amp; hostname</code>，即在300秒后输出节点的hostname，这时候我们想终止这条命令的执行怎么办呢？我们已经在Redis中以hash表（key：hostname，value：pid）记录过了每个节点上执行的那条命令的pid，所以我们只需要取出这条命令的所有的pid以及对应的主机名就好啦，然后就在各个节点上杀掉特定的进程即可。对了别忘记更新一下MySQL中命令的状态哦。这里有一点需要注意的是我们记录的pid有可能只是一个父进程ID，而<code>sleep 300 &amp;&amp; hostname</code>这样的命令其实会产生两个pid，所以我们要将他们一起杀掉。这里建议大家直接使用<code>pkill -TERM -P $pid</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好啦。具体就介绍到这里了，相信大家已经都能根据上述内容实现一个简单的并行命令需求啦！其实核心就是消息的分发以及命令重定向到共享存储，这也是在分布式系统开发中经常用到的技巧，灵活利用能实现很多实用又有趣的功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o6sdpimwf.bkt.clouddn.com/uploads/2017/06/parallel.jpg&quot; alt=&quot;Gotty&quot;&gt; &lt;/p&gt;
&lt;p&gt;在集群中经常我们会需要在多个节点上执行相同的操作，有不少的软件能帮助我们实现这样的需求，例如大名鼎鼎的Salt，或者更加轻量级的dsh。但是一方面如果在我们自己编写的程序里面再调用这些软件获取并行命令的输出结果，这个命令的执行其实是阻塞的，需要一直等待salt/dsh命令执行完毕后获取输出。
    
    </summary>
    
      <category term="后端" scheme="http://zxh.site/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Golang" scheme="http://zxh.site/categories/%E5%90%8E%E7%AB%AF/Golang/"/>
    
    
      <category term="Golang" scheme="http://zxh.site/tags/Golang/"/>
    
      <category term="后端" scheme="http://zxh.site/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Golang实现多节点Web终端</title>
    <link href="http://zxh.site/2017/04/01/web-tty/"/>
    <id>http://zxh.site/2017/04/01/web-tty/</id>
    <published>2017-04-01T10:07:04.000Z</published>
    <updated>2018-05-26T03:59:03.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o6sdpimwf.bkt.clouddn.com/uploads/2017/04/screenshot.gif" alt="Gotty"><br>熟悉Linux或MacOS的同学都应该对终端并不陌生，诸如XShell、PuTTY这样的工具大家也应该很熟悉。如今各种私有云、公有云、虚拟化技术正在蓬勃发展，工作在集群之上的Web应用程序如果能够提供可以执行命令的终端窗口，将大大改善用户的使用体验。这篇文章就跟大家介绍一下我是如何利用Golang实现支持多节点多用户的Web终端。<a id="more"></a></p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>假设一个用户拥有若干台机器的管理权限，如果能够直接在Web界面上直接登陆任意节点，将给用户带来更好的使用体验。而实现这一功能的几大难点在于：</p><ol><li>供用户访问的Web服务启动在管理节点上，其他节点与管理节点之间通过内网连接，不能被直接访问；</li><li>该系统支持多个用户同时操作；</li><li>每个用户应该以自己的用户身份登陆节点。  </li></ol><p>要实现上述需求，首先WebServer要支持代理请求，并且在计算节点上要能够动态的同时启动多个tty服务。本着“避免重复造轮子”的原则，我先上著名同性交友网站GayHub进行了一番搜寻，最后发现了两个不错的工具能够实现我的需求：</p><blockquote><p><a href="https://github.com/yudai/gotty" target="_blank" rel="noopener">GoTTY</a> is a simple command line tool that turns your CLI tools into web applications.<br><a href="https://github.com/koding/websocketproxy" target="_blank" rel="noopener">WebsocketProxy </a> is an http.Handler interface build on top of gorilla/websocket that you can plug into your existing Go webserver to provide WebSocket reverse proxy.  </p></blockquote><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="启动多个GoTTY实例"><a href="#启动多个GoTTY实例" class="headerlink" title="启动多个GoTTY实例"></a>启动多个GoTTY实例</h3><p>要支持多用户不同身份同时访问，显然我们必须启动多个GoTTY服务，因为无法预计用户的身份和规模，我们不能在每个节点上预先启动多个服务，而应该动态的接受管理节点的命令去启动服务。这一步很简单，最简单的方法是直接在管理节点上执行ssh命令，更好的方式则是在管理节点和计算节点之间实现消息队列的机制，计算节点上能获取到管理节点的命令并执行。这里我利用Redis在管理节点和计算节点之间实现了Agent，这不是这篇文章的重点，所以具体方法这里不赘述。<br>简而言之我已经实现了动态的在计算节点上接收命令以不同身份在不同的接口启动多个GoTTY。</p><h3 id="反向代理GoTTY接口"><a href="#反向代理GoTTY接口" class="headerlink" title="反向代理GoTTY接口"></a>反向代理GoTTY接口</h3><p>下载GoTTY运行后发现这个程序做得非常巧妙，它利用go-bindata将所有静态文件都打包到了二进制文件中，程序编译后只有一个可执行程序，但却能够提供web服务，我通过Chrome调试工具查看了它的网络请求，摸清了它的基本原理，其前端核心是一个websocket请求。前端没有秘密，我只需要将静态文件拆分出来单独提供文件服务就可以使用。于是我尝试在一台计算节点上启动gotty服务，将接口设置了代理，拆分出静态文件，发现服务能正常工作，这意味着成功了一半。</p><p>在Web服务中proxy是很常见的，但大都是通过专门的软件去实现，并且这还是一个Websocket的接口，而WebsocketProxy恰好提供了这样的功能。利用WebsocketProxy我们只需要添加几行简单的代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">agentURL := fmt.Sprintf(<span class="string">"ws://%s:%d/ws"</span>, nodeIP, ttyPort)</span><br><span class="line">u, err := url.Parse(agentURL)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line">proxyHandler := websocketproxy.NewProxy(u)</span><br></pre></td></tr></table></figure></p><p>接下来只需要动态新增这样一个Handler即可。</p><h3 id="动态新增HTTP-Handler"><a href="#动态新增HTTP-Handler" class="headerlink" title="动态新增HTTP Handler"></a>动态新增HTTP Handler</h3><p>我的Web Server采用了Beego框架，仔细阅读框架文档和代码后发现Beego的<a href="https://godoc.org/github.com/astaxie/beego#Handler" target="_blank" rel="noopener">App.Handler</a>能用来添加一个新的HTTP Handler,如果我在一个已有的HTTP Handler中调用该方法，则可以实现动态的增加一个Handler。我们只需要在上述代码的基础上再添加两行：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wsURL := fmt.Sprintf(<span class="string">"/ws_%s%d"</span>, nodeName, ttyPort)</span><br><span class="line">beego.Handler(wsURL, proxyHandler)</span><br></pre></td></tr></table></figure></p><p>如此一来我们就动态的新增了一个handler，并且它的url是根据节点名和端口号动态变化的，接下来我们只需要告诉前端去这个新的URL上建立websocket连接即可。</p><h3 id="修改GoTTY前端代码"><a href="#修改GoTTY前端代码" class="headerlink" title="修改GoTTY前端代码"></a>修改GoTTY前端代码</h3><p>简单分析一下GoTTY的前端代码，发现作者真的具备很强的工具整合能力，自己手写的代码只有寥寥数行，其余均是直接采用第三方库。上面我们已经成功的在计算节点上启动了GoTTY并且动态的新增了Handler，但前端代码中请求的地址是不会变的，所以我们要对它进行修改，让前端知道应该去访问哪个接口。<br>原理很简单，我们让Golang的HTTP Handler跳转到GoTTY的静态文件上，并且带上参数，让前端能获取并使用这个参数就行了，在Go中新增:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redirectURL := fmt.Sprintf(<span class="string">"/tty/index.html?NodeName=%s%d"</span>, nodeName, ttyPort)</span><br><span class="line">n.Redirect(redirectURL, <span class="number">302</span>)</span><br></pre></td></tr></table></figure></p><p>在gotty.js中新增：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nodeName = getQueryString(<span class="string">"NodeName"</span>)</span><br><span class="line"><span class="keyword">var</span> url = (httpsEnabled ? <span class="string">'wss://'</span> : <span class="string">'ws://'</span>) + <span class="built_in">window</span>.location.host + <span class="string">'/ws_'</span> + nodeName;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryString</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"(^|&amp;)"</span> + name + <span class="string">"=([^&amp;]*)(&amp;|$)"</span>, <span class="string">"i"</span>);</span><br><span class="line">    <span class="keyword">var</span> r = <span class="built_in">window</span>.location.search.substr(<span class="number">1</span>).match(reg);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">unescape</span>(r[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>大功告成~试试神奇的体验吧</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>虽然上述代码已经比较完美的实现了一个多用户多节点的Web终端，但是还有一些小问题比如HTTP新增的路由没有动态的得到释放，在用户规模极大的情况下会影响WebServer的性能，查看Beego源码后发现没有提供删除Handler的功能，后续有时间我会尝试解决该问题后向Beego提交Pull Request。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o6sdpimwf.bkt.clouddn.com/uploads/2017/04/screenshot.gif&quot; alt=&quot;Gotty&quot;&gt;&lt;br&gt;熟悉Linux或MacOS的同学都应该对终端并不陌生，诸如XShell、PuTTY这样的工具大家也应该很熟悉。如今各种私有云、公有云、虚拟化技术正在蓬勃发展，工作在集群之上的Web应用程序如果能够提供可以执行命令的终端窗口，将大大改善用户的使用体验。这篇文章就跟大家介绍一下我是如何利用Golang实现支持多节点多用户的Web终端。
    
    </summary>
    
      <category term="后端" scheme="http://zxh.site/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Golang" scheme="http://zxh.site/categories/%E5%90%8E%E7%AB%AF/Golang/"/>
    
    
      <category term="Golang" scheme="http://zxh.site/tags/Golang/"/>
    
      <category term="后端" scheme="http://zxh.site/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7自动部署(PXE+Kickstart)</title>
    <link href="http://zxh.site/2017/03/06/CentOS7AutoDeploy/"/>
    <id>http://zxh.site/2017/03/06/CentOS7AutoDeploy/</id>
    <published>2017-03-06T08:07:04.000Z</published>
    <updated>2018-05-26T04:14:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o6sdpimwf.bkt.clouddn.com/uploads/2017/03/auto.jpg" alt="AutoDeploy"><br>在程序部署的过程中我们经常需要批量部署操作系统，本着“能自动化的绝不手动做”的原则，显然重复部署操作系统这种活儿，我们应该交给脚本去完成。这篇文章就跟大家分享一下如何基于<code>PXE</code>、<code>Kickstart</code>以及<code>dnsmasq</code>实现CentOS7自动部署。<a id="more"></a></p><hr><h2 id="什么是PXE"><a href="#什么是PXE" class="headerlink" title="什么是PXE"></a>什么是PXE</h2><p>PXE(Pre-boot Execution Environment，预启动执行环境)其实是一种算得上“古老”的技术，Intel和Systemsoft早在1999年对外发布了<a href="http://download.intel.com/design/archives/wfm/downloads/pxespec.pdf" target="_blank" rel="noopener">PXE2.1规范</a>，而PXE背后的概念起源于BOOTP/DHCP/TFTP协议的早期阶段，所以严格来说它的历史可以追溯到1985年之前。这项技术诞生的主要目的就是通过网络进行操作系统的自动化部署。  </p><p>简单来说，PXE就是用来通过网络进行操作系统的自动化部署的一种技术集合，它依赖于DHCP以及TFTP服务，每一台支持PXE启动的机器都可以看作一台PXE Client(PXE Client的ROM中包含TFTP Client)，PXE Client会向其所在网络中的DHCP服务索取IP地址以及PXE文件位置，之后经过TFTP服务器获取并执行pxelinux.0、pxelinux.cfg、vmlinuz、initrd.img等文件，实现系统的下载、引导以及安装。其具体原理可以参考<a href="https://en.wikipedia.org/wiki/Preboot_Execution_Environment" target="_blank" rel="noopener">维基百科</a>。 </p><p><img src="http://o6sdpimwf.bkt.clouddn.com/uploads/2017/03/PXE.jpg" alt="原理图"></p><h2 id="那什么是Kickstart呢"><a href="#那什么是Kickstart呢" class="headerlink" title="那什么是Kickstart呢"></a>那什么是Kickstart呢</h2><p>手动安装操作系统的时候，往往有很多选项需要进行配置，我们想要实现自动化，就需要一个工具来代替我们做出选择，我们只需要把这个工具配置好，剩下的都交给它。Kickstart就是这样的一个工具，它是<a href="https://en.wikipedia.org/wiki/Red_Hat_Enterprise_Linux" target="_blank" rel="noopener">Red Hat Enterprise Linux</a>操作系统自动执行无人值守的操作系统安装和配置的一种常用方法。  </p><p>Kickstart安装系统时需要有相应的配置文件才能正常工作，这个文件中记录了我们需要安装的操作系统的各种配置、依赖的软件包、安装过程以及安装完成后要执行的脚本等等，它是安装过程的核心文件。我们有很多方式去生成这个配置文件：</p><ol><li>如果你对Kickstart很熟悉，你可以手动编写或者基于系统中已经存在的kickstart文件进行改写。</li><li>你可以使用配套的GUI程序<code>system-config-kickstart</code>傻瓜式生成配置文件。</li><li>你还可以使用系统安装程序<code>Anaconda</code>来生成配置文件。  </li></ol><p>除此之外如果你有兴趣，还可以了解一下<a href="https://en.wikipedia.org/wiki/Cobbler_(software" target="_blank" rel="noopener">Cobbler</a>)这款安装部署软件。</p><p>找一张图来说明一下完整过程(实际情况中OS Server、install/boot Server以及DHCP Server可以在一台机器上)：<br><img src="http://o6sdpimwf.bkt.clouddn.com/uploads/2017/03/PXEAndKickstart.jpg" alt="原理图"></p><h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><p>下面简单的记录一下我的安装步骤，为了方便我采用了GUI工具配置kickstart配置文件，具体步骤如下：</p><h3 id="安装所需要的服务于平台"><a href="#安装所需要的服务于平台" class="headerlink" title="安装所需要的服务于平台"></a>安装所需要的服务于平台</h3><pre><code>[root@localhost file]# yum -y install tftp tftp-server dnsmasq syslinux nfs-* rpc* vim xinetd system-config-kickstart</code></pre><h3 id="配置tftp"><a href="#配置tftp" class="headerlink" title="配置tftp"></a>配置tftp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost file]# vim /etc/xinetd.d/tftp </span><br><span class="line"># default: off</span><br><span class="line"># description: The tftp server serves files using the trivial file transfer \</span><br><span class="line">#       protocol.  The tftp protocol is often used to boot diskless \</span><br><span class="line">#       workstations, download configuration files to network-aware printers, \</span><br><span class="line">#       and to start the installation process for some operating systems.</span><br><span class="line">service tftp</span><br><span class="line">&#123;</span><br><span class="line">        socket_type             = dgram</span><br><span class="line">        protocol                = udp</span><br><span class="line">        wait                    = yes</span><br><span class="line">        user                    = root</span><br><span class="line">        server                  = /usr/sbin/in.tftpd</span><br><span class="line">        server_args             = -s /var/lib/tftpboot #tftp的工作目录</span><br><span class="line">        disable                 = yes                  #将这一行改为no</span><br><span class="line">        per_source              = 11</span><br><span class="line">        cps                     = 100 2</span><br><span class="line">        flags                   = IPv4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置NFS"><a href="#配置NFS" class="headerlink" title="配置NFS"></a>配置NFS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost file]# cat /etc/exports</span><br><span class="line">/base/file   192.168.195.0/24(rw,sync,no_root_squash)  #ks.cfg文件的存放位置</span><br><span class="line">/base/repo   192.168.195.0/24(rw,sync,no_root_squash)  #ISO镜像文件存放位置</span><br></pre></td></tr></table></figure><h3 id="配置dnsmasq（支持dhcp-和pxe文件）"><a href="#配置dnsmasq（支持dhcp-和pxe文件）" class="headerlink" title="配置dnsmasq（支持dhcp/和pxe文件）:"></a>配置dnsmasq（支持dhcp/和pxe文件）:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost file]# egrep -v &quot;^#|^$&quot; /etc/dnsmasq.conf </span><br><span class="line">dhcp-range=192.168.195.50,192.168.195.150,12h  #设置分配的地址池</span><br><span class="line">dhcp-option=3,192.168.195.1  #设置默认网关</span><br><span class="line">dhcp-boot=pxelinux.0  </span><br><span class="line">enable-tftp    #支持tftp</span><br><span class="line">tftp-root=/var/lib/tftpboot  #设置访问目录</span><br><span class="line">dhcp-authoritative    </span><br><span class="line">conf-dir=/etc/dnsmasq.d</span><br></pre></td></tr></table></figure><h3 id="配置default"><a href="#配置default" class="headerlink" title="配置default"></a>配置default</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost file]# mkdir /var/lib/tftpboot/pxelinux.cfg</span><br><span class="line">[root@localhost file]# mount /dev/cdrom /mnt/</span><br><span class="line">[root@localhost file]#cp -rf /mnt/isolinux/isolinux.cfg  /var/lib/tftpboot/pxelinux.cfg/default</span><br><span class="line">[root@localhost file]# cat /var/lib/tftpboot/pxelinux.cfg/default  #文件修改如下</span><br><span class="line">default ks</span><br><span class="line">prompt 1</span><br><span class="line">timeout 6</span><br><span class="line">display boot.msg</span><br><span class="line">F1 boot.msg</span><br><span class="line">F2 options.msg </span><br><span class="line">F3 general.msg </span><br><span class="line">F4 param.msg </span><br><span class="line">F5 rescue.msg </span><br><span class="line">label text </span><br><span class="line">  kernel vmlinuz </span><br><span class="line">  append initrd=initrd.img text </span><br><span class="line">label ks </span><br><span class="line">  kernel vmlinuz </span><br><span class="line">  append ks=nfs:192.168.195.131:/base/file/ks.cfg initrd=initrd.img  #NFS地址和路径</span><br><span class="line">label local </span><br><span class="line">  localboot 1 </span><br><span class="line">label memtest86 </span><br><span class="line">  kernel memtest </span><br><span class="line">  append -</span><br></pre></td></tr></table></figure><h3 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost tftpboot]# cp -rf /mnt/isolinux/&#123;boot.msg,initrd.img,vmlinuz&#125; /var/lib/tftpboot/</span><br><span class="line">[root@localhost tftpboot]# cp -rf /usr/share/syslinux/pxelinux.0  /var/lib/tftpboot/</span><br><span class="line">[root@localhost tftpboot]# cp –rf /mnt/* /base/repo/</span><br></pre></td></tr></table></figure><h3 id="配置kicksatrt"><a href="#配置kicksatrt" class="headerlink" title="配置kicksatrt"></a>配置kicksatrt</h3><p><strong>此步骤采用桌面环境下的Kickstart工具进行辅助配置，实际可根据需求手动修改ks.cfg文件</strong></p><ol><li>设置基本配置：<br>配置时区、键盘、密码等信息，<strong>勾选安装后重启</strong></li><li>设置安装方法：<br><img src="http://o6sdpimwf.bkt.clouddn.com/uploads/2017/03/method.png" alt="设置安装方法"></li><li>设置是否加载引导程序：<br><img src="http://o6sdpimwf.bkt.clouddn.com/uploads/2017/03/bootloader.png" alt="引导程序"></li><li>设置分区信息：<br><img src="http://o6sdpimwf.bkt.clouddn.com/uploads/2017/03/Partition.png" alt="设置分区信息"></li><li><p>设置网络：<br>默认即可</p></li><li><p>设置验证信息：<br>默认即可</p></li><li><p>设置防火墙：<br>关闭防火墙</p></li><li><p>设置安装软件包： 根据需要选择安装包</p></li></ol><blockquote><p>NOTE: 当出现错误“由于下载软件包信息失败，软件包选择被禁止”的错误时，需要将/etc/yum.repos.d/CentOS-Base.repo 中的[base]修改为[development],否则<code>kickstart</code>找不到yum源</p></blockquote><ol><li>编写安装后的脚本：<br>以下脚本用于修改修改主机名和网卡名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">for lines in $(seq 0 `find /etc/sysconfig/network-scripts/ -name &quot;ifcfg-*&quot;| grep -v &quot;ifcfg-lo&quot;| wc -l`);do</span><br><span class="line">for dev_name in `find /etc/sysconfig/network-scripts/ -name &quot;ifcfg-*&quot; | awk -F &apos;-&apos; &apos;&#123;if($NF !~ /eth/)&#123;print &#125;&#125;&apos; | grep -v &quot;ifcfg-lo&quot;`;d</span><br><span class="line">o</span><br><span class="line">    dev[$lines]=$dev_name</span><br><span class="line">    mv $&#123;dev[$lines]&#125;  /etc/sysconfig/network-scripts/ifcfg-eth$lines #修改网卡名</span><br><span class="line">    sed -i &quot;s#NAME=.*#NAME=eth$lines#&quot; /etc/sysconfig/network-scripts/ifcfg-eth$lines</span><br><span class="line">    sed -i &quot;s#DEVICE=.*#DEVICE=eth$lines#&quot; /etc/sysconfig/network-scripts/ifcfg-eth$lines</span><br><span class="line">done</span><br><span class="line">done</span><br><span class="line">sed -i &apos;/GRUB_CMDLINE_LINUX/ s/quiet/quiet net.ifnames=0 biosdevname=0/g&apos; /etc/sysconfig/grub</span><br><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br><span class="line">sed -i &apos;s/quiet/quiet net.ifnames=0 biosdevname=0/g&apos; /boot/grub2/grub.cfg</span><br><span class="line">rm -rf /etc/hostname #修改主机名</span><br><span class="line">echo Node`ip addr show  | grep eno   | awk -F &apos;[/ ]+&apos; &apos;&#123;print $3&#125;&apos; | grep -v [A-Za-z]  | head -1  | awk -F &apos;.&apos; &apos;&#123;print $NF&#125;&apos;` &gt; /etc/ho</span><br><span class="line">stname</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure></li></ol><p><strong>将ks.cfg文件保存在/base/file下</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl  start nfs</span><br><span class="line">systemctl  start xinetd</span><br><span class="line">dnsmasq --addn-host=/var/dnsmasq.hosts --log-facility /tmp/dnsmasq.log --log-queries</span><br></pre></td></tr></table></figure></p><p>至此结束，启动开启一台新的机器进行测试</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o6sdpimwf.bkt.clouddn.com/uploads/2017/03/auto.jpg&quot; alt=&quot;AutoDeploy&quot;&gt;&lt;br&gt;在程序部署的过程中我们经常需要批量部署操作系统，本着“能自动化的绝不手动做”的原则，显然重复部署操作系统这种活儿，我们应该交给脚本去完成。这篇文章就跟大家分享一下如何基于&lt;code&gt;PXE&lt;/code&gt;、&lt;code&gt;Kickstart&lt;/code&gt;以及&lt;code&gt;dnsmasq&lt;/code&gt;实现CentOS7自动部署。
    
    </summary>
    
      <category term="Linux" scheme="http://zxh.site/categories/Linux/"/>
    
      <category term="经验&amp;技巧" scheme="http://zxh.site/categories/Linux/%E7%BB%8F%E9%AA%8C-%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Linux" scheme="http://zxh.site/tags/Linux/"/>
    
      <category term="PXE" scheme="http://zxh.site/tags/PXE/"/>
    
      <category term="Kickstart" scheme="http://zxh.site/tags/Kickstart/"/>
    
  </entry>
  
  <entry>
    <title>Phabricator仓库配置</title>
    <link href="http://zxh.site/2016/12/01/phabricator-2/"/>
    <id>http://zxh.site/2016/12/01/phabricator-2/</id>
    <published>2016-12-01T14:19:17.000Z</published>
    <updated>2018-05-26T04:20:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o6sdpimwf.bkt.clouddn.com/uploads/2016/11/hero.png" alt="CLI"><br><a href="http://blog.zxh.site/2016/11/26/phabricator-configure/#more" target="_blank" rel="noopener">上一篇博客</a>中介绍了如何安装部署<code>Phabricator</code>，本以为安装完成之后就可以愉快的使用了，但是没想到只是完成了一半，打算迁徙几个代码库进来试试，结果又踩了不少坑<a id="more"></a>，在安装部署完成的基础之上还需要配置不少东西才能真正的用起来，<code>Phabricator</code>看起来是很不错，但是作为一个工具，不得不说使用门槛还是偏高（可能是我太菜了[/捂脸]），最后终于用上了，简单总结分享一下吧</p><h2 id="Repository-Hosting"><a href="#Repository-Hosting" class="headerlink" title="Repository Hosting"></a>Repository Hosting</h2><p><code>Phabricator</code>支持Git、SVN以及Mercurial在SSH以及HTTP(Mercurial不支持HTTP)协议下进行代码托管，具体可以参见<a href="https://secure.phabricator.com/book/phabricator/article/diffusion_hosting/" target="_blank" rel="noopener">官方文档</a>，这里只介绍Git+SSH的方式，文档比较长，但是简化翻译后一共要进行如下几步操作：</p><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>Phabricator需要设置三个账户：</p><ol><li><code>daemon-user</code>用于启动phd守护进程，这里我直接用了<code>root</code></li><li><code>www-user</code>作为WEB服务运行的用户，安装部署的时候已经默认了<code>apache</code>无需手动设置</li><li><code>vcs-user</code>Git操作相关的用户，这里我用了<code>git</code>  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 添加git用户</span><br><span class="line">useradd git</span><br><span class="line"></span><br><span class="line"># 修改shadow文件，将git用户的第二项该为NP，类似：git:NP:0:99999:7:::</span><br><span class="line">vim /etc/shadow</span><br><span class="line"># 修改passwd文件，将git用户的最后一项改为/usr/bin/bash</span><br><span class="line">vim /etc/passwd</span><br><span class="line"></span><br><span class="line">visudo</span><br><span class="line"># 在97行附近，加入如下内容：</span><br><span class="line">git  ALL=(ALL) SETENV: NOPASSWD: /bin/ls, /usr/bin/git, </span><br><span class="line">/usr/bin/git-upload-pack, /usr/bin/git-receive-pack, /usr/bin/ssh</span><br><span class="line"></span><br><span class="line"># 注释掉Defaults    requiretty</span><br></pre></td></tr></table></figure><p>修改配置，启动服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[phabricator]#  ./bin/config set phd.user root</span><br><span class="line">[phabricator]#  ./bin/phd start</span><br><span class="line">[phabricator]#  ./bin/config set diffusion.ssh-user git</span><br></pre></td></tr></table></figure></p><blockquote><p>注：<br>1.The second field (which is the password field) must not be set to !!. This value will prevent login. If it is set to !!, edit it and set it to NP (“no password”) instead<br>2.务必注释掉sudoer中的Defaults    requiretty  </p></blockquote><h3 id="配置SSHD"><a href="#配置SSHD" class="headerlink" title="配置SSHD"></a>配置SSHD</h3><p>为Phabricator单独配置一个sshd到2222端口上，当然你可以放到任意一个端口，如果你觉得很不爽，也可以阅读<a href="https://secure.phabricator.com/book/phabricator/article/diffusion_hosting/" target="_blank" rel="noopener">官方文档</a>进行一些特殊的设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 设置端口号为2222</span><br><span class="line">./bin/config set diffusion.ssh-port 2222</span><br><span class="line"></span><br><span class="line"># 编辑脚本</span><br><span class="line">cd ~your/phabricator/path</span><br><span class="line">cp ./resources/sshd/phabricator-ssh-hook.sh /usr/libexec/phabricator-ssh-hook.sh</span><br><span class="line">chmod 0755 /usr/libexec/phabricator-ssh-hook.sh</span><br><span class="line">vim /usr/libexec/phabricator-ssh-hook.sh</span><br></pre></td></tr></table></figure></p><p>看起来大概这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line"># NOTE: Replace this with the username that you expect users to connect with.</span><br><span class="line">VCSUSER=&quot;git&quot;</span><br><span class="line"></span><br><span class="line"># NOTE: Replace this with the path to your Phabricator directory.</span><br><span class="line">ROOT=&quot;/var/www/html/phabricator&quot;</span><br><span class="line"></span><br><span class="line">if [ &quot;$1&quot; != &quot;$VCSUSER&quot; ];</span><br><span class="line">then</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">exec &quot;$ROOT/bin/ssh-auth&quot; $@</span><br></pre></td></tr></table></figure></p><p>创建编辑sshd配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config.phabricator</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># NOTE: You must have OpenSSHD 6.2 or newer; support for AuthorizedKeysCommand</span><br><span class="line"># was added in this version.</span><br><span class="line"></span><br><span class="line"># NOTE: Edit these to the correct values for your setup.</span><br><span class="line"></span><br><span class="line">AuthorizedKeysCommand /usr/libexec/phabricator-ssh-hook.sh</span><br><span class="line">AuthorizedKeysCommandUser git </span><br><span class="line">AllowUsers git </span><br><span class="line"></span><br><span class="line"># You may need to tweak these options, but mostly they just turn off everything</span><br><span class="line"># dangerous.</span><br><span class="line"></span><br><span class="line">Port 2222</span><br><span class="line">Protocol 2</span><br><span class="line">PermitRootLogin no</span><br><span class="line">AllowAgentForwarding no</span><br><span class="line">AllowTcpForwarding no</span><br><span class="line">PrintMotd no</span><br><span class="line">PrintLastLog no</span><br><span class="line">PasswordAuthentication yes </span><br><span class="line">AuthorizedKeysFile none</span><br><span class="line"></span><br><span class="line">PidFile /var/run/sshd-phabricator.pid</span><br></pre></td></tr></table></figure><p>执行<code>/usr/sbin/sshd -f /etc/ssh/sshd_config.phabricator</code>启动<code>sshd</code>  </p><blockquote><p>注：<br>Both the script(phabricator-ssh-hook.sh) itself and the parent directory the script resides in must be owned by root, and the script must have 755 permissions</p></blockquote><h2 id="Import-repository"><a href="#Import-repository" class="headerlink" title="Import repository"></a>Import repository</h2><p>完成上面的步骤之后，就可以自己新建仓库了，创建仓库很简单就不啰嗦了，这里讲一下如何导入一个现有的代码库到<code>Phabricator</code>中，步骤如下：</p><h3 id="添加Credentials"><a href="#添加Credentials" class="headerlink" title="添加Credentials"></a>添加Credentials</h3><p>进入<code>Application</code>-&gt;<code>Passphrase</code>-&gt;<code>Create Credential</code>,添加一个<code>SSH Private Key</code>将本机的SSH密钥对加入系统，同时将<code>Public Key</code>放到需要克隆的远程仓库中例如<code>GitHub</code>或者原来<code>Gerrit</code>所在的机器</p><h3 id="导入代码"><a href="#导入代码" class="headerlink" title="导入代码"></a>导入代码</h3><ol><li>进入<code>Diffusion</code>-&gt;<code>Create Repository</code>-&gt;<code>Create Git Repository</code>创建一个仓库</li><li>找到新建的仓库，点击<code>Manage Repository</code>-&gt;<code>URIs</code>-&gt;<code>Add New URI</code>，将远程仓库地址填写到<code>URI</code>中，设置<code>I/O Type</code>为<code>Observe</code>模式</li><li><code>Set Credentials</code>选中刚才添加的<code>Credentials</code></li><li>回到<code>Basics</code>中<code>Activate Repository</code>，此时可以在状态中看到正在导入，等待导入完成</li><li>在导入完成之后，编辑刚才<code>Observe</code>模式的那个URI，设置<code>I/O Type</code>为<code>No I/O</code>  </li></ol><blockquote><p>注：<br>官方文档中写的是Disable掉Observe的那个URI，实际上应该是设置<code>I/O Type</code>为<code>No I/O</code></p></blockquote><h2 id="Clone-amp-Commit"><a href="#Clone-amp-Commit" class="headerlink" title="Clone &amp; Commit"></a>Clone &amp; Commit</h2><p>进入<code>Settings</code>-&gt;<code>Personal Settings</code>-&gt;<code>Edit</code>-&gt;<code>SSH Public Keys</code>把平时开发用的机器的Public Key放进去，到这里，就可以用<code>git clone</code>指定的代码库了。不过还没完，你还得安装学习一下如何用<code>Arcanist</code>提交代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 下载到任何目录</span><br><span class="line">mdkir cd /usr/local/phabricator</span><br><span class="line">cd /usr/local/phabricator</span><br><span class="line">git clone https://github.com/phacility/libphutil.git</span><br><span class="line">git clone https://github.com/phacility/arcanist.git</span><br></pre></td></tr></table></figure></p><p>第一次使用的时候，会提示输入一个Token，直接根据提示从你的Phabricator URL中就能获取到，另外别忘了设置一下环境变量，vim /etc/profile.d/pha.sh<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/phabricator/arcanist/bin</span><br></pre></td></tr></table></figure></p><p>顺便可以设置一下开机启动啥的这里就不写了，<code>Arcanist</code>我简单的使用了一下，大概有这些好处：</p><ul><li>让你的提交信息变得更规范</li><li>提交时就能设置好review相关的参数</li><li>直接用命令行就可以查看多个提交review的进度（这个很爽）</li><li>命令行直接合并代码</li></ul><p>简而言之就是更加快捷高效，命令并不难掌握，可以参考一下<a href="https://www.5288z.com/?p=1478" target="_blank" rel="noopener">这个链接</a>学习一下，如果用过git上手这个应该很快。  </p><p>最后，如果你只是自己玩玩或者在一个个人项目中使用<code>Phabricator</code>,别忘了设置<code>differential.allow-self-accept</code>为<code>true</code> ，下一篇我打算试试集成一个合适的CI系统进来，敬请期待~</p><hr><p>EOF</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o6sdpimwf.bkt.clouddn.com/uploads/2016/11/hero.png&quot; alt=&quot;CLI&quot;&gt;&lt;br&gt;&lt;a href=&quot;http://blog.zxh.site/2016/11/26/phabricator-configure/#more&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上一篇博客&lt;/a&gt;中介绍了如何安装部署&lt;code&gt;Phabricator&lt;/code&gt;，本以为安装完成之后就可以愉快的使用了，但是没想到只是完成了一半，打算迁徙几个代码库进来试试，结果又踩了不少坑
    
    </summary>
    
      <category term="工具" scheme="http://zxh.site/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://zxh.site/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Phabricator" scheme="http://zxh.site/tags/Phabricator/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 7 Phabricator安装配置</title>
    <link href="http://zxh.site/2016/11/26/phabricator-configure/"/>
    <id>http://zxh.site/2016/11/26/phabricator-configure/</id>
    <published>2016-11-26T14:16:24.000Z</published>
    <updated>2018-05-26T04:20:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o6sdpimwf.bkt.clouddn.com/uploads/2016/11/hero.png" alt="CLI"></p><p>Phabricator是一套完整的软件开发工具集，包含了任务管理、代码审查、类MarkDown的文档编辑、开发沟通等等，相较于Gerrit这样的代码审核软件，它显得更加现代化，并且集成的其他工具也能很好的和代码审核配合提高生产效率。<a id="more"></a><br>我在CentOS 7下部署这套工具的时候遇到不少问题，不断摸索花了几个小时终于全部搞定了，整理了一下跟大家分享经验。</p><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 切换到任意目录下，这里以/opt/software为例</span><br><span class="line"></span><br><span class="line">cd /opt/software</span><br><span class="line">wget https://raw.githubusercontent.com/phacility/phabricator/master/scripts/install/install_rhel-derivs.sh</span><br><span class="line">chmod +x install_rhel-derivs.sh</span><br><span class="line">./install_rhel-derivs.sh</span><br><span class="line"></span><br><span class="line"># 因为众所周知的原因，代码clone速度较慢，并且核心代码库比较大，加上clone时不支持断点续传</span><br><span class="line"># 建议在科学上网的环境下进行以上操作，如果不具备科学上网的条件，可以考虑去github上下载zip包</span><br></pre></td></tr></table></figure><p><strong>注</strong>：</p><ul><li><strong>如果将克隆后的仓库拷贝到远程主机上安装，用scp复制到远程主机后部分文件会出问题，应该执行<code>git reset --hard HEAD</code>恢复文件到最新版本，否则PHP脚本会报错</strong></li></ul><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>在完整执行过<code>install_rhel-derivs.sh</code>脚本后，系统应该已经有完整的<code>LAMP</code>环境了，执行如下操作进行Web服务器配置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 将clone下来的代码放置到/var/www/html文件夹下</span><br><span class="line">mv /opt/software/* /var/www/html</span><br><span class="line"></span><br><span class="line"># 配置httpd服务</span><br><span class="line">vim /etc/httpd/conf/httpd.conf </span><br><span class="line"></span><br><span class="line"># 在119行附近修改（加入）以下内容</span><br><span class="line">DocumentRoot &quot;/var/www/html/phabricator/webroot&quot;</span><br><span class="line">DirectoryIndex index.php index.html index.html.var</span><br><span class="line"></span><br><span class="line">&lt;VirtualHost *&gt;</span><br><span class="line">  RewriteEngine on</span><br><span class="line">  RewriteRule ^/rsrc/(.*)     -                       [L,QSA]</span><br><span class="line">  RewriteRule ^/favicon.ico   -                       [L,QSA]</span><br><span class="line">  RewriteRule ^(.*)$          /index.php?__path__=$1  [B,L,QSA]</span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line"></span><br><span class="line"># 重启并设置开机启动httpd服务</span><br><span class="line">systemctl restart httpd</span><br><span class="line">systemctl enable httpd</span><br><span class="line"></span><br><span class="line"># 配置Phabricator域名</span><br><span class="line">./phabricator/bin/config set phabricator.base-uri &apos;http://example.com/&apos;</span><br><span class="line"></span><br><span class="line"># 初始化数据库</span><br><span class="line">./phabricator/bin/storage upgrade</span><br></pre></td></tr></table></figure></p><p><strong>注</strong>：</p><ul><li>必须设置一个完整域名，否则会报错或者影响部分功能使用，没有公网域名可以修改客户机hosts文件配置主机域名 </li><li>必须执行数据库初始化操作否则会报错</li></ul><h2 id="Phabricator配置"><a href="#Phabricator配置" class="headerlink" title="Phabricator配置"></a>Phabricator配置</h2><p>完成上述步骤后，输入配置的域名应该就能看到Phabricator的管理员注册界面了，完成注册后进入主界面会看到还有十多个issues提醒，根据提示逐项修改<code>/etc/php.ini</code>和<code>/etc/my.cnf.d/server.cnf</code>,然后重启mariadb和httpd服务，这里提供一下我自己的配置文件供大家参考，环境相同且没有其他软件导致配置冲突的话可以考虑直接替换文件重启服务。</p><ul><li><a href="http://o6sdpimwf.bkt.clouddn.com/uploads/2016/11/php.ini" target="_blank" rel="noopener">php.ini</a></li><li><a href="http://o6sdpimwf.bkt.clouddn.com/uploads/2016/11/server.cnf" target="_blank" rel="noopener">server.cnf</a>  </li></ul><p><strong>注</strong>：</p><ul><li>issues列表中提到的启用<code>pygments</code>以开启代码高亮，使用<code>yum install python-pygments</code>即可安装</li><li><code>Large File Storage</code>建议保留mysql的同时设置一个localpath，系统默认会将小于1M的文件存数据库</li><li><code>Alternate File Domain Not Configured</code>没有CDN的可以忽略</li><li><code>PHP Extension &#39;APC&#39; Not Installed</code>可以忽略，这个我已经配置了但是提示没有，希望知道怎么配置的同学帮忙补充  </li></ul><p>大功告成！尽情探索一下吧~</p><hr><p>EOF</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o6sdpimwf.bkt.clouddn.com/uploads/2016/11/hero.png&quot; alt=&quot;CLI&quot;&gt;&lt;/p&gt;
&lt;p&gt;Phabricator是一套完整的软件开发工具集，包含了任务管理、代码审查、类MarkDown的文档编辑、开发沟通等等，相较于Gerrit这样的代码审核软件，它显得更加现代化，并且集成的其他工具也能很好的和代码审核配合提高生产效率。
    
    </summary>
    
      <category term="工具" scheme="http://zxh.site/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://zxh.site/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Phabricator" scheme="http://zxh.site/tags/Phabricator/"/>
    
  </entry>
  
  <entry>
    <title>如何变得更高效</title>
    <link href="http://zxh.site/2016/10/21/efficient/"/>
    <id>http://zxh.site/2016/10/21/efficient/</id>
    <published>2016-10-21T14:33:07.000Z</published>
    <updated>2018-05-26T03:51:19.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o6sdpimwf.bkt.clouddn.com/uploads/2016/10/efficiency.jpg" alt="efficiency">  </p><p>最近发现如何使自己的效率最大化是很值得研究的问题，尤其是在开发的时候如何提高专注度提高效率？每天的时间都是有限的，如何发挥时间的最大价值？所以最近收集了一些小技巧和工具来提高效率。<a id="more"></a>平时我都是在Windows10+Linux(CentOS 7为主)虚拟机的环境下进行开发的，分享一些经验和技巧吧  </p><hr><h3 id="提高效率的软件"><a href="#提高效率的软件" class="headerlink" title="提高效率的软件"></a>提高效率的软件</h3><h4 id="Wox"><a href="#Wox" class="headerlink" title="Wox"></a>Wox</h4><p><a href="https://github.com/Wox-launcher/Wox" target="_blank" rel="noopener">Wox</a>是一款快速启动程序的小工具，它的特点是足够轻便小巧，并且还挺美观。安装软件之后直接Alt+space就可以在任意界面呼出这个小工具，直接输入你想打开的程序回车就好了，再也不用鼠标点击开始菜单去搜寻了。类似的工具还有<code>Launchy</code>,但是Wox更强大的地方在于可以拓展各种插件，例如执行<code>wpm install 有道词典</code>，软件就集成了翻译功能，输入<code>yd 要查询的单词</code>就能迅速得到结果，还有更多的插件让你事半功倍。</p><h4 id="Everything"><a href="#Everything" class="headerlink" title="Everything"></a>Everything</h4><p><a href="https://www.voidtools.com/" target="_blank" rel="noopener">Everything</a>是一款快速检索文件的工具，建立索引之后搜索速度极快，Wox默认就是用它作为本地文件检索引擎，配合Wox工作起来效率倍增。</p><h4 id="OneNote"><a href="#OneNote" class="headerlink" title="OneNote"></a>OneNote</h4><p>如果要问我最喜欢Windows10的哪个特性的话，我一定毫不犹豫的回答：原生支持OneNote！在Window10中将右侧菜单激活之后会看到一些快捷方式，其中有一个“便签”，这就是UWP版的OneNote，启动迅速、云端同步、完全免费、跨各种平台，非常好用！从此再也不用“印象笔记”、“有道云笔记”之类的软件了。</p><h4 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h4><p><a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">oh-my-zsh</a>是zsh的扩展，zsh是比bash易用性更好的shell，MacOS就使用zsh作为默认shell，说明zsh确实有它的过人之处，而oh-my-zsh更是极大的提高了zsh的效率。插件丰富、自动补齐变得更强大、主题美观并且完全兼容bash、git特殊加持……GitHub上Star 4w+，总之就是特别赞</p><h4 id="Xshell-Xftp"><a href="#Xshell-Xftp" class="headerlink" title="Xshell + Xftp"></a>Xshell + Xftp</h4><p>虽然Windows上的终端软件不少，比如短小精悍的Putty、大名鼎鼎的SecureCRT等，我觉得Putty很棒，适合放到U盘中随身携带即开即用，但是很遗憾的是它对于彩色的支持度不是很好，oh-my-zsh的主题在Putty下显示不正常，SecureCRT又是收费软件，99刀的价格并不算便宜，而XShell却提供了<code>Free for Home/School</code>的许可，加上它强大的功能以及Xftp的整合，可谓是全能型的终端软件了。</p><hr><h3 id="关于Windows"><a href="#关于Windows" class="headerlink" title="关于Windows"></a>关于Windows</h3><p>一帮买了MacBook的程序员鼓吹Mac各种好、效率高、码农必备；一帮Linux高手鼓吹Linux各种帅气的命令行操作、各种奇技淫巧狂拽炫酷吊炸天……很少见到有人夸Windows好，其实主要原因就是：</p><blockquote><p><strong>你的硬件配置不够好</strong>  </p></blockquote><p>相信我，一块SSD能让你对Windows有新的认识，哪怕只是128G的金士顿也能让你飞起来。另外内存一定要大一些，反正已经白菜价了建议8GB或者更大。在这个基础上再去对比各个系统的优劣吧，不然怎么公平呢。</p><blockquote><p>Windows上安装软件需要去网上各种搜索下载安装配置  </p></blockquote><p>Windows上其实也有类似apt-get/yum之类的包管理软件————<a href="https://chocolatey.org/" target="_blank" rel="noopener">Chocolatey</a>，有兴趣的话可以研究一下。另外Windows10周年更新之后，悄悄在系统中加入了一个Sub-System，实际上是整合了一个ubuntu的系统，感兴趣的同学可以google搜索一下具体开启这个子系统的方法，不过这还是一个Beta功能，所以并不能完全达到Linux系统的效果，但是多数Linux命令和软件已经完美支持了。  </p><p>不过我个人觉得更好的方式是弄个虚拟机，运行一个<strong>非桌面版</strong>的Linux系统，新手建议CentOS或者Ubuntu，CentOS在社区使用范围较广，遇到问题能很便捷地获取到解决方法。学会Linux之后效率会得到极大的提升，从此开发相关的所有工具、环境、代码放到Linux中，其他日常应用程序在Windows上。</p><blockquote><p>Windows没有高效通用的Shell  </p></blockquote><p>开启“适用于Linux的Windows子系统”吧，直接运行bash就可以了，就是Linux中一模一样的bash。或者彻底一点，装虚拟机吧！</p><hr><h3 id="生活习惯"><a href="#生活习惯" class="headerlink" title="生活习惯"></a><strong>生活习惯</strong></h3><h4 id="在地铁上看书"><a href="#在地铁上看书" class="headerlink" title="在地铁上看书"></a>在地铁上看书</h4><p>据说北上广的上班族平均通勤时间接近1个小时，来回就是2个小时，大多数人会选择在地铁上玩手机度过。如果把这些时间利用起来读一点儿书，按每天一个小时计算，平均一个周就能看完一本书，就算看得慢一些一个月总是能看完一本书的，一年就是12本，虽然这个数量据说还不到发达国家的最低平均阅读量，但是总算是有收获的。别说了，赶紧买个Kindle吧。</p><h4 id="记录每天做了什么"><a href="#记录每天做了什么" class="headerlink" title="记录每天做了什么"></a>记录每天做了什么</h4><blockquote><p>Make a Done List to Drive Your Productivity</p></blockquote><p>小时候在每学期开学的时候都会给自己制定一个“开学计划”，事实证明完全是三分钟热度持续不了几天一切就全都抛掷脑后了。后来长大了也没改掉这个毛病，总是在制定计划、重新制定计划。其实计划赶不上变化，每天都会发生各种事情可能干扰你的计划，任何计划都不可能详尽的排除各种意外情况的发生，与其使用<code>Todo List</code>不如从现在开始每天记录<code>Done List</code>。  </p><p>只记录今天做了什么，花了多少时间，慢慢地会发现这种习惯的神奇之处。如果知道自己每天都在做什么，自然能根据自己的<code>Done List</code>去自然制定<code>Todo List</code>，一段时间后会发现自己的效率因为这么一个简单的小习惯得到了极大的提高。  </p><p>就到这里吧，希望看到这篇文章的人会觉得有用~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o6sdpimwf.bkt.clouddn.com/uploads/2016/10/efficiency.jpg&quot; alt=&quot;efficiency&quot;&gt;  &lt;/p&gt;
&lt;p&gt;最近发现如何使自己的效率最大化是很值得研究的问题，尤其是在开发的时候如何提高专注度提高效率？每天的时间都是有限的，如何发挥时间的最大价值？所以最近收集了一些小技巧和工具来提高效率。
    
    </summary>
    
      <category term="生活" scheme="http://zxh.site/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="http://zxh.site/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="经验&amp;技巧" scheme="http://zxh.site/tags/%E7%BB%8F%E9%AA%8C-%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>入职一年工作总结</title>
    <link href="http://zxh.site/2016/07/01/first-anniversary/"/>
    <id>http://zxh.site/2016/07/01/first-anniversary/</id>
    <published>2016-07-01T14:33:07.000Z</published>
    <updated>2018-05-26T04:00:11.000Z</updated>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="http://o6sdpimwf.bkt.clouddn.com/uploads/2016/07/look.jpg" class="full-image" alt="回顾"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>去年毕业，因为各种原因决定来北京工作，于是被学校赶走之后就来了北京。一晃竟然就是一年。回顾过去这一年，感觉竟然是活了23年以来最为充实的一年，充实意味着大部分日子没有虚度，这是这一年最为满意的地方。我始终相信无论是财富还是知识的积累都是复利的，善于理财的人手头的财富会越来越多增长越来越快，知识也一样。<br><a id="more"></a>公司有一个较为特别的规定，每天下班之前花几分钟发送一封不一定会有人看的邮件，内容是今天都做了什么，明天打算做什么。这样做的好处很多，不仅可以让一起工作的同事知道你的工作进度，更能让自己的思路和工作计划变得清晰，回顾过去一周、一月、一年的report邮件，也能总结出这一段时间都完成了什么工作。如果可以的话，决定以后每一年都为过去一年做记录和计划。  </p><h3 id="过去一年学习到的新东西"><a href="#过去一年学习到的新东西" class="headerlink" title="过去一年学习到的新东西"></a>过去一年学习到的新东西</h3><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="http://o6sdpimwf.bkt.clouddn.com/uploads/2016/07/team.png" class="full-image" alt="Team"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><ul><li><strong>对团队重要性的认识</strong><br>上大学的时候我开发过两个小项目，一个是基于微信公众平台的小区物业管理，一个是学校的在线打印店。每当看到现在市面上类似的产品，我都会想到这两个奇葩的小东西。首先值得肯定的是当初弄这些玩意儿的想法还是挺先进的，虽然谈不上开创者，但是那时候确实市面上的竞品不多，可惜我们是在天津弄了个地方几个人凑在一起瞎搞，我是唯一的开发，然后还有一个集产品和美工于一体的大黄加上一些酱油的小学弟。我并不是什么天才程序员，再加上这样简陋的配置自然不可能成什么大事。这段经历最大的回报就是瞎折腾的过程中提高了自己学习的能力。<br>去年我也见证了一个小团队的解散，这是几个朋友一起搞的小团队，他们想做视频交互，合伙人中有视频行业从业多年的精英、就职与微软多年的资深开发。由于这个东西确实很好玩，我也在闲暇之余投入了一些精力协助他们做一些开发。但是显然这个新的方向也并不是这么一个几个人的小团队能做起来的。我认为失败最大的原因是团队人员配置问题，最主要的是技术开发能力不足、人手不足、缺乏配合。最资深的技术常年工作的内容是C++相关的，并且在微软呆了太久缺乏对新技术的热情，而另一个开发水平有限，我这种友情场外援助显然不能挽救场面，最后项目自然无疾而终。<br>我坚信我迟早会开发出一个还不错的自己的产品，但是现在我明白了一个人很难做成一件大事，无论你能力有多强，想要做好一款互联网时代的优秀产品，孤军奋战是几乎不可能完成的。众多的互联网从业者中，有很多看起来并没有任何卵用的角色，但是真正想做一个东西出来任何事情都亲力亲为的时候就会发现效率是极低的。人类社会之所以像现在这样分工明确显然是有道理的，各司其职又能互相配合的团队才是成就一个伟大产品最重要的因素。<strong>而我目前需要做的是在找到这样的团队之前，不断提升自己的能力</strong>。 </li></ul><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="http://o6sdpimwf.bkt.clouddn.com/uploads/2016/07/code.png" class="full-image" alt="Code"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><ul><li><p><strong>对编程的重新认识</strong><br>又要提到大学时候做的那两个奇葩的项目了。那时候可以算是什么都不会，要用到什么就现学现用，好在我学习能力还不错于是就把各种东西<code>ThinkPHP</code>、<code>Bootstrap</code>、<code>jQuery</code>还有一堆乱七八糟的插件拼凑到一起，随便写了一堆代码部署到<code>SAE</code>上，奇葩的是他们竟然能正常运行上线服务。那时候并不在意代码规范，不懂得如何规划项目，只知道我要做什么，只要实现了就好。于是入职后的第一个周我的内心的崩溃的，完全看不懂项目里的那些上万行的<code>Javascript</code>代码，也有太多的概念不懂，满脑子里面塞的都是新东西：<code>单页应用</code>、<code>Restful接口</code>、<code>代码规范</code>、<code>前端构建</code>、<code>插件封装</code>、<code>前后端分离</code>、<code>代码调试</code>、<code>性能调优</code>……一下子感觉自己什么都不懂，连代码都看不懂，下个月应该就可以被开除了吧……<strong>最深刻的认识就是以前写的代码真是玩具代码，我根本不会编程</strong>。后来又开始学习<code>Golang</code>，看了很多别人的代码在大牛们的悉心指导下才逐渐对<code>设计模式</code>、<code>接口设计</code>、<code>远程调用</code>……这些东西有所了解。而越是深入学习，越是发现自己什么都不会，而计算机行业技术永远保持着快速的迭代更新，穷尽一生也不可能将所有的东西都掌握。<strong>优秀的开发者应该永远保持对技术和学习的热情</strong>。</p></li><li><p><strong>技术上的提升</strong><br><code>Javascript</code>和<code>Golang</code>的编码水平得到了很大的提升，确切说是以前根本不会，现在算是入门了。熟悉了<code>Linux</code>系统，现在也能完成基本的系统部署，<code>Shell</code>、<code>Docker</code>、<code>Torque</code>、<code>Slurm</code>、<code>Redis</code>……也都能玩得来，还能随手撸出来一段解放双手的脚本。对项目的基础构建有了一定的认识。最最最重要的是学习的能力得到了提高，不会的东西看看文档就能开始尝试，在知识的复利条件下这意味着未来如果我能保持去年的精力投入一定会得到更多的回报。  </p></li></ul><h3 id="过去一年看过的书"><a href="#过去一年看过的书" class="headerlink" title="过去一年看过的书"></a>过去一年看过的书</h3><ul><li>已看  <ul><li>《JavaScript语言精粹》</li><li>《JavaScript权威指南》</li><li>《Go语言程序设计》</li><li>《Go语言编程》</li><li>《黑客与画家》</li><li>《如何变得有思想》</li><li>《解忧杂货铺》</li><li>《异类》</li><li>《冰与火之歌第二卷》</li><li>《从0到1》</li><li>《创业小败局》</li><li>《浪潮之巅》</li><li>《穷爸爸富爸爸》</li><li>《Web全栈工程师的自我修养》</li><li>《极简欧洲史》</li></ul></li><li>在看  <ul><li>《代码整洁之道》</li><li>《JavaScript设计模式》</li><li>《新生》  </li></ul></li><li>年度好评书籍<br>  <img src="http://o6sdpimwf.bkt.clouddn.com/uploads/2016/07/hacker.jpg" alt="黑客与画家">    </li></ul><h3 id="未来一年的计划"><a href="#未来一年的计划" class="headerlink" title="未来一年的计划"></a>未来一年的计划</h3><ul><li>继续提高JavaScript和Golang的编程能力</li><li>尝试完成一个完全属于自己的项目</li><li>阅读数量不少于去年的书</li></ul><hr><p>愿明年总结的时候，能同样觉得充实。  </p>]]></content>
    
    <summary type="html">
    
      &lt;span itemprop=&quot;image&quot; itemscope=&quot;&quot; itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;http://o6sdpimwf.bkt.clouddn.com/uploads/2016/07/look.jpg&quot; class=&quot;full-image&quot; alt=&quot;回顾&quot;&gt;&lt;meta itemprop=&quot;width&quot; content=&quot;auto&quot;&gt;&lt;meta itemprop=&quot;height&quot; content=&quot;auto&quot;&gt;&lt;/span&gt;
&lt;p&gt;去年毕业，因为各种原因决定来北京工作，于是被学校赶走之后就来了北京。一晃竟然就是一年。回顾过去这一年，感觉竟然是活了23年以来最为充实的一年，充实意味着大部分日子没有虚度，这是这一年最为满意的地方。我始终相信无论是财富还是知识的积累都是复利的，善于理财的人手头的财富会越来越多增长越来越快，知识也一样。&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://zxh.site/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="http://zxh.site/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>巧用Redis模拟RPC</title>
    <link href="http://zxh.site/2016/06/12/redis-rpc/"/>
    <id>http://zxh.site/2016/06/12/redis-rpc/</id>
    <published>2016-06-12T13:29:09.000Z</published>
    <updated>2018-05-26T03:57:27.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o6sdpimwf.bkt.clouddn.com/uploads/2016/06/rpc.jpg" alt="redis"></p><p>Redis是一个非常灵活的工具，利用Redis我们可以很方便的完成一些数据的缓存和交换。这种数据交换不依赖语言，在各种语言下都有很简单方便的实现，并且redis-cli可以直接命令行操作，在脚本中也能很方便的实现数据交换。正是因为它具备这样的特性，就算是shell脚本，也可以很容易模拟实现RPC。<br><a id="more"></a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>实现RPC如果不考虑底层如何实现，不考虑信息如何在网络中传输，那么主要操作就是在客户端发起请求，服务端进行响应并且通知客户端完成了该操作返回数据。也就是说只要客户端和服务端都可以与Redis数据库建立连接，两端就可以通过它实现相互通讯。Redis支持订阅消息事件，支持事件广播，还有<code>BRPOP</code>这样的阻塞式数据弹出方式。所以我们只要在Server中订阅与Client约定好的<code>Channel</code>，就可以实现通知，再把完成操作之后希望返回的数据<code>PUSH</code>到队列中，在Client中利用<code>BRPOP</code>就可以实现超时或者取出Server返回的消息。  </p><blockquote><p><strong>BRPOP</strong> key [key …] timeout<br>BRPOP 是列表的阻塞式(blocking)弹出原语。<br>它是 RPOP 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 BRPOP 命令阻塞，直到等待超时或发现可弹出元素为止。</p></blockquote><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>以Golang为例，利用了<code>redigo</code>,伪代码如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mockRPC</span><span class="params">(channel, command <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> data <span class="keyword">string</span></span><br><span class="line">redisConn.Do(<span class="string">"PUBLISH"</span>, channel, command)</span><br><span class="line">reply, err := redis.Values(redisConn.Do(<span class="string">"BRPOP"</span>, <span class="string">"foo"</span>, <span class="number">5</span>))</span><br><span class="line"><span class="comment">// BRPOP会在5秒内取出数据，否则返回错误提示</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> strings.LastIndexAny(err.Error(), <span class="string">"nil returned"</span>) != <span class="number">-1</span> &#123;</span><br><span class="line"><span class="comment">//判断err返回的消息内容，redigo中BRPOP无内容返回会返回"redigo: nil returned"</span></span><br><span class="line"><span class="comment">//可以模拟为timeout</span></span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"timeout"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有错误返回则说明有数据返回，将数据解析传回需要的地方</span></span><br><span class="line">redis.Scan(reply, &amp;data, &amp;data)</span><br><span class="line"><span class="comment">// parse data, return if necessary</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Server端进行相反的操作，即获取订阅事件触发指定的function，然后将数据PUSH到约定的List中即可，大概是这样子：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">psc := redis.PubSubConn&#123;c&#125;</span><br><span class="line">psc.Subscribe(<span class="string">"foo"</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> v := psc.Receive().(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> redis.Message:</span><br><span class="line">fmt.Printf(<span class="string">"%s: message: %s\n"</span>, v.Channel, v.Data)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">string</span>(v.Data) == <span class="string">"command"</span> &#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">redisConn.Do(<span class="string">"LPUSH"</span>, <span class="string">"someList"</span>, <span class="string">"some data"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> redis.Subscription:</span><br><span class="line">fmt.Printf(<span class="string">"%s: %s %d\n"</span>, v.Channel, v.Kind, v.Count)</span><br><span class="line"><span class="keyword">case</span> error:</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></p><hr><p>就这样就实现了~也算一种奇技淫巧吧哈哈</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o6sdpimwf.bkt.clouddn.com/uploads/2016/06/rpc.jpg&quot; alt=&quot;redis&quot;&gt;&lt;/p&gt;
&lt;p&gt;Redis是一个非常灵活的工具，利用Redis我们可以很方便的完成一些数据的缓存和交换。这种数据交换不依赖语言，在各种语言下都有很简单方便的实现，并且redis-cli可以直接命令行操作，在脚本中也能很方便的实现数据交换。正是因为它具备这样的特性，就算是shell脚本，也可以很容易模拟实现RPC。&lt;br&gt;
    
    </summary>
    
      <category term="后端" scheme="http://zxh.site/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="工具" scheme="http://zxh.site/categories/%E5%90%8E%E7%AB%AF/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="后端" scheme="http://zxh.site/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Redis" scheme="http://zxh.site/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Windows平台OmniMarkupPreviewer配置引发的思考</title>
    <link href="http://zxh.site/2016/06/03/markdown-plugin-for-sublime-text/"/>
    <id>http://zxh.site/2016/06/03/markdown-plugin-for-sublime-text/</id>
    <published>2016-06-03T15:08:45.000Z</published>
    <updated>2018-05-26T04:19:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o6sdpimwf.bkt.clouddn.com/uploads/2016/06/dontcopy.jpg" alt="git"></p><h3 id="假装思考"><a href="#假装思考" class="headerlink" title="假装思考"></a>假装思考</h3><p>这篇博客其实并不是教程，只是记录一下今天遇到的我觉得值得吐槽的一件事情。事情是这样的，今天下午我打算回来写个博客，因为博客是用Hexo搭建的，所以写的时候自然想使用markdown来写。平时我都用Atom来写因为它提供了实时预览的功能，但是最近Atom是越用越卡，而在线编辑的又感觉太麻烦，我感觉还是Sublime用起来爽于是就试着找了一个<code>markdown</code>的插件，也就是<code>OmniMarkupPreviewer</code>。配置好之后体验了一把（这篇博客就是用这个插件写的）。<a id="more"></a><code>OmniMarkupPreviewer</code>确实是一个不错的插件，不过…好像现在程序员们都很有钱嘛，不管是百度还是谷歌搜出来的教程都是Mac的配置，我试着配置了一下，发现别的功能都是正常的，但是无法直接在Sublime中按<code>Ctrl+Alt+O</code>打开浏览器实时预览，而这正是我需要的最核心的功能啊。于是我又尝试用我蹩脚的英文开始搜索，仅有的几个提问竟然都没有人回答。我不禁开始深思难道真的是我太low了吗作为一个程序员我竟然不用Mac真可耻！不过作为一个程序员，不手动解决这个问题我是绝对不会善罢甘休的，于是我继续搜索，整整用了一个小时，依然没有解决这个问题。<br>我突然发现我浏览过的数十篇介绍如何配置的文章几乎全都如出一辙，<strong>copied and pasted, again and again</strong>，所以虽然我点开了几十个链接，真正有用的信息其实就那么几条，有的人用的是Windows粘贴在自己博客里面的教程却是Mac的配置文件，我真想问他真的使用这个插件了吗？<del>还是说这个插件其实以前Windows也是这么配置的？</del>（后来我看了源码并不是这样配置的）还有的人直接就是原封不动的复制粘贴了别人的教程，哦，不过他们却不辞辛劳的把原文链接和原作者名匿去了，这样显得更像自己写的？<br>互联网的开放性使得越来越多的信息变得冗余，相比没有网络的时代，我们能获取知识的途径更多了更便捷了，但是冗余的信息也让我们耗费更多本不应该耗费的时间在搜索和提取信息上。而造成这些信息冗余的正是我们这些互联网的使用者。有时候我在想，网上那么多错误、虚假、重复的信息是否能有一种技术或者一批“网络卫士”来清除这些信息只保留那些有价值的不重复的信息呢？我这么一个不知名初出茅庐不久的程序员当然不是想喊出什么和谐网络净化知识的口号，现阶段更没有这个能力去开发实现，我只是觉得作为一个技术从业者，参考、总结、整理优秀的技术文档存入自己的知识库无可厚非，但直接复制粘贴别人的文章到自己的博客中，甚至没有验证过是否可行，除了让信息变得更加冗余之外有什么意义呢？  </p><blockquote><p>Don’t repeat yourself<br>And<br><strong>Don’t repeat others</strong>  </p></blockquote><h3 id="尝试解决问题"><a href="#尝试解决问题" class="headerlink" title="尝试解决问题"></a>尝试解决问题</h3><p>写了这么多废话，还是说一下Windows上这玩意儿怎么配置吧。由于没找到答案，所以我决定自己从源码中寻找答案，从来没写过python的我硬着头皮打开了源码，我定位到了这段代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">launching_web_browser_for_url</span><span class="params">(url, success_msg_default=None, success_msg_user=None)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        setting = Setting.instance()</span><br><span class="line">        <span class="keyword">if</span> setting.browser_command:</span><br><span class="line">            browser_command = [os.path.expandvars(arg).format(url=url)</span><br><span class="line">                               <span class="keyword">for</span> arg <span class="keyword">in</span> setting.browser_command]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> os.name == <span class="string">'nt'</span>:</span><br><span class="line">                <span class="comment"># unicode arguments broken under windows</span></span><br><span class="line">                encoding = locale.getpreferredencoding()</span><br><span class="line">                browser_command = [arg.encode(encoding) <span class="keyword">for</span> arg <span class="keyword">in</span> browser_command]</span><br><span class="line"></span><br><span class="line">            subprocess.Popen(browser_command)</span><br><span class="line">            <span class="keyword">if</span> success_msg_user:</span><br><span class="line">                sublime.status_message(success_msg_user)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># Default web browser</span></span><br><span class="line">            desktop.open(url)</span><br><span class="line">            <span class="keyword">if</span> success_msg_default:</span><br><span class="line">                sublime.status_message(success_msg_default)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">if</span> setting.browser_command:</span><br><span class="line">            log.exception(<span class="string">'Error while launching user defined web browser'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            log.exception(<span class="string">'Error while launching default web browser'</span>)</span><br></pre></td></tr></table></figure></p><p>显然这就是打开浏览器调用的函数，于是我将browser_command和url打印出来，发现传入的参数是跟配置文件中写的一样，但是<code>subprocess.Popen(browser_command)</code>却报错，看来参数有误<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">encoding = locale.getpreferredencoding()</span><br><span class="line">browser_command = [arg.encode(encoding) <span class="keyword">for</span> arg <span class="keyword">in</span> browser_command]</span><br></pre></td></tr></table></figure></p><p>我又将<code>encoding</code>的值打印输出，系统拿到的值是cp936编码，查了一下这是GBK编码的别名，看来这并没有什么问题</p><blockquote><p>微软的CP936通常被视为等同GBK，连 IANA 也以“CP936”为“GBK”之别名[1]。事实上比较起来， GBK 定义之字符较 CP936 多出95字（15个非汉字及80个汉字）  </p></blockquote><p>这时候我注意到<code>subprocess.Popen(browser_command)</code>中并不包含url的参数，而浏览器应该不仅仅打开自身，还需要跳转到对应的url上，所以参数应该是从<code>browser_command</code>中传入的，果然在<code>browser_command</code>中有一个{url}  </p><pre><code>&quot;browser_command&quot;: [&quot;open&quot;, &quot;-a&quot;, &quot;Google Chrome&quot;, &quot;{url}&quot;]</code></pre><p>也就是说这个是不应该被修改的，于是我尝试将前面的所有参数替换为<code>&quot;C:/Program Files (x86)/Google/Chrome/Application/chrome.exe&quot;</code>，果然问题得到解决了。不过这时候我接着看了下面的代码，<code>if setting.browser_command:</code>下面有<code>else</code>，也就是说如果这一项没有配置，系统也会尝试用默认浏览器去打开这个链接，果然我将<code>browser_command</code>置空后依然能打开</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>所以结论是，Windows平台OmniMarkupPreviewer配置项<code>browser_command</code>应该设置为空（默认浏览器打开）或者<code>[&quot;$your_browser_path&quot;,{url}]</code>  </p><p>注：如果你按上述配置了，但依然不能用，控制台提示类似<code>TypeError: Type str doesn&#39;t support the buffer API</code>这样的错误，请参考这个<a href="https://github.com/timonwong/OmniMarkupPreviewer/pull/120" target="_blank" rel="noopener">Pull Request</a>进行修改</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o6sdpimwf.bkt.clouddn.com/uploads/2016/06/dontcopy.jpg&quot; alt=&quot;git&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;假装思考&quot;&gt;&lt;a href=&quot;#假装思考&quot; class=&quot;headerlink&quot; title=&quot;假装思考&quot;&gt;&lt;/a&gt;假装思考&lt;/h3&gt;&lt;p&gt;这篇博客其实并不是教程，只是记录一下今天遇到的我觉得值得吐槽的一件事情。事情是这样的，今天下午我打算回来写个博客，因为博客是用Hexo搭建的，所以写的时候自然想使用markdown来写。平时我都用Atom来写因为它提供了实时预览的功能，但是最近Atom是越用越卡，而在线编辑的又感觉太麻烦，我感觉还是Sublime用起来爽于是就试着找了一个&lt;code&gt;markdown&lt;/code&gt;的插件，也就是&lt;code&gt;OmniMarkupPreviewer&lt;/code&gt;。配置好之后体验了一把（这篇博客就是用这个插件写的）。
    
    </summary>
    
      <category term="假装有思想" scheme="http://zxh.site/categories/%E5%81%87%E8%A3%85%E6%9C%89%E6%80%9D%E6%83%B3/"/>
    
    
      <category term="假装有思想" scheme="http://zxh.site/tags/%E5%81%87%E8%A3%85%E6%9C%89%E6%80%9D%E6%83%B3/"/>
    
      <category term="OmniMarkupPreviewer" scheme="http://zxh.site/tags/OmniMarkupPreviewer/"/>
    
      <category term="Windows" scheme="http://zxh.site/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>多机高可用Redis Sentinel配置</title>
    <link href="http://zxh.site/2016/06/03/redis/"/>
    <id>http://zxh.site/2016/06/03/redis/</id>
    <published>2016-06-03T12:35:56.000Z</published>
    <updated>2018-05-26T03:57:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o6sdpimwf.bkt.clouddn.com/uploads/2016/06/sentinel.png" alt="CLI"></p><h3 id="Redis-Sentinel是什么"><a href="#Redis-Sentinel是什么" class="headerlink" title="Redis Sentinel是什么"></a>Redis Sentinel是什么</h3><p>Redis是一个高性能的<code>key-value</code>存储系统，说白了就是一种小巧而又高效的数据库。作为一种存储系统，自然应该考虑到<code>HA(High Available)</code>,Redis的各种设计都让人觉得很简单、高效、贴心，所以贴心的Redis从2.6版本之后开始支持HA配置，并且它提供了一套易于配置又方便使用的HA系统<a id="more"></a>，这就是<code>Redis Sentinel</code><br><code>HA</code>的实现其实主要做以下几件事： </p><ol><li>master将数据导出成<code>RDB</code>文件(这也是持久化实现的基础)</li><li>将文件同步给slave</li><li>slave将文件导入系统  </li></ol><p>如果只是做系统数据备份，以上就够了，这种情况显然并不需要一个sentinel，sentinel额外的工作是在master挂了之后，从其他的机器中”投票选举”一个新的master，是的真的是民主投票选举，感兴趣的可以去<a href="http://redis.io/topics/sentinel" target="_blank" rel="noopener">官方文档</a>看看具体的实现，sentinel要干的活：  </p><ol><li>实时监测系统中机器的状态</li><li>如果检测到master挂掉之后，选出新的master</li></ol><blockquote><p>Q：一定要选一个新的master吗？为什么？<br>A：slave机器正常情况下是没有写数据的权限的，当然你要是非要修改配置文件，也可以让slave拥有写数据的权限，但是这样一来很可能引起数据出错，所以默认情况下slave应该是只读权限，所以挂掉之后需要升级为master才能继续工作。（多master的配置不在讨论范围内）</p></blockquote><h3 id="用前须知"><a href="#用前须知" class="headerlink" title="用前须知"></a><strong>用前须知</strong></h3><ul><li>一个具有良好<code>&quot;鲁棒性&quot;</code>的Redis Sentinel环境至少需要三台能互相通讯的机器</li><li>如果需要设置密码，多台机器必须使用相同的密码</li><li>任何一个HA系统都不能百分百保证数据的完整和正确性，尤其是配置好之后不好好测试就开始用的…… </li></ul><h3 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a><strong>环境介绍</strong></h3><ul><li>系统环境：CentOS 7.2</li><li>三台机器(IP)：<ul><li>master(13.40.11.96)</li><li>slave(13.40.11.102)</li><li>sentinel(13.40.11.101)</li></ul></li><li>Redis版本：2.8.19 </li></ul><h3 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h3><h4 id="master配置"><a href="#master配置" class="headerlink" title="master配置"></a>master配置</h4><p>master不需要做sentinel相关的配置，不过大多数情况下，我们都应该给系统设置一个密码，<strong>注意：</strong> <em>如果设置了密码，系统中每一台机器都应该设置相同的密码</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requirepass &quot;b840fc02d524045429941cc15f59e41cb7be6c52&quot;</span><br></pre></td></tr></table></figure></p><h4 id="slave配置"><a href="#slave配置" class="headerlink" title="slave配置"></a>slave配置</h4><p>salve中做如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">##slave</span><br><span class="line">slaveof 13.40.11.95 6379</span><br><span class="line">masterauth b840fc02d524045429941cc15f59e41cb7be6c52</span><br></pre></td></tr></table></figure></p><h4 id="sentinel配置"><a href="#sentinel配置" class="headerlink" title="sentinel配置"></a>sentinel配置</h4><p>正确安装好redis之后/etc目录下有一个redis-sentinel.conf的文件，这是一个范例文件，里面详细的写了配置说明，我们参照它的说明手动创建一个配置文件，名字随意位置随意，你能找到在哪儿就行，这里我建立的是/etc/sentinel.conf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">##sentinel</span><br><span class="line">port 26379</span><br><span class="line">sentinel monitor mymaster 13.40.11.95 6379 1</span><br><span class="line">sentinel down-after-milliseconds mymaster 5000</span><br><span class="line">sentinel auth-pass mymaster b840fc02d524045429941cc15f59e41cb7be6c52</span><br><span class="line">sentinel config-epoch mymaster 2</span><br><span class="line">sentinel leader-epoch mymaster 2</span><br></pre></td></tr></table></figure></p><p>好了就这么简单，将master和slave上的redis服务直接重启，然后在sentinel上执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /etc/sentinel.conf --sentinel</span><br></pre></td></tr></table></figure></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="数据备份测试"><a href="#数据备份测试" class="headerlink" title="数据备份测试"></a>数据备份测试</h4><p>环境搭建好了，接下来进行一波测试，在master上随便写点东西，在slave上去读取，如果你没配置错的话，一定能读取到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">##master上</span><br><span class="line">SET test 123</span><br><span class="line">##slave上</span><br><span class="line">GET test</span><br><span class="line">##返回123</span><br></pre></td></tr></table></figure></p><h4 id="模拟宕机"><a href="#模拟宕机" class="headerlink" title="模拟宕机"></a>模拟宕机</h4><p>在master和slave的<code>redis-cli</code>中分别执行<code>info replication</code>命令可以查看到主从关系，然后将master的redis服务停止掉，sentinel会在你设置的<code>down-after-milliseconds</code>毫秒后检测到master失去联系，此时sentinel会将slave升级为master  </p><hr><p>是不是so easy，以上~</p><h5 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h5><p>redis官方文档：<a href="http://redis.io/topics/sentinel" target="_blank" rel="noopener">redis.io/topics/sentinel</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o6sdpimwf.bkt.clouddn.com/uploads/2016/06/sentinel.png&quot; alt=&quot;CLI&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Redis-Sentinel是什么&quot;&gt;&lt;a href=&quot;#Redis-Sentinel是什么&quot; class=&quot;headerlink&quot; title=&quot;Redis Sentinel是什么&quot;&gt;&lt;/a&gt;Redis Sentinel是什么&lt;/h3&gt;&lt;p&gt;Redis是一个高性能的&lt;code&gt;key-value&lt;/code&gt;存储系统，说白了就是一种小巧而又高效的数据库。作为一种存储系统，自然应该考虑到&lt;code&gt;HA(High Available)&lt;/code&gt;,Redis的各种设计都让人觉得很简单、高效、贴心，所以贴心的Redis从2.6版本之后开始支持HA配置，并且它提供了一套易于配置又方便使用的HA系统
    
    </summary>
    
      <category term="后端" scheme="http://zxh.site/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="工具" scheme="http://zxh.site/categories/%E5%90%8E%E7%AB%AF/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="后端" scheme="http://zxh.site/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Redis" scheme="http://zxh.site/tags/Redis/"/>
    
  </entry>
  
</feed>
