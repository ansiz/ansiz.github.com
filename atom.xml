<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ansiz</title>
  
  <subtitle>迎风向前是唯一的方法</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zxh.site/"/>
  <updated>2018-08-12T00:41:53.063Z</updated>
  <id>http://zxh.site/</id>
  
  <author>
    <name>张稀虹</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HPC 系列文章(4):Slurm概览</title>
    <link href="http://zxh.site/2018/08/11/HPC-%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0-4-Slurm%E6%A6%82%E8%A7%88/"/>
    <id>http://zxh.site/2018/08/11/HPC-系列文章-4-Slurm概览/</id>
    <published>2018-08-11T10:25:31.000Z</published>
    <updated>2018-08-12T00:41:53.063Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/08/slurm-better-thumbnail.png" alt="Cover"></p><p>经过前一篇文章的学习，大家应该对HPC集群调度系统有了初步的认识。接下来我们将以Slurm作为调度系统进行HPC作业相关的学习，会深入介绍Slurm的架构、配置及使用。</p><h2 id="Slurm概述"><a href="#Slurm概述" class="headerlink" title="Slurm概述"></a>Slurm概述</h2><p>Slurm是一个可工作于各种不同规模的Linux集群之上的开源、具备容错性和高度可扩展性的集群管理和作业调度系统。作为一款集群作业调度管理系统，Slurm包含三大主要功能：</p><ol><li>资源分配：在特定时间段内为用户分配对计算资源的独占或非独占访问权限，以便他们可以执行作业。简单的说就是为作业提供对计算资源的授权和分配。</li><li>作业管理：它提供了在分配的节点上启动、执行和监控作业（通常是并行作业）的框架。</li><li>作业调度：通过管理待处理作业的队列来仲裁资源的争用。例如根据优先级或不同当调度策略调整资源的分配顺序。<a id="more"></a></li></ol><p>除此之外还提供了可选的插件用于计费、资源预留、多种调度策略、拓扑优化的资源选择、基于用户或账户的资源限制以及复杂的多因素作业优先级算法等功能。</p><h2 id="Slurm架构"><a href="#Slurm架构" class="headerlink" title="Slurm架构"></a>Slurm架构</h2><p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/08/slurm-arch.gif" alt="架构图"></p><p>先来看看这张官方提供的架构图，图中描述的是单集群内Slurm核心组件的架构及依赖关系。之所以强调单集群，是因为Slurm事实上支持多集群的部署，但为了便于理解，我们这里只介绍单集群的架构，理解之后自然会对多集群部署架构有一个清晰的概念。下面我们根据该图进行详细介绍：</p><h3 id="slurmctld"><a href="#slurmctld" class="headerlink" title="slurmctld"></a>slurmctld</h3><p>Slurm有至少一个集中管理器<code>slurmctld</code>用于监控资源和作业，因为slurmctld对于整个集群管理来说至关重要，所以为了保证系统的高可用，你可以选择部署多个备用的<code>slurmctld</code>用以容灾。绝大多数功能和状态都是由slurmctld提供和管理的，安装了slurmctld的节点我们称之为主控节点，它就像是系统中的指挥官，掌控全局信息并指挥其他程序完成作业，包含以下作用：</p><ul><li>与计算节点上的slurmd进程保持通讯，负责作业下发及状态监控，slurmctld与slurmd是一对多的关系</li><li>负责集群资源的整体调度</li><li>负责集群作业队列的管理</li><li>收集资源使用信息，并交由slurmdbd记录</li><li>提供所有功能的接口，包括节点信息、作业信息、资源信息、作业控制等等</li></ul><h3 id="slurmd"><a href="#slurmd" class="headerlink" title="slurmd"></a>slurmd</h3><p>每个计算节点上都会运行slurmd进程，用以接收主控节点的指令并汇报节点及任务状态。具体作用：</p><ul><li>与主控节点交换数据</li><li>收集本机运行状态并将数据发送给主控节点</li><li>负责运行作业并在整个作业生命周期中提供管理</li></ul><h3 id="slurmdbd"><a href="#slurmdbd" class="headerlink" title="slurmdbd"></a>slurmdbd</h3><p>slurmdbd是可选的，没有它slurmd的作业系统也可以正常工作，不过实际环境中它却是必不可少的，它用于提供管理账户信息、资源使用情况、作业统计报表等等功能。主要功能：</p><ul><li>账户管理</li><li>生成报表</li><li>计费</li></ul><h3 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h3><p>除上述组件之外，slurm还提供了很多命令行工具，其中用户工具包括：</p><ul><li>sbatch：用于创建批处理作业</li><li>srun：用于创建交互作业</li><li>salloc: 用于获取作业资源分配</li><li>scancel：用于终止排队等候或正在运行的作业</li><li>sinfo： 用于报告系统状态</li><li>squeue： 用于报告作业状态</li><li>sacct：用于获取正在运行或已经完成的作业或作业步信息</li><li>smap和sview： 以图形方式报告系统和作业状态， 包括网络拓扑</li><li>sreport：提供报表信息</li></ul><p>管理员工具包括：</p><ul><li>scontrol： 用于监视和/或修改集群上的配置和状态信息。</li><li>sacctmgr： 数据库管理工具用于识别群集，有效用户，有效的帐户等信息。</li></ul><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>Slurm包含了调度所需的各种功能，除基本功能之外Slurm还提供了可用于轻松支持各种基础设施的通用插件机制，这允许模块化的方式配置Slurm，下面列出部分Slurm支持的插件以及它们的功能：</p><ul><li>Accounting Storage： 主要用于存储有关作业的历史数据。当与slurmdbd一起使用时，它还可以提供基于限制的系统以及历史系统状态。</li><li>Account Gather Energy： 收集系统中每个作业或节点的能耗数据，此插件集成于Accounting Storage和Job Account Gather插件中。</li><li>Authentication of communications: 提供Slurm各种组件之间的认证机制。</li><li>Checkpoint: 提供检查机制接口</li><li>Cryptography (Digital Signature Generation)： 用于生成数字签名的机制，验证作业步被授权在特定节点上执行。这与用于验证的插件不同，因为作业步请求是从用户的srun命令而不是直接从slurmctld守护进程发出的，该插件用于生成作业步凭证及其数字签名。</li><li>Generic Resources：提供用于控制如GPU、CPU等通用资源的接口。</li><li>Job Submit： 自定义作业提交插件。</li><li>Job Accounting Gather： 收集作业步资源使用情况。</li><li>Job Completion Logging： 负责作业终止记录，所收集的数据通常是- Accounting Storage Plugin的子集。</li><li>Launchers： 控制srun命令用于启动任务的机制。</li><li>MPI： 为各种MPI实现提供不同的钩子。例如用于设置MPI特定的环境变量。</li><li>Preempt： 设定作业抢占机制。</li><li>Priority: 为作业指定优先级。</li><li>Process tracking (for signaling): 提供作业进度追踪，用于信号捕获及作业信息统计。</li><li>Scheduler: 决定作业如何调度。</li><li>Node selection: 决定资源如何分配。</li><li>Switch or interconnect: 交换机或互连接口插件。对于大多数系统（以太网或infiniband），这不是必需的。</li><li>Task Affinity: 提供绑定作业的机制，并将其各个任务分配给特定的处理器。</li><li>Network Topology：根据网络拓扑优化资源选择。用于工作分配和高级预约。</li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/08/concept.gif" alt="concept"></p><p>要正确理解Slurm的工作流程，我们需要先了解一些基本概念：</p><ul><li>节点（node）：每一台安装并正确配置了slurmd进程的服务器就是一个节点。安装了slurmctld的节点虽然我们称之为主控节点，但实际上它并不是我们这里讨论的节点，这里指的节点即计算资源。</li><li>分区（partition）：分区将一组节点组合成逻辑上的一个集合，也有人称之为“队列”，实际上节点间并没有队列的概念，所以我认为“分区”是一个更合适的翻译。</li><li>作业（job）：<strong>特定时间为用户进行的一次资源申请或分配即可看作一个作业</strong>。这和我们惯性思维中的作业概念并不一致，传统意义上我们总是认为作业应该是某个运行的脚本或者程序，但事实上Slurm的作业只代表一次资源申请或分配。理解这个区别将有利于你理解Slurm中一些比较高级的用法。</li><li>作业步（job step）：Slurm中有作业步的概念，你可以理解为子作业。这允许我们在某个作业中分步骤的细分使用计算资源。</li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://slurm.schedmd.com/overview.html" target="_blank" rel="noopener">Slurm Document</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o6sdpimwf.bkt.clouddn.com/2018/08/slurm-better-thumbnail.png&quot; alt=&quot;Cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;经过前一篇文章的学习，大家应该对HPC集群调度系统有了初步的认识。接下来我们将以Slurm作为调度系统进行HPC作业相关的学习，会深入介绍Slurm的架构、配置及使用。&lt;/p&gt;
&lt;h2 id=&quot;Slurm概述&quot;&gt;&lt;a href=&quot;#Slurm概述&quot; class=&quot;headerlink&quot; title=&quot;Slurm概述&quot;&gt;&lt;/a&gt;Slurm概述&lt;/h2&gt;&lt;p&gt;Slurm是一个可工作于各种不同规模的Linux集群之上的开源、具备容错性和高度可扩展性的集群管理和作业调度系统。作为一款集群作业调度管理系统，Slurm包含三大主要功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;资源分配：在特定时间段内为用户分配对计算资源的独占或非独占访问权限，以便他们可以执行作业。简单的说就是为作业提供对计算资源的授权和分配。&lt;/li&gt;
&lt;li&gt;作业管理：它提供了在分配的节点上启动、执行和监控作业（通常是并行作业）的框架。&lt;/li&gt;
&lt;li&gt;作业调度：通过管理待处理作业的队列来仲裁资源的争用。例如根据优先级或不同当调度策略调整资源的分配顺序。
    
    </summary>
    
      <category term="高性能计算" scheme="http://zxh.site/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/"/>
    
      <category term="HPC" scheme="http://zxh.site/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/HPC/"/>
    
    
      <category term="高性能计算" scheme="http://zxh.site/tags/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/"/>
    
      <category term="HPC" scheme="http://zxh.site/tags/HPC/"/>
    
  </entry>
  
  <entry>
    <title>HPC 系列文章(3):调度系统概览</title>
    <link href="http://zxh.site/2018/08/05/HPC-%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0-3-Slurm%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%A7%88/"/>
    <id>http://zxh.site/2018/08/05/HPC-系列文章-3-Slurm调度系统概览/</id>
    <published>2018-08-05T01:12:33.000Z</published>
    <updated>2018-08-11T10:37:34.766Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/08/schedule.png" alt="Cover"></p><h2 id="初识集群作业调度系统"><a href="#初识集群作业调度系统" class="headerlink" title="初识集群作业调度系统"></a>初识集群作业调度系统</h2><p>经过前面的简单学习，大家应该了解了HPC和集群的基本概念，集群有强大的运算力，那么如何管理集群资源的分配呢？如何管理和实现集群作业调度呢？平时我们在使用一台服务器进行一些作业时，只需要简单的登陆这台服务器执行相关指令即可。不过你是否思考过下面这些问题呢？</p><ol><li>系统中存在若干进程，操作系统会如何安排计算机资源？</li><li>是否可以为某些特定进程分配更多的资源？</li><li>如果我们使用的是多核心处理器，能否让特定的一个或多个核心运行某个程序？<a id="more"></a></li></ol><p>相信如果上学时学过计算机组成原理和操作系统的同学都能对上面几个问题有一些简单的认识。平时我们不用关心这些细节，是因为操作系统已经实现了进程的管理和调度。可见资源调度对于操作系统而言至关重要，集群是由若干台计算机组成的一个系统，它同样需要管理分配计算资源，这就是调度系统存在的意义。</p><p>但集群的调度系统和计算机操作系统的调度系统又有许多不同之处，集群的计算资源分散在系统中由网络互联，我们不可能像使用本地的计算资源一样使用它们。并且我们也不希望某个作业的资源发生竞争而影响执行效率，所以我们也不会采用轮转的方式。<strong>集群调度系统采用的是一种资源隔离和预分配的机制来调度资源。</strong>除此之外它还提供不同的资源分配策略和管理策略，我们再来思考几个问题：</p><ol><li>当系统中空闲的资源不能满足更多的作业时如何处理作业？</li><li>如何保证系统容纳尽可能多的作业？（类似背包问题）</li><li>我能否让特定的作业优先获得资源？</li><li>能否让特定的作业运行在特定配置的节点上？</li><li>在多用户环境下能否限制某些用户的资源用量？</li><li>能否统计每个用户的资源使用量？</li></ol><p>以上这些都是集群调度系统所要处理的问题，并且实际情况会更加复杂。一个优秀的调度系统应该具备多种灵活的调度策略，资源分配时要考虑多种复杂的因素来为作业分配资源，例如CPU、内存、GPU甚至节点所处的网络等，提供资源使用记录及管理，同时它还要能监控和管理节点的工作状态和资源使用情况，为集群提供尽可能高的使用效率。</p><h2 id="调度系统对比"><a href="#调度系统对比" class="headerlink" title="调度系统对比"></a>调度系统对比</h2><p>我们不会因为要做电子表格就自己做一个Excel出来，显然我们也不必因为要使用集群而自行开发这么一套系统，那市面上有哪些集群调度系统呢？打开Google搜索<code>Cluster Scheduler</code>，出来一大堆结果，这里我将我所了解的目前主流的调度系统为大家做一个简单的对比和梳理：</p><div class="note info"><p>如果你用中文搜索“集群调度系统”，得到的结果与我们所讨论的集群作业调度系统有一些区别，国内对相关领域的研究的可参考文献较少，中文搜索的结果与我们要讨论的内容有偏差。建议使用Google进行相关资料检索 </p></div><table><thead><tr><th>软件</th><th>厂商</th><th>授权许可</th><th>平台支持</th><th>最大节点数</th><th>是否收费</th></tr></thead><tbody><tr><td>OpenLava</td><td>Teraproc</td><td>GPL</td><td>Linux</td><td>数千</td><td>免费</td></tr><tr><td>PBS Pro</td><td>Altari</td><td>商业授权</td><td>Linux,Windows</td><td>50k+</td><td>付费</td></tr><tr><td>TORQUE</td><td>Adaptive Computing</td><td>商业授权</td><td>Linux, Unix</td><td>数千</td><td>付费</td></tr><tr><td>Moab Cluster Suite</td><td>Adaptive Computing</td><td>商业授权</td><td>多平台</td><td>数千</td><td>付费</td></tr><tr><td>Platform LSF</td><td>IBM</td><td>商业授权</td><td>Unix, Linux, Windows</td><td>未知</td><td>付费</td></tr><tr><td>Slurm</td><td>SchedMD</td><td>GPL</td><td>Linux,Unix</td><td>120k+</td><td>免费</td></tr></tbody></table><h3 id="术语解释"><a href="#术语解释" class="headerlink" title="术语解释"></a>术语解释</h3><p>本文中讨论的“调度系统”实际应该分成<code>Workload Manager</code>和<code>Resource Manager</code>分别讨论，但为了便于理解，我们讨论的“调度系统”即二者的合称。关于它们的区别：</p><ul><li>Resource Manager<ul><li>为集群资源提供作业队列管理</li><li>创建作业队列</li></ul></li><li>Workload Manager<ul><li>整合了一个或多个Resource Manager的调度管理器，给Resource Manager下指令</li><li>监控作业运行状态</li><li>收集和统计作业及资源使用信息</li><li>实现资源限制和策略制定等</li></ul></li></ul><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>上面这些调度系统，实际上有一些有一些渊源。早期的LSF是开源的，后来成为了商用软件，<code>OpenLava</code>就是基于早期的<code>LSF</code>（Platform LSF 4.2)开发的开源软件。</p><p>然后我们说一说<code>PBS</code>，它最初是由<code>MRJ Technology Solutions</code>这家软件外包商于1991年6月开始为NASA所研发的作业调度系统，MRJ于20世纪90年代末被Veridian收购，2003年<code>Altair</code>公司通过收购Veridian获得了所有PBS技术和知识产权的权利。目前市面上有几个它的衍生产品：</p><ul><li>OpenPBS - 由MRJ于1998年发布的原始开源版本</li><li>TORQUE - 由Adaptive Computing公司（前身为Cluster Resources公司）维护的OpenPBS分支</li><li>PBS Professional（PBS Pro） - <code>Altair Engineering</code>提供的PBS版本。</li></ul><p><code>Torque</code>其实是基于<code>OpenPBS</code>开发的，早期的Torque也是开源免费软件，不过2018年6月开始TORQUE不再开源。<code>Moab</code>的前生叫<code>Maui</code>，Torque自带的scheduler功能比较弱，所以通常是需要配合Maui使用的，Torque+Maui才是我们讨论的调度系统，Maui之前是开源免费的，后来变成了商用软件<code>Moab</code>后不再免费。PBS Pro截止2016年6月之前都是商用付费软件，从2016年6月起，Altair公司宣布提供开源许可并逐步开放源码。</p><p><code>Slurm</code>前期主要由劳伦斯利弗莫尔国家实验室，SchedMD，Linux NetworX，Hewlett-Packard和Groupe Bull负责开发，它受到封闭源Quadrics RMS的启发，并且具有相似的语法。目前由社区和SchedMD公司共同维护，保持开源和免费，由SchedMD公司提供商业支持。</p><h2 id="调度系统选择"><a href="#调度系统选择" class="headerlink" title="调度系统选择"></a>调度系统选择</h2><p>上面已经分析和介绍了几款主流的调度系统，他们中的大多数如今都是商业软件，商业软件缺点是需要付费并且通常价格高昂，但它们提供一些开源免费软件所不具备的优势。例如PBS Pro背靠Altair，Altair生产了一些工业界常用的数值模拟软件，因为属于同一家公司，所以当你恰好需要的就是这些应用软件时，PBS Pro也许是不错的选择。LSF也有一些行业内的应用软件支持，并且它们都提供一些商业技术支持以及相关的完整的解决方案。所以如果你是商用、依赖特定厂商提供的应用层配套软件并且不差钱，这些商用调度系统是不错的选择。</p><p>但是综合考虑的话，我更倾向于推荐Slurm作为调度管理器。首先它是开源且免费的，我们可以学习它的源码，基于Slurm开发产品。其次从对比数据可以看出来它具备非常优秀的设计和性能，目前全球许多超算中心和超大规模的集群包括我国的天河二号等都采用Slurm作为调度系统。而且Slurm目前仍然处于活跃的开发和维护中，社区占有率和话题度都比较高，相关的学习资料也相当完善，并且官方提供了足够详细的使用文档。</p><p>后续的文章我将更加详细的介绍Slurm及其使用。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://en.wikipedia.org/wiki/Comparison_of_cluster_software" target="_blank" rel="noopener">Comparison of cluster software</a></li><li><a href="https://www.mir.wustl.edu/Portals/0/Documents/Uploads/CHPC/WashU_2_moab.pdf" target="_blank" rel="noopener">Job Scheduling with Moab Cluster Suite</a></li><li><a href="https://en.wikipedia.org/wiki/TORQUE" target="_blank" rel="noopener">TORQUE</a></li><li><a href="http://www.linuxclustersinstitute.org/workshops/archive/20th/files/11-MoabTorque/Moab-Torque.pdf" target="_blank" rel="noopener">Moab-Torque</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o6sdpimwf.bkt.clouddn.com/2018/08/schedule.png&quot; alt=&quot;Cover&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;初识集群作业调度系统&quot;&gt;&lt;a href=&quot;#初识集群作业调度系统&quot; class=&quot;headerlink&quot; title=&quot;初识集群作业调度系统&quot;&gt;&lt;/a&gt;初识集群作业调度系统&lt;/h2&gt;&lt;p&gt;经过前面的简单学习，大家应该了解了HPC和集群的基本概念，集群有强大的运算力，那么如何管理集群资源的分配呢？如何管理和实现集群作业调度呢？平时我们在使用一台服务器进行一些作业时，只需要简单的登陆这台服务器执行相关指令即可。不过你是否思考过下面这些问题呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;系统中存在若干进程，操作系统会如何安排计算机资源？&lt;/li&gt;
&lt;li&gt;是否可以为某些特定进程分配更多的资源？&lt;/li&gt;
&lt;li&gt;如果我们使用的是多核心处理器，能否让特定的一个或多个核心运行某个程序？
    
    </summary>
    
      <category term="高性能计算" scheme="http://zxh.site/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/"/>
    
      <category term="HPC" scheme="http://zxh.site/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/HPC/"/>
    
    
      <category term="高性能计算" scheme="http://zxh.site/tags/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/"/>
    
      <category term="HPC" scheme="http://zxh.site/tags/HPC/"/>
    
  </entry>
  
  <entry>
    <title>HPC系列文章(2)：HPC技术概览</title>
    <link href="http://zxh.site/2018/07/28/HPC%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0-2-%EF%BC%9AHPC%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/"/>
    <id>http://zxh.site/2018/07/28/HPC系列文章-2-：HPC技术概览/</id>
    <published>2018-07-28T08:57:13.000Z</published>
    <updated>2018-07-28T15:24:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/AI-HPC.jpg" alt="Cover"></p><h2 id="什么是高性能运算"><a href="#什么是高性能运算" class="headerlink" title="什么是高性能运算"></a>什么是高性能运算</h2><p>在正式学习之前，我们先了解一个非常基本的问题：“究竟什么是高性能计算（HPC）？广义上来说，高性能运算就是使用高性能的计算机完成特定的计算任务。我知道这听上去是一句正确的废话，那我们将这个定义得更详细一些，就目前而言，高性能运算通常指的是通过大量的高性能的计算硬件堆叠而成的计算集群完成特定的计算任务。这里有几个关键词我们分开讨论。<a id="more"></a></p><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>首先是“大量高性能计算硬件堆叠而成的计算集群”，也就是说通常不止一台。为什么不止一台呢？因为就目前的计算机科技水平而言，一台计算机的计算力是非常有限的，而提升单台机器的计算力难度是比较大的，相较之下更简单粗暴的办法就是采用更多的机器，将它们组合到一起，这听上去颇有些暴力美学的味道，集群将一组松散集成的计算机软件和/或硬件连接起来高度紧密地协作完成计算工作。</p><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>然后是“特定的计算任务”，当机器不止一台的时候，想让它们完成同一个任务，这个任务就需要具备一些特殊性。想象一下如果将你写了一段代码或者一个脚本，假设一共100行代码，你将这段代码简单粗暴地拆分成两个50行的文件，分别拿到两台机器上各自运行，会发生什么？显然是无法工作的。那什么样的程序或者代码才能在集群上运行呢？通常该程序需要支持并行运算或者是互不干涉的进行分布式运算。集群的并行运算与我们在拥有多核处理器的单台计算机上并行运行的多线程程序有一些类似，不过集群上的并行运算更复杂一些，因为这些程序运行在不同的机器上，通常并不会直接包含其他同时运行的程序的上下文，而是通过某些特殊的通讯协议来协同作业。或者它们本就是互相不相关的独立作业，每个作业各自完成自己的工作，不必等待其他作业完成后才可以运行，互相之间也没有锁或者资源竞争。只有这样才能充分的利用集群的性能。</p><blockquote><p>并行计算（parallel computing）一般是指许多指令得以同时进行的计算模式。在同时进行的前提下，可以将计算的过程分解成小部分，之后以并发方式来加以解决。</p><p>电脑软件可以被分成数个运算步骤来运行。为了解决某个特定问题，软件采用某个算法，以一连串指令运行来完成。传统上，这些指令都被送至单一的中央处理器，以循序方式运行完成。在这种处理方式下，单一时间中，只有单一指令被运行(processor level: 比较微处理器，CISC, 和RISC，即流水线Pipeline的概念，以及后来在Pipeline基础上以提高指令处理效率为目的的硬件及软件发展，比如branch-prediction, 比如forwarding，比如在每个运算单元前的指令堆栈，汇编程序员对programm code的顺序改写)。并行运算采用了多个运算单元，同时运行，以解决问题。</p></blockquote><h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><p>最后一个关键词是“高性能”，这就有别于一般的分布式计算（不过它们也有很多相通之处）。不知道大家是否有了解过一些分布式计算的项目，它们召集一些志愿者贡献出自己电脑空闲的计算力，一起为一些科学计算做出贡献，这些节点对于计算节点的性能没有特别严格的限制，甚至可以不限制硬件平台，如果你愿意参与你就可以为这些计算项目贡献一点力量，这是一种更加松散的架构，包括现在有的“挖矿”项目也是类似这样的分布式计算。而高性能运算更加强调性能，包括计算单元（CPU、GPU、FPGA等）、内存、存储、网络等等一系列的硬件都应该具备很强的性能，所以高性能运算还会涉及到异构计算、并行文件系统、高速网络等等。</p><h2 id="高性能计算能做什么"><a href="#高性能计算能做什么" class="headerlink" title="高性能计算能做什么"></a>高性能计算能做什么</h2><p>高性能计算实际上服务于我们的日常生活之中，只是它的存在感很低。举个最简单的例子，天气预报。气象预测实际上应该叫做气象模拟计算，简单的说就是把卫星收集到的大量数据（你可以尽可能想象它的大），通过一些科学的计算模型进行模拟计算并推演，以此为基础来推断未来的天气。如果没有足够强大的计算力，这显然是一项无法完成的任务。提高计算力能够提高模拟计算的速度和精度，这也是为什么这些年天气预报越来越准，能预报的时间越来越长的重要原因。HPC还能应用到各种领域，例如：</p><ul><li>科学计算：例如生物科学上计算DNA序列、化学上有机化学分子计算、物理学中复杂的模型推演、数学中复杂的计算等等。</li><li>工业领域：基于现代力学理论的数值仿真技术广泛应用于航天航空、汽车、船舶、机械、建筑、电子等行业领域。</li><li>人工智能：计算能力的提升和可获得的数据的增加是深度学习的两个关键驱动因素，近些年非常热门的人工智能相关技术都依赖庞大的计算力。</li></ul><p>除此之外，计算金融、国防科技、医学成像、图像编解码、大数据分析等等各种领域都是HPC的用武之地。HPC系统最常见的用户是科学研究人员，工程师和学术机构以及一些政府机构。可以说一切需要计算力解决问题的地方，都可以使用HPC成倍的提升效率。</p><h2 id="我们要学些什么"><a href="#我们要学些什么" class="headerlink" title="我们要学些什么"></a>我们要学些什么</h2><p>集群中的计算力需要有一个合理规范的调度系统，负责分配作业调度,提高集群资源使用率。所以我们需要了解学习HPC集群调度系统。目前常见的HPC集群作业调度系统有Altair公司的<code>PBS</code>、开源的<code>Slurm</code>和IBM公司的<code>LSF</code>，这个系列中主要围绕<code>Slurm</code>进行介绍。</p><p>集群中运行的任务具备一些特殊性，要想发挥出集群的优势，作业需要支持并行运算，或者在集群上运行不相互依赖的分布式作业，所以会简单介绍并行计算以及一些分布式计算相关的知识和技巧。</p><p>大量的设备需要有一个高效可靠的监控和管理系统，所以我也会了解一些分布式监控系统以及一些常见的集群运维手段和工具。</p><p>目前云服务和虚拟化非常火热，并且也可以说是未来的一种技术趋势，在了解和掌握基本的高性能运算基础之上，我还会额外介绍一些虚拟化和云相关的知识，探讨一下高性能计算和云计算如何结合等等。</p><p>概括一下大概有以下内容：</p><ul><li>集群调度系统</li><li>并行计算及部分应用</li><li>集群监控及管理</li><li>云及容器技术</li></ul><p>我个人能力和水平有限，有的东西也是在不断学习的过程中，有任何讲的不对或者不合理的地方，欢迎大家在评论区进行讨论，共同学习进步。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o6sdpimwf.bkt.clouddn.com/2018/07/AI-HPC.jpg&quot; alt=&quot;Cover&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是高性能运算&quot;&gt;&lt;a href=&quot;#什么是高性能运算&quot; class=&quot;headerlink&quot; title=&quot;什么是高性能运算&quot;&gt;&lt;/a&gt;什么是高性能运算&lt;/h2&gt;&lt;p&gt;在正式学习之前，我们先了解一个非常基本的问题：“究竟什么是高性能计算（HPC）？广义上来说，高性能运算就是使用高性能的计算机完成特定的计算任务。我知道这听上去是一句正确的废话，那我们将这个定义得更详细一些，就目前而言，高性能运算通常指的是通过大量的高性能的计算硬件堆叠而成的计算集群完成特定的计算任务。这里有几个关键词我们分开讨论。
    
    </summary>
    
      <category term="高性能计算" scheme="http://zxh.site/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/"/>
    
      <category term="HPC" scheme="http://zxh.site/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/HPC/"/>
    
    
      <category term="高性能计算" scheme="http://zxh.site/tags/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/"/>
    
      <category term="HPC" scheme="http://zxh.site/tags/HPC/"/>
    
  </entry>
  
  <entry>
    <title>HPC系列文章(1)：开篇</title>
    <link href="http://zxh.site/2018/07/22/HPC%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0-1-%EF%BC%9A%E5%BC%80%E7%AF%87/"/>
    <id>http://zxh.site/2018/07/22/HPC系列文章-1-：开篇/</id>
    <published>2018-07-22T05:47:50.000Z</published>
    <updated>2018-07-22T14:27:31.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/AI-HPC.jpg" alt="Cover"></p><h1 id="写在最前"><a href="#写在最前" class="headerlink" title="写在最前"></a>写在最前</h1><p>HPC系列文章是一系列关于高性能计算的技术文章，计划每周更新至少一篇高性能计算相关的文章。为什么要写这些文章呢？首要原因是我个人从事相关的研发工作，我一直认为<code>Learning by teaching</code>是最佳的学习和验证学习效果的方式，所以我想将个人了解的相关知识在这里进行梳理。另外一方面是高性能运算实际上服务于我们每个人的日常生活中，被许多热门技术和行业所依赖，但鲜有人深入了解，真正从事这个行业的人并不像Web开发、深度学习等多，针对高性能运算的技术文章也相对较少，我想将这些文章整理成一个系列供感兴趣的朋友学习了解。<a id="more"></a></p><p>高性能运算涉及的技术领域非常广泛，从高性能硬件基础设施、网络、存储、复杂的调度系统、异构计算、并行计算、繁多的应用软件、虚拟化、云计算等等都会涵盖。可以说每个知识面单独拿出来讲都非常复杂，我自然也不是每个领域都深入了解和涉及，我个人主要从事的是调度系统及虚拟化技术的研究，所以该系列文章也主要包含这些内容。</p><p>高性能运算能用在很多领域，包括科学计算、模拟运算、编解码、深度学习等等都可以通过高性能运算成倍的提速。近几年人工智能产业越来越热，也为高性能计算带来新的生机，高性能计算人才稀缺，整体来说高性能运算是一个非常有价值且正在逐步发展的研究方向。但是正如前面所说，高性能运算涵盖的知识非常多，门槛比较高，我希望这个系列文章能为大家打开这扇门，降低学习的曲线，系统地学习和掌握高性能运算相关的技术。</p><p>我在学习高性能计算相关技术的过程，因为每个领域都有很多可以学习的东西，持续学习的过程可以说是惊喜不断。我也希望能通过这个系列文章为大家带来一些技术上的突破，和大家一起共同进步。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o6sdpimwf.bkt.clouddn.com/2018/07/AI-HPC.jpg&quot; alt=&quot;Cover&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;写在最前&quot;&gt;&lt;a href=&quot;#写在最前&quot; class=&quot;headerlink&quot; title=&quot;写在最前&quot;&gt;&lt;/a&gt;写在最前&lt;/h1&gt;&lt;p&gt;HPC系列文章是一系列关于高性能计算的技术文章，计划每周更新至少一篇高性能计算相关的文章。为什么要写这些文章呢？首要原因是我个人从事相关的研发工作，我一直认为&lt;code&gt;Learning by teaching&lt;/code&gt;是最佳的学习和验证学习效果的方式，所以我想将个人了解的相关知识在这里进行梳理。另外一方面是高性能运算实际上服务于我们每个人的日常生活中，被许多热门技术和行业所依赖，但鲜有人深入了解，真正从事这个行业的人并不像Web开发、深度学习等多，针对高性能运算的技术文章也相对较少，我想将这些文章整理成一个系列供感兴趣的朋友学习了解。
    
    </summary>
    
      <category term="高性能计算" scheme="http://zxh.site/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/"/>
    
      <category term="HPC" scheme="http://zxh.site/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/HPC/"/>
    
    
      <category term="高性能计算" scheme="http://zxh.site/tags/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/"/>
    
      <category term="HPC" scheme="http://zxh.site/tags/HPC/"/>
    
  </entry>
  
  <entry>
    <title>在Deepin上安装TensorFlow</title>
    <link href="http://zxh.site/2018/07/15/%E5%9C%A8Deepin%E4%B8%8A%E5%AE%89%E8%A3%85TensorFlow/"/>
    <id>http://zxh.site/2018/07/15/在Deepin上安装TensorFlow/</id>
    <published>2018-07-15T11:51:33.000Z</published>
    <updated>2018-07-15T13:19:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/tensorflowdeepin.png" alt="NVIDIA-SMI"><br>Tensorflow是目前热门的深度学习框架，官方提供了较为详细的安装文档，不过是针对主流操作系统的，并不包含Deepin这种国产发行版，所以在安装过程中遇到一些问题，这里简单记录一下安装流程。<a id="more"></a></p><h2 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h2><ul><li>Deepin 15.6桌面版</li><li>NVIDIA 1060GTX</li><li>显卡驱动版本：387.34-3deepin</li><li>CUDA版本：8.0</li><li>Tensorflow版本：Tensorflow-GPU(1.4.1)</li><li>cuDNN版本：6.0</li></ul><blockquote><p>注意：请务必注意上述版本，Tensorflow安装最大的坑就在于官方文档总是提供最新的版本，而实际上最新的版本不一定适应于你当前的硬件！</p></blockquote><h2 id="安装NVIDIA显卡驱动"><a href="#安装NVIDIA显卡驱动" class="headerlink" title="安装NVIDIA显卡驱动"></a>安装NVIDIA显卡驱动</h2><p>Deepin默认使用的是开源驱动，该驱动兼容性较好但是性能比NVIDIA原生闭源驱动要差。所以我们要先切换一下驱动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nvidia-driver <span class="comment">#安装驱动包</span></span><br></pre></td></tr></table></figure><p>安装完成后重启系统，在终端中执行nvidia-smi将会看到类似输出：</p><p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/nvidia-smi.png" alt="NVIDIA-SMI"></p><blockquote><p>注意: NVIDIA官网目前提供的最新驱动版本是390，但我安装之后导致系统黑屏驱动无法工作，如无必要不建议安装NVIDIA官网提供的最新版本。</p></blockquote><h2 id="安装CUDA"><a href="#安装CUDA" class="headerlink" title="安装CUDA"></a>安装CUDA</h2><p>因为Deepin和Ubuntu实际上都是基于Debian的，所以我们可以看Tensorflow中Ubuntu的文档进行安装，根据Tensorflow官网提供的链接，NVIDIA将建议安装CUDA9.2，不过这里我们直接用源内提供的8.0版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install nvidia-cuda-dev nvidia-cuda-toolkit nvidia-nsight nvidia-visual-profiler</span><br></pre></td></tr></table></figure><h2 id="安装cuDNN"><a href="#安装cuDNN" class="headerlink" title="安装cuDNN"></a>安装cuDNN</h2><p>安装cuDNN需要进行简单的注册并填写一个简单的调查问卷，注册完成之后即可下载。</p><p>cuDNN也要分很多版本（<a href="https://developer.nvidia.com/rdp/cudnn-archive" target="_blank" rel="noopener">版本列表</a>），这里我们选择<code>cuDNN v6.0 (April 27, 2017), for CUDA 8.0</code>这个版本。直接下载压缩包(<a href="https://developer.nvidia.com/compute/machine-learning/cudnn/secure/v6/prod/8.0_20170307/cudnn-8.0-linux-x64-v6.0-tgz" target="_blank" rel="noopener">cuDNN v6.0 Library for Linux</a>)解压就好：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.<span class="built_in">local</span> <span class="comment"># 如果没有这个文件夹请手动新建</span></span><br><span class="line">tar zxvf ~/Software/cudnn-8.0-linux-x64-v6.0.tgz</span><br></pre></td></tr></table></figure><p>配置LD_LIBRARY_PATH：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建议直接将这个写到bashrc或者zshrc中</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=~/.<span class="built_in">local</span>/cuda/lib64</span><br></pre></td></tr></table></figure><h2 id="安装Tensorflow"><a href="#安装Tensorflow" class="headerlink" title="安装Tensorflow"></a>安装Tensorflow</h2><p>首先安装python和pip，然后执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install tensorflow-gpu==1.4.1</span><br></pre></td></tr></table></figure><p>验证一下安装情况，在python交互模式中输入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow</span><br></pre></td></tr></table></figure><p>如果没有任何报错就说明安装好了，跑一个官网最简单的<a href="https://www.tensorflow.org/get_started/get_started_for_beginners?hl=zh-cn" target="_blank" rel="noopener">对鸢尾花进行分类</a>的demo试试吧，你将看到类似这样的输出：</p><p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/demo.png" alt="NVIDIA-SMI"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o6sdpimwf.bkt.clouddn.com/2018/07/tensorflowdeepin.png&quot; alt=&quot;NVIDIA-SMI&quot;&gt;&lt;br&gt;Tensorflow是目前热门的深度学习框架，官方提供了较为详细的安装文档，不过是针对主流操作系统的，并不包含Deepin这种国产发行版，所以在安装过程中遇到一些问题，这里简单记录一下安装流程。
    
    </summary>
    
      <category term="Linux" scheme="http://zxh.site/categories/Linux/"/>
    
      <category term="深度学习" scheme="http://zxh.site/categories/Linux/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Linux" scheme="http://zxh.site/tags/Linux/"/>
    
      <category term="深度学习" scheme="http://zxh.site/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Deepin——优秀的国产Linux发行版</title>
    <link href="http://zxh.site/2018/07/15/Deepin-%E4%BC%98%E7%A7%80%E7%9A%84%E5%9B%BD%E4%BA%A7Linux%E5%8F%91%E8%A1%8C%E7%89%88/"/>
    <id>http://zxh.site/2018/07/15/Deepin-优秀的国产Linux发行版/</id>
    <published>2018-07-15T04:01:27.000Z</published>
    <updated>2018-07-15T08:26:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/desktop.png" alt="Desktop"></p><p>最近想接触一下深度学习相关的东西，需要用到高性能的GPU做支持，家里吃灰大半年的PC终于有机会重新发光发热了。之前购买这台PC主要是为了玩一些大型的单机游戏，配置还算凑合，有1060GTX的显卡+双固态硬盘，装的当然是Window的操作系统。不过Windows真的不太适合用来做这方面的开发，所以就打算在第二块移动硬盘上安装Linux的操作系统。</p><p>我平时做开发都是在Linux下，所以对Linux还算比较熟悉，但是平时几乎从来不用桌面环境，不过这次需要比较直观的图像输出，就选了Deepin这款基于Debian的国产桌面操作系统。<a id="more"></a>事实上我在15年就在一台笔记本上安装体验了Deepin，那时候体验就已经不错了，不过系统中存在一些小bug，稳定性一般，加上当时开发的东西主要在CentOS上运行，就没有再深入体验。这两天我花了一些时间搭建开发环境，顺便把它弄得更顺手，这个过程中Deepin总体的使用体验远超我的预期。两年的时间，Deepin已经成熟。</p><h2 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h2><p>在这个颜值即正义的时代，检验一个桌面操作系统是否优秀的第一关就是外观，Deepin吸收借鉴了macOS和Windows的很多优秀设计，又将它们各自的槽点进行了改进，形成了一套相当好用的桌面环境。例如多工作区、Dock栏以及多任务视图借鉴了macOS，而文件管理器及菜单中的很多操作更接近于Windows。</p><p>有一些人吐槽说这是抄袭，我不太认可这样的观点，我认为原封不动的照搬才是抄袭，而懂得取舍和改进应该算作创新。</p><h3 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h3><p>Deepin的菜单有三种不同的展示方式，缩小可以变成类似Windows的菜单，放大后类似macOS将所有应用平铺在屏幕中，此外还可以按类别来展示。我个人更喜欢Windows那样的，按下菜单键后可以直接输入应用名打开程序，比较高效。</p><p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/menu-win.png" alt="Win"></p><p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/menu.png" alt="Menu"></p><h3 id="侧边栏"><a href="#侧边栏" class="headerlink" title="侧边栏"></a>侧边栏</h3><p>如今macOS和Windows10都有侧边栏，一个好用的侧边栏会让系统体验更好。Deepin也弄了一个侧边栏，设计还算简洁，不过目前功能比较简单，类似一个微缩的控制面板，而且貌似暂不支持小插件。上半部分是一个可以切换的区域，通知被折叠到了第三页，天气放在第二页。使用体验上不如macOS从上往下滚动舒服，但是比windows的要强一点点，这部分还有较大的优化空间。</p><p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/desktop.png" alt="桌面"></p><h3 id="多工作区"><a href="#多工作区" class="headerlink" title="多工作区"></a>多工作区</h3><p>熟悉macOS的用户应该都非常喜欢macOS的多桌面设计，你可以将不同的软件放到不同的桌面并且可以通过触控板上的手势操作快速切换，macOS可以说把多桌面体验做到了机制。Deepin在这一点上与macOS非常相似，整体使用下来感觉只差一个带手势操作的触控板了。</p><p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/multi-tasks.png" alt="多任务"></p><p>按下Super+s（Super即常见键盘的Win键），就可以快速呼出所有的应用，你可以轻易的将它们排列和切换。</p><p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/multi-workspace.png" alt="多工作区"></p><p> 按下Super+方向键，可以快速在相邻的工作区切换，操作非常方便。与macOS最大的不同是应用最大化之后，macOS中该最大化的应用会独占整个工作区，而Deepin支持多个最大化的应用在同一个工作区。这一点上我个人更喜欢macOS的设计，软件最大化后连菜单栏都会收缩起来，让你可以获得沉浸式的工作体验。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>Deepin的外观设计我个人还是很满意的，不过真正让我觉得惊喜的是它的一些特点和以代码开发人员的思维所做出的一些高效设计。</p><h3 id="兼容常用Windows软件"><a href="#兼容常用Windows软件" class="headerlink" title="兼容常用Windows软件"></a>兼容常用Windows软件</h3><p>Linux在桌面市场上之所以不够流行，其主要原因是桌面软件对Linux支持较少，而Deepin通过精心改造的wine让一些常用的Windows软件可以在系统中运行。例如我们常用的微信桌面版、QQ、网易云音乐、迅雷等等，都可以从Deepin的应用商店里直接安装使用，这解决了很多用户的一大痛点。</p><p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/store.png" alt="多工作区"></p><h3 id="为普通人做的设计"><a href="#为普通人做的设计" class="headerlink" title="为普通人做的设计"></a>为普通人做的设计</h3><p>内置常用软件，提供常用软件的应用商店，内置中文输入法极大降低了普通用户上手Linux的使用成本。国人大多数都是更习惯Windows的操作方式，例如打开“计算机”应该看到磁盘分区，<code>Ctrl+X/C/V</code>分别对应剪切、复制和粘贴。坦白说尽管我欣赏macOS的很多设计，但是在文件管理器上macOS的体验真的算不上优秀，而类windows的操作效率会更高一些。</p><h3 id="为程序员做的设计"><a href="#为程序员做的设计" class="headerlink" title="为程序员做的设计"></a>为程序员做的设计</h3><p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/terminal.png" alt="终端"></p><p>除了照顾普通大众，Deepin针对程序员也做了一些优化，例如尽可能多的快捷键，其中包括<code>Alt+F2</code>快速启动终端、内置快速截图、菜单中就可以设置软件安装源、内置优秀的终端软件等等，这些就算对有经验的Linux用户来说也是一种便利。</p><p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/source.png" alt="软件源"></p><h2 id="配置技巧"><a href="#配置技巧" class="headerlink" title="配置技巧"></a>配置技巧</h2><p>我花了一整天的时间将Deepin打造得更符合我的使用习惯，这里简单分享一下一些优化和遇到的坑</p><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>推荐直接安装应用商店中的shadowsocks-qt,然后配合genpac实现智能代理，再安装上glider实现HTTP代理，这几款软件的安装和使用都非常简单，这里我分享一下我的glider服务配置：<a href="https://gist.github.com/ansiz/5ed26da1dbad594fb09ceca3fa927eb7" target="_blank" rel="noopener">GitHubGist</a></p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>系统默认的字体不算好看，我目前使用的是苹方字体，等宽字体推荐Noto Mono，终端字体我用的<a href="https://github.com/tonsky/FiraCode" target="_blank" rel="noopener">Fira Code Retina</a>，系统对Emoji的支持也比较差，如果你用chrome作为浏览器并且希望能看到彩色的emoji的话，我建议不要各种折腾emoji字体了，直接安装chromoji这个插件。一定要安装emoji字体的话，推荐<a href="https://github.com/emojione/emojione" target="_blank" rel="noopener">emojione</a></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="窗口特效开启失败"><a href="#窗口特效开启失败" class="headerlink" title="窗口特效开启失败"></a>窗口特效开启失败</h4><p>开启窗口特效后会减少画面的撕裂感，显示更为流畅，但需要更多的系统资源。安装完闭源显卡驱动后开启窗口特效失败，需要手动修改<code>~/.config/deepin/deepin-wm-switcher/config.json</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;allow_switch&quot;:true,&quot;last_wm&quot;:&quot;deepin-wm&quot;&#125;</span><br></pre></td></tr></table></figure><h4 id="终端配置选中即复制"><a href="#终端配置选中即复制" class="headerlink" title="终端配置选中即复制"></a>终端配置选中即复制</h4><p>终端选中即复制默认未打开，需要手动配置copy_on_select：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.config/deepin/deepin-terminal/config.conf</span><br><span class="line"></span><br><span class="line">copy_on_select=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>Tips：按鼠标中键就是粘贴</p><h4 id="Vim禁用鼠标"><a href="#Vim禁用鼠标" class="headerlink" title="Vim禁用鼠标"></a>Vim禁用鼠标</h4><p><code>Vim</code>会自动进入鼠标模式，影响内容复制，请手动配置<code>~/.vimrc</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set mouse=</span><br></pre></td></tr></table></figure><h2 id="目前发现的问题"><a href="#目前发现的问题" class="headerlink" title="目前发现的问题"></a>目前发现的问题</h2><ul><li>侧边栏弹出的逻辑不清晰，响应不及时</li><li>拖动操作bug，无论是拖动终端中的Tab还是拖动文件夹中的文件重新排布顺序都无法实现</li><li>字体支持不完整，Emoji支持较差</li><li>暂不支持NVIDIA最新驱动，安装最新的390驱动会导致系统无法启动，目前可以使用387版</li><li>偶尔会出现假死机的情况，现象是鼠标点击无效，键盘操作正常，<a href="https://wiki.deepin.org/index.php?title=%E7%B3%BB%E7%BB%9F%E6%AD%BB%E6%9C%BA" target="_blank" rel="noopener">官方文档</a>也有提到该问题，希望能尽快改善减少。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说Deepin是一款非常优秀的桌面Linux系统，经过多年的打磨，各方面都已经日趋完善，是一款能够满足办公娱乐及开发的桌面系统。</p><p>我还在上小学的时候连音像店都会卖深度快速装机光盘，那是深度起家的黑历史，难以想象当初靠盗版起家的深度自主研发的操作系统能做到这个水准。吸收了很多macOS和Windows的优秀设计，又摒弃了它们的一些槽点，很多细节都是按照开发人员的思维设计的，一些细节上甚至会给人惊喜。令人担心的是深度的CTO兼创始人上个月离职了，希望不要因此而停止这个国产优秀系统的开发，期待更加优秀的Deepin。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o6sdpimwf.bkt.clouddn.com/2018/07/desktop.png&quot; alt=&quot;Desktop&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近想接触一下深度学习相关的东西，需要用到高性能的GPU做支持，家里吃灰大半年的PC终于有机会重新发光发热了。之前购买这台PC主要是为了玩一些大型的单机游戏，配置还算凑合，有1060GTX的显卡+双固态硬盘，装的当然是Window的操作系统。不过Windows真的不太适合用来做这方面的开发，所以就打算在第二块移动硬盘上安装Linux的操作系统。&lt;/p&gt;
&lt;p&gt;我平时做开发都是在Linux下，所以对Linux还算比较熟悉，但是平时几乎从来不用桌面环境，不过这次需要比较直观的图像输出，就选了Deepin这款基于Debian的国产桌面操作系统。
    
    </summary>
    
      <category term="Linux" scheme="http://zxh.site/categories/Linux/"/>
    
      <category term="评测" scheme="http://zxh.site/categories/Linux/%E8%AF%84%E6%B5%8B/"/>
    
    
      <category term="Linux" scheme="http://zxh.site/tags/Linux/"/>
    
      <category term="评测" scheme="http://zxh.site/tags/%E8%AF%84%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>安全的SOCKS5协议</title>
    <link href="http://zxh.site/2018/07/08/%E5%AE%89%E5%85%A8%E7%9A%84socks5%E5%8D%8F%E8%AE%AE/"/>
    <id>http://zxh.site/2018/07/08/安全的socks5协议/</id>
    <published>2018-07-08T07:27:48.000Z</published>
    <updated>2018-07-17T12:11:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/malicious.png" alt="malicious"></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在<code>HTTP</code>/<code>HTTPS</code>的世界里，<code>TCP/IP</code>数据包的源和目标是公开的。恶意的第三方可以干扰网络连接，将污染过的数据包发送给请求源，从而实现阻止或中断连接。<a id="more"></a></p><p>目前已知的攻击手段包括：</p><ul><li>IP封锁 - 对指定IP地址的任何连接尝试都会被恶意的第三方阻止。</li><li>DNS欺骗 - 返回错误的IP地址。</li><li>包过滤 - 当包中被检测到特定的词句时该数据包将会被阻止或丢弃。</li><li>TCP RST - 对在黑名单中的目的地址进行访问时会发送<code>RST</code>包，TCP连接将会立即中断。</li><li>深度学习 - 利用集群深度学习，恶意方可以快速找到可疑的IP地址。</li></ul><p>在这样的封锁下，想要在自由的网络中呼吸新鲜空气听起来像是在做梦。但是极客们显然不愿意因此丢失任何一个数据包。</p><p>解决方案是利用强加密算法的<a href="https://zh.wikipedia.org/wiki/SOCKS" target="_blank" rel="noopener">SOCKS5</a>协议。</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ul><li>穿透防火墙封锁</li><li>隐藏所有数据包数据，包括源，目标，载荷等</li></ul><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>下面介绍常见的安全SOCKS5代理的开发技术及其工作原理</p><h3 id="工作模式介绍"><a href="#工作模式介绍" class="headerlink" title="工作模式介绍"></a>工作模式介绍</h3><h4 id="自由网络"><a href="#自由网络" class="headerlink" title="自由网络"></a>自由网络</h4><p>在没有恶意攻击者的情况下，客户端与服务器端可以正常通讯。</p><p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/free-client-server.gif" alt="free"></p><h4 id="被封锁的网络"><a href="#被封锁的网络" class="headerlink" title="被封锁的网络"></a>被封锁的网络</h4><p>恶意攻击者可以在客户端和服务器之间部署类似防火墙的系统，这样任何请求都不会到达服务器。因此，最终用户无法从服务器获取任何数据。</p><p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/blocking.gif" alt="blocked"></p><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>一种合理的方法是在防火墙之外设置代理服务器。所有流量都需要先通过代理服务器，然后由代理服务器中继。目前代理技术包括HTTP代理，Socks服务，VPN服务，SSH隧道等。SOCKS5也是其中一种代理协议。</p><p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/proxying.gif" alt="proxy"></p><p>举个例子，当请求通过SSH隧道传输时，防火墙无法识别流量，因为数据已加密。但问题是，在创建隧道时进行SSH握手时，很可能会发现代理服务器被用作代理。因此防火墙可以阻止SSH隧道创建步骤的网络连接。</p><h4 id="安全代理"><a href="#安全代理" class="headerlink" title="安全代理"></a>安全代理</h4><p>安全的socks代理不应向防火墙公开以下信息：</p><ul><li>任何表明它被用作代理的特征</li><li>任何真实传输的数据</li></ul><p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/secure-proxy.gif" alt="secure-proxy"></p><p>要解决上述模型中存在的问题，<code>SOCKS5</code>需要进行改进。我们可以把<code>SOCKS5</code>拆分成两部分，<code>socks5-local</code>和<code>socks5-remote</code></p><p>上图中SOCKS5的工作原理主要可以概括为以下几步：</p><ul><li>客户端通过<code>SOCKS5</code>协议向本地代理发送请求。</li><li>本地代理通过<code>HTTP</code>协议发送加密后的请求数据。</li><li>因为HTTP协议没有明显的特征，并且远程代理服务器尚未被识别为代理，因此请求可以穿透防火墙。</li><li>远程代理服务器解密数据后中继到真实服务。</li><li>真实服务将响应返回到远程代理服务器，并通过相同的路径传播回客户端。</li></ul><h3 id="使用SOCKS5作为本地代理协议"><a href="#使用SOCKS5作为本地代理协议" class="headerlink" title="使用SOCKS5作为本地代理协议"></a>使用SOCKS5作为本地代理协议</h3><p><code>SOCKS5</code>在客户端有广泛的支持。我们很容易得到通过SOCKS5从客户端传输数据到本地代理服务器的好处。 SOCKS5在第5层上执行数据传输。</p><p>下面的curl命令演示了客户端能够使用SOCKS5连接到SOCKS5代理服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --socks5 127.0.0.1:1080 https://google.com</span><br></pre></td></tr></table></figure><h3 id="为什么使用HTTP作为传输协议"><a href="#为什么使用HTTP作为传输协议" class="headerlink" title="为什么使用HTTP作为传输协议"></a>为什么使用HTTP作为传输协议</h3><p>HTTP可能是整个互联网上最常见的流量类型。选择HTTP作为传输协议以突破防火墙使得数据包和服务器不太可能被识别用于代理使用。</p><p>HTTPS不适合防火墙突破。因为HTTPS的设计目的是：</p><ul><li>避免恶意方改变内容</li><li>避免恶意方伪装成目标服务器</li><li>数据加密</li></ul><p>而代理软件的目的应满足以下要求：</p><ul><li>避免目标服务器被识别</li><li>避免代理服务器被识别为代理</li><li>数据加密</li></ul><p>基于以上原因，HTTP是突破防火墙比HTTPS或任何其他协议更好的选择。</p><h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><p>密码算法对数据进行加密和解密，这样任何人都无法从加密流中读取数据，除了LocalProxy和RemoteProxy。由于<code>AEAD</code>密码同时提供机密性，完整性和真实性，建议选择下面列出的AEAD系列之一作为在本地代理和远程代理中使用的密码算法：</p><ul><li>chacha20-ietf-poly1305</li><li>aes-256-gcm</li><li>aes-128-gcm</li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>Shadowsocks是一款出色的安全socks5代理解决方案。查看其<a href="https://shadowsocks.org/en/index.html" target="_blank" rel="noopener">官方网站</a>了解更多信息。</p><h2 id="挑战和风险"><a href="#挑战和风险" class="headerlink" title="挑战和风险"></a>挑战和风险</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ul><li>恶意方可以在客户端安装干扰软件，以阻止本地软件和LocalProxy之间的连接。<ul><li>这可以通过强制安装来实现</li><li>它也可以通过嵌入广泛安装的软件来实现</li></ul></li><li>恶意方可能会强制该人卸载LocalProxy</li></ul><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>必须将服务器端部署到没有防火墙阻止的环境中</p><ul><li>恶意方可以强制云提供商或潜入云服务器做以下事情：<ul><li>窃取服务器日志文件</li><li>杀死ServerProxy进程</li></ul></li><li>恶意方也可以是云提供商</li></ul><h3 id="不安全的加密算法"><a href="#不安全的加密算法" class="headerlink" title="不安全的加密算法"></a>不安全的加密算法</h3><p>使用何种加密算法取决于用户，如果最终用户选择不安全的密码算法，可能会增加服务器被识别为代理服务器的风险。提供代理服务的服务器将被封锁。</p><h3 id="IP白名单限制"><a href="#IP白名单限制" class="headerlink" title="IP白名单限制"></a>IP白名单限制</h3><p>如果最终用户只能连接到选定范围的IP列表（即IP白名单），则用户无法使用SOCKS5服务器，因为SOCKS5服务器IP不太可能包含在IP白名单中。</p><h3 id="进一步的风险"><a href="#进一步的风险" class="headerlink" title="进一步的风险"></a>进一步的风险</h3><p>当最终用户泄露密码密钥和流量历史记录时，恶意方可以解密过去的所有流量。</p><h3 id="执法监管"><a href="#执法监管" class="headerlink" title="执法监管"></a>执法监管</h3><p>即使使用安全的SOCKS5代理，也要注意不要泄露任何个人信息。卸载掉那些不可信任的安全证书和软件，据说<code>Shadowsocks</code>的发明者因为通过QQ与朋友聊天最后被“喝茶”。 :)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过秘密部署安全的SOCKS5代理服务器并选择强密码算法，人们可以突破严重的网络封锁。 <code>Shadowsocks</code>可能是您的首选。</p><hr><p>本文翻译自<a href="https://enqueuezero.com/secure-socks5-proxy.html" target="_blank" rel="noopener">secure-socks5-proxy</a>，包含少量修改。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://enqueuezero.com/secure-socks5-proxy.html" target="_blank" rel="noopener">原文</a></li><li><a href="https://zhuanlan.zhihu.com/p/28566058" target="_blank" rel="noopener">什么是AEAD加密</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o6sdpimwf.bkt.clouddn.com/2018/07/malicious.png&quot; alt=&quot;malicious&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在&lt;code&gt;HTTP&lt;/code&gt;/&lt;code&gt;HTTPS&lt;/code&gt;的世界里，&lt;code&gt;TCP/IP&lt;/code&gt;数据包的源和目标是公开的。恶意的第三方可以干扰网络连接，将污染过的数据包发送给请求源，从而实现阻止或中断连接。
    
    </summary>
    
      <category term="网络" scheme="http://zxh.site/categories/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="译文" scheme="http://zxh.site/categories/%E7%BD%91%E7%BB%9C/%E8%AF%91%E6%96%87/"/>
    
    
      <category term="网络" scheme="http://zxh.site/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="译文" scheme="http://zxh.site/tags/%E8%AF%91%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>HPC环境下使用Docker</title>
    <link href="http://zxh.site/2018/07/01/docker-on-cluster/"/>
    <id>http://zxh.site/2018/07/01/docker-on-cluster/</id>
    <published>2018-07-01T04:29:09.000Z</published>
    <updated>2018-07-17T12:11:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/07/docker-banner2.jpg" alt="docker"><br>HPC应用总类繁多，各种软件可能运行在不同的系统平台之上，容器技术正是解决这类问题的绝佳手段。我在<a href="http://blog.zxh.site/2018/05/15/Singularity/" target="_blank" rel="noopener"><em>Singularity——HPC环境的绝佳容器解决方案</em></a>一文中介绍了<code>Singularity</code>这个HPC下非常适合的容器技术。但是Singularity也有一些不尽人意的地方，例如缺少虚拟化网络、热度不如<code>Docker</code>高等。那如果想在一个高性能集群中使用Docker又会遇到什么问题呢？有没有什么好的解决方案？<a id="more"></a></p><h2 id="需要解决的问题"><a href="#需要解决的问题" class="headerlink" title="需要解决的问题"></a>需要解决的问题</h2><h3 id="非root用户运行Docker"><a href="#非root用户运行Docker" class="headerlink" title="非root用户运行Docker"></a>非root用户运行Docker</h3><p>在许多系统中你尝试以普通用户身份运行Docker指令，通常会得到如下提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.37/containers/json: dial unix /var/run/docker.sock: connect: permission denied</span><br></pre></td></tr></table></figure><p>Docker默认不支持普通用户直接运行Docker命令，这里有一篇不错的文章说明了为什么我们不允许非root用户直接运行Docker命令：<a href="http://dockone.io/article/589" target="_blank" rel="noopener"><em>为什么我们不允许非root用户在CentOS、Fedora和RHEL上直接运行Docker命令</em></a>,文章中提到了两个解决方案：</p><ul><li>将非root用户加入<code>docker</code>用户组</li><li>设置<code>sudo</code>规则</li></ul><p>但是这样会给管理员带来一些额外的工作量，不方便与类似<code>Slurm</code>之类的软件配合使用。</p><h3 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h3><p>Docker运行指令实际上会由Docker daemon去执行，所以当你将启动容器的指令包装到一个脚本中再通过调度系统去运行时，集群资源限制会失去作用。原因是它们是由完全不相关的进程去负责启动的，<code>cgroup</code>限制自然会失效。这样一来虽然环境是隔离了，但是失去了资源限制，会影响集群资源分配策略。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>为了解决上述问题，我查询了很多资料，有一篇IEEE论文中提出了一个思路： <a href="https://ieeexplore.ieee.org/document/7923813/" target="_blank" rel="noopener"><em>Enabling Docker Containers for High-Performance and Many-Task Computing</em></a>，我用<code>Golang</code>按照作者的思路开发了一个名为<code>go-socker</code>的工具（GitHub仓库：<a href="https://github.com/ansiz/go-socker" target="_blank" rel="noopener">go-socker</a>）。针对上面的两个问题，<code>go-socker</code>给出了解决方案。<code>go-socker</code>本质上就是封装了一些基本的Docker指令，然后我们将编译后的可执行程序owner设置为root，再为其加上特殊的<code>s</code>权限位，这样普通用户执行的命令就会在程序内被提升到root。<br>关于这个特殊的<code>s</code>权限位介绍： <a href="http://cn.linux.vbird.org/linux_basic/0220filemanager_4.php#suid" target="_blank" rel="noopener">鸟哥的Linux私房菜——第七章、Linux文件与目录管理</a></p><blockquote><p>当 s 这个标志出现在文件拥有者的 x 权限上时，例如刚刚提到的 /usr/bin/passwd 这个文件的权限状态：『-rwsr-xr-x』，此时就被称为 Set UID，简称为 SUID 的特殊权限。 那么SUID的权限对於一个文件的特殊功能是什么呢？基本上SUID有这样的限制与功能：</p><ul><li>SUID 权限仅对二进位程序(binary program)有效；</li><li>运行者对於该程序需要具有 x 的可运行权限；</li><li>本权限仅在运行该程序的过程中有效 (run-time)；</li><li>运行者将具有该程序拥有者 (owner) 的权限。</li></ul></blockquote><p>这样就解决了运行权限的问题，由于我们只封装了容器作业必要的基本指令，所以权限的提升不会带来严重的安全问题。</p><p>对于资源限制的问题，本质上Slurm的资源限制是通过<code>cgroup</code>实现的，所以我们只需要将容器内运行的进程定位到，再将其放到对应的<code>Slurm</code>作业所在的资源限制组中，就实现了资源限制，关于上述问题的详细实现方式可以直接读<a href="https://github.com/ansiz/go-socker" target="_blank" rel="noopener">go-socker</a>的代码了解，也欢迎提交issue和PR！</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://ieeexplore.ieee.org/document/7923813/" target="_blank" rel="noopener"><em>Enabling Docker Containers for High-Performance and Many-Task Computing</em></a></li><li><a href="http://dockone.io/article/589" target="_blank" rel="noopener"><em>为什么我们不允许非root用户在CentOS、Fedora和RHEL上直接运行Docker命令</em></a></li><li><a href="http://cn.linux.vbird.org/linux_basic/0220filemanager_4.php#suid" target="_blank" rel="noopener">鸟哥的Linux私房菜——第七章、Linux文件与目录管理</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o6sdpimwf.bkt.clouddn.com/2018/07/docker-banner2.jpg&quot; alt=&quot;docker&quot;&gt;&lt;br&gt;HPC应用总类繁多，各种软件可能运行在不同的系统平台之上，容器技术正是解决这类问题的绝佳手段。我在&lt;a href=&quot;http://blog.zxh.site/2018/05/15/Singularity/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;em&gt;Singularity——HPC环境的绝佳容器解决方案&lt;/em&gt;&lt;/a&gt;一文中介绍了&lt;code&gt;Singularity&lt;/code&gt;这个HPC下非常适合的容器技术。但是Singularity也有一些不尽人意的地方，例如缺少虚拟化网络、热度不如&lt;code&gt;Docker&lt;/code&gt;高等。那如果想在一个高性能集群中使用Docker又会遇到什么问题呢？有没有什么好的解决方案？
    
    </summary>
    
      <category term="容器" scheme="http://zxh.site/categories/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="HPC" scheme="http://zxh.site/categories/%E5%AE%B9%E5%99%A8/HPC/"/>
    
    
      <category term="HPC" scheme="http://zxh.site/tags/HPC/"/>
    
      <category term="Docker" scheme="http://zxh.site/tags/Docker/"/>
    
      <category term="Slurm" scheme="http://zxh.site/tags/Slurm/"/>
    
  </entry>
  
  <entry>
    <title>有趣的X11</title>
    <link href="http://zxh.site/2018/06/24/x11/"/>
    <id>http://zxh.site/2018/06/24/x11/</id>
    <published>2018-06-24T08:07:04.000Z</published>
    <updated>2018-07-17T12:11:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>大多数熟练使用Linux的用户都习惯于使用高效的命令行进行操作，尤其是在服务器上，安装桌面环境浪费资源、降低稳定性。但是有的应用程序又必须有显示输出才有意义，比如使用服务器运行一些有图像输出的程序时。你可以选择安装桌面环境，然后使用<code>VNC</code>或<code>RDP</code>进行远程桌面连接，但更好的选择其实是使用X窗口系统（以下简称X11）转发输出。这张图片就是一个神奇的Linux文件管理器和macOS文件管理器”运行”在同一桌面下的有趣效果：<br><img src="http://o6sdpimwf.bkt.clouddn.com/2018/05/x11-fs8.png" alt="x11"><br><a id="more"></a></p><h2 id="什么是X11？"><a href="#什么是X11？" class="headerlink" title="什么是X11？"></a>什么是X11？</h2><p>这项有趣的技术自1984年第一版X1发布至今已经有三十多年，可以称得上是古老的技术了。1987年9月15日首次发布现有X窗口系统所用的协议<code>X11</code>（Protocol），后续发布的版本命名为<code>X11R2</code>、<code>X11R3</code>…而今最新的引用实现（引用性、示范性的实现体）版本则是2012年发布的X11R7.7（X11 Release 7.7），所以后来就简称<code>X11</code>了。</p><blockquote><p>X窗口系统（X Window System，也常称为X11或X）是一种以位图方式显示的软件窗口系统。最初是1984年麻省理工学院的研究，之后变成UNIX、类UNIX、以及OpenVMS等操作系统所一致适用的标准化软件工具包及显示架构的运作协定。X窗口系统通过软件工具及架构协定来创建操作系统所用的图形用户界面，此后则逐渐扩展适用到各形各色的其他操作系统上。现在几乎所有的操作系统都能支持与使用X。更重要的是，今日知名的桌面环境——GNOME和KDE也都是以X窗口系统为基础建构成的。————<a href="https://zh.wikipedia.org/wiki/X_Window%E7%B3%BB%E7%B5%B1#.E5.8F.82.E8.A7.81" target="_blank" rel="noopener">维基百科-X窗口系统</a></p></blockquote><p><code>X11</code>最大的特点是它的C/S架构和我们一般认为的Server运行在远端Client运行在本地恰好相反，<code>X11</code>的Server反而通常运行在用户本地的机器上，而运行在远端的Client也并非特指某一个或一种程序，而是一切基于<code>X11</code>开发的GUI。通常我们把X Server安装在本地并启动，例如<code>Windows</code>上的<code>XManager</code>，<code>macOS</code>上的<code>XQuartz</code>等软件，用以接收远端的图像信号并将鼠标、键盘输入转发到远端。你可以把X11理解为将图像数据处理运行在服务器上，但显示信号通过网络输出到另外一台机器上，想象将平时我们使用显示器的HDMI或者DVI线被换成了一根网线。</p><h2 id="X11的优点"><a href="#X11的优点" class="headerlink" title="X11的优点"></a>X11的优点</h2><h3 id="让显示输出更加灵活"><a href="#让显示输出更加灵活" class="headerlink" title="让显示输出更加灵活"></a>让显示输出更加灵活</h3><p>客户端可以在远程服务器上执行计算任务，而X Server仅负责图形显示。既可以充分利用服务器的强大性能进行运算，还不用给服务器安装桌面环境或连接显示器就能看到图像输出，这种场景在集群环境下非常常见。</p><h3 id="让GUI变得可移植"><a href="#让GUI变得可移植" class="headerlink" title="让GUI变得可移植"></a>让GUI变得可移植</h3><p>只有X Server服务端与硬件打交道，所有的客户端都与硬件无关，这让不同的平台上的移植变得很容易。</p><h3 id="风格可自定义"><a href="#风格可自定义" class="headerlink" title="风格可自定义"></a>风格可自定义</h3><p>X系统只负责显示图形，并不限制显示和操作的风格，因此不同的X Window的风格并不相同，用户可以根据自己的喜好进行选择。</p><h2 id="X11的缺点"><a href="#X11的缺点" class="headerlink" title="X11的缺点"></a>X11的缺点</h2><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>X Window的C/S体系（C/S架构）设计在应用程序和视频硬件之间多加了一层软件，导致绘图效率下降，所以引起了一些批评。因此开发了若干扩展，在设备和客户机在同一个系统上时，通过在获取适当许可的情况下，以直接访问设备来改善这一问题。而在Linux上，一些视频驱动已经部分移入内核以提高效率。</p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>另一方面，X也被批评为需要（或者提供）了过多的对硬件的直接访问，从而影响了系统稳定性。行为不良的显卡驱动（有时也可能是应用程序）甚至能够导致整个系统崩溃或者重启；有时即使操作系统仍在工作，它也不能继续渲染其显示（这时除了重启，缺乏好的恢复手段）。目前所有的桌面GUI操作系统都提供某种对硬件的直接访问，支持者认为市场已经证明为了提供图形性能牺牲一点稳定性是值得的。或许将来随着技术和用户的演化这一平衡会有所变化。</p><h3 id="不规范的用户界面"><a href="#不规范的用户界面" class="headerlink" title="不规范的用户界面"></a>不规范的用户界面</h3><p>X刻意不去规范用户界面和程序之间大多数的通信，导致出现了许多非常不同的界面，同时造成程序之间协同的困难；而客户机之间的互操作规范ICCCM以难以正确实现而闻名。后来的标准化尝试，如Motif和CDE，也于事无补。长久以来这已经成为用户和程序员的噩梦。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>X缺乏良好的网络与透明的音效系统。当用户对音效日益期盼时，各种不兼容的音效子系统便出现了。过去，大多数程序员只好忽略网络问题，简单地使用本地操作专用的音效API。第一代客户端-服务端音效系统有rplay和Network Audio System。而最近的努力产生了EsounD（GNOME）和ARts（KDE），而这也并非标准。而其他系统如Media Application Server则正在开发当中。<br>直到最近，X也没有好地解决显示与打印机所打印的内容一致性（所见即所得）的解决方案。许多X客户机完全用PostScript实现打印，而这与发送到服务端的几乎是分离的。从X11R6.3起包含了Xprint，此时客户端已经不错，但是服务器实现还不行。而从X11R6.8起实现的质量已经很好，并且获得了组件支持。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>X11是一个功能非常强大的 C/S 图形显示系统，具有很好的跨网络性能，也易于进行扩展，是一个值得学习研究的技术。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://zh.wikipedia.org/wiki/X_Window%E7%B3%BB%E7%B5%B1" target="_blank" rel="noopener">X窗口系统</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-xwin/" target="_blank" rel="noopener">X Window 系统的窗口显示原理</a></li><li><a href="https://baike.baidu.com/item/X%20Window/7249336" target="_blank" rel="noopener">X Window</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大多数熟练使用Linux的用户都习惯于使用高效的命令行进行操作，尤其是在服务器上，安装桌面环境浪费资源、降低稳定性。但是有的应用程序又必须有显示输出才有意义，比如使用服务器运行一些有图像输出的程序时。你可以选择安装桌面环境，然后使用&lt;code&gt;VNC&lt;/code&gt;或&lt;code&gt;RDP&lt;/code&gt;进行远程桌面连接，但更好的选择其实是使用X窗口系统（以下简称X11）转发输出。这张图片就是一个神奇的Linux文件管理器和macOS文件管理器”运行”在同一桌面下的有趣效果：&lt;br&gt;&lt;img src=&quot;http://o6sdpimwf.bkt.clouddn.com/2018/05/x11-fs8.png&quot; alt=&quot;x11&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://zxh.site/categories/Linux/"/>
    
      <category term="工具" scheme="http://zxh.site/categories/Linux/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Linux" scheme="http://zxh.site/tags/Linux/"/>
    
      <category term="工具" scheme="http://zxh.site/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Slurm+Singularity打造轻量级容器云</title>
    <link href="http://zxh.site/2018/05/25/slurm-singularity/"/>
    <id>http://zxh.site/2018/05/25/slurm-singularity/</id>
    <published>2018-05-25T04:29:09.000Z</published>
    <updated>2018-07-17T12:11:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o6sdpimwf.bkt.clouddn.com/container-blog.jpg" alt="vm_vs_container"></p><p><a href="https://slurm.schedmd.com/" target="_blank" rel="noopener">Slurm</a>是一套功能非常强大的集群调度系统，能够实现按需调度计算资源。<a href="http://singularity.lbl.gov/user-guide" target="_blank" rel="noopener">Singularity</a>是一套轻量的容器系统，它可以无缝的和现有的环境结合，为应用提供一个”运行时环境“，你可以把它想象成一个没有Daemon进程没有网络虚拟化技术的<code>Docker</code>。那二者相结合会产生什么有趣的结果呢？<a id="more"></a></p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>我们先讨论一下这两个技术相结合的应用场景。假设你是一个高大上的用户，需要在一个集群上运行一些高大上的科学计算任务，例如利用集群实现DNA的快速比对，你还会用集群进行气象数据的预测、用集群进行汽车风阻数据模拟计算等等，总之你是一个会在集群中使用各种应用的用户，这样的应用场景在研究所或者高校是非常常见的。显然这些应用都有各种不同的配套软件，而这些软件又可能在不同的系统中才有，那你会怎么办呢？你一定会想到应用容器技术。这就是Slurm结合Singularity的意义。关于为什么要使用Singularity而非Docker，我在<a href="http://blog.zxh.site/2018/05/15/Singularity/#more" target="_blank" rel="noopener">另外一篇文章</a>中有介绍到，这里你只需要知道Singularity是非常适合HPC环境的容器技术即可。</p><h2 id="技术分析"><a href="#技术分析" class="headerlink" title="技术分析"></a>技术分析</h2><p>如果你用过<code>OpenStack</code>，应该知道一个最基本的提供计算服务的云环境需要哪些基本服务，分别是<code>Nova</code>、<code>Neutron</code>、<code>Glance</code>和<code>Keystone</code>，它们分别提供计算、网络、镜像及整个系统的身份鉴权。<code>Nova</code>是<code>Openstack</code>的计算服务，负责启动实例、调度实例、管理系统计算资源，<code>Glance</code>则为实例提供镜像管理。<code>Slurm</code>和<code>Singularity</code>可以实现容器启动、资源调度和镜像使用这三个核心功能。这个过程很简单也很有趣，如果我们把启动指定容器的命令作为一个计算任务丢给<code>Slurm</code>，我们就在一台机器上启动了容器，<code>Slurm</code>能够通过<code>cgroups</code>限制作业对硬件资源的使用。如此一来我们就轻易的实现了一套简单粗暴的容器云。</p><p>上面的内容简单总结就是: <strong>将启动容器这个操作，作为一个作业由<code>Slurm</code>调度到某个计算节点上执行</strong></p><h2 id="技术验证"><a href="#技术验证" class="headerlink" title="技术验证"></a>技术验证</h2><p>我们在一套实验环境中进行上述实验，先在两台安装CentOS系统的机器上部署<code>Slurm</code>及<code>Singularity</code>，克隆一个<code>Ubuntu</code>的系统镜像，然后写一个简单的脚本:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 这个脚本就是让singularity在`Ubuntu`的镜像中运行bash。</span></span><br><span class="line">singularity <span class="built_in">exec</span> ubuntu.simg bash</span><br></pre></td></tr></table></figure><p>再往调度系统中提交这个作业:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srun -p demo01 -w node01 --pty test.sh</span><br></pre></td></tr></table></figure><p>看看效果吧：<br><img src="http://o6sdpimwf.bkt.clouddn.com/srun-demo.jpeg" alt="demo"></p><p>node01本身安装的系统是CentOS，从输出我们可以看到我们的bash实际运行在Ubuntu的系统内。并且这是一个Slurm的作业，这个环境下使用的硬件资源、时长等等都可以被限制。这样一来，有了资源调度、限制、环境隔离……再深入一点，我们如果能让用户随时重新连接到这个环境内，提供命令行或者web的操作，这不就是一个轻量级的容器云了吗？事实上笔者已经实现了上述内容，细节太多就不展开说了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是一次有趣且有价值的尝试，也是一次技术的融合与碰撞。经过这次尝试再反观目前的虚拟化技术，以OpenStack为代表的一站式解决方案实际上是对各种虚拟化技术的整合，其中包含了许多云和虚拟化相关的技术，他们有多种替代品，而将各个组件拆分出来独立使用也可以打造出新的东西，打开新世界的大门。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o6sdpimwf.bkt.clouddn.com/container-blog.jpg&quot; alt=&quot;vm_vs_container&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://slurm.schedmd.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Slurm&lt;/a&gt;是一套功能非常强大的集群调度系统，能够实现按需调度计算资源。&lt;a href=&quot;http://singularity.lbl.gov/user-guide&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Singularity&lt;/a&gt;是一套轻量的容器系统，它可以无缝的和现有的环境结合，为应用提供一个”运行时环境“，你可以把它想象成一个没有Daemon进程没有网络虚拟化技术的&lt;code&gt;Docker&lt;/code&gt;。那二者相结合会产生什么有趣的结果呢？
    
    </summary>
    
      <category term="云技术" scheme="http://zxh.site/categories/%E4%BA%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="虚拟化" scheme="http://zxh.site/categories/%E4%BA%91%E6%8A%80%E6%9C%AF/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="虚拟化" scheme="http://zxh.site/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="Singularity" scheme="http://zxh.site/tags/Singularity/"/>
    
      <category term="Slurm" scheme="http://zxh.site/tags/Slurm/"/>
    
      <category term="云技术" scheme="http://zxh.site/tags/%E4%BA%91%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Singularity——HPC环境的绝佳容器解决方案</title>
    <link href="http://zxh.site/2018/05/15/Singularity/"/>
    <id>http://zxh.site/2018/05/15/Singularity/</id>
    <published>2018-05-15T03:24:27.000Z</published>
    <updated>2018-07-22T05:48:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o6sdpimwf.bkt.clouddn.com/vm_vs_container.png" alt="vm_vs_container"></p><p>高性能计算可以应用在非常多的领域，例如科学计算、深度学习、视频渲染、气象预测等等，各个行业使用完全不同的应用环境，相关的配套软件又可能只存在于各种不同的平台之上，这样的场景在HPC应用环境下非常常见。如何解决这样的问题呢？容器技术肯定是不二之选。<a id="more"></a>但是HPC环境和传统的应用环境又有一些区别，比起Docker，Singularity才是HPC环境下的绝佳容器解决方案。</p><h2 id="为什么不用Docker？"><a href="#为什么不用Docker？" class="headerlink" title="为什么不用Docker？"></a>为什么不用Docker？</h2><p><code>Docker</code>绝对是目前最热的容器技术，但是它却不特别适合HPC环境。有几个重要的原因：</p><ol><li>调度管理器的资源限制无法施加到容器中</li><li>非root用户使用授权问题</li></ol><p>集群中的资源使用通常需要由调度管理器来进行分配，例如<code>Slurm</code>/<code>PBS</code>等系统负责资源分配。调度管理器根据用户需求为每个作业分配一定的资源，实质上是利用<code>cgroups</code>针对每个作业进行配置实现的。而<code>Docker</code>镜像的启动实际上是由<code>Docker Daemon</code>去执行的，如此一来资源限制自然会失效。并且<code>Docker Daemon</code>是由root用户启动的，无论是为普通用户设置<code>sudoer</code>还是将普通用户添加到docker用户组中都不是一个安全的方式。</p><h2 id="Singularity的优势"><a href="#Singularity的优势" class="headerlink" title="Singularity的优势"></a>Singularity的优势</h2><p><code>Singularity</code>拥有容器技术所包含的大多数优势，例如启动迅速、资源开销小、轻松的迁移和扩展等等。除此之外，相较于<code>Docker</code>这样的容器技术，它还有一些独特的优势：</p><ul><li><p>更加轻松的环境打包迁徙：<code>Singularity</code>所依赖的东西都在镜像文件中，不需要再单独打包/导入，直接拷贝走镜像即可。没有复杂的缓存机制，并且该镜像已经过压缩，只需占用非常少的磁盘空间。</p></li><li><p>和现有系统无缝整合：系统用户权限、网络等均直接继承宿主机配置，并且无需进入某个镜像后再执行命令，可以直接在外部调用镜像内的指令，就像执行一个本地安装的指令一样。</p></li><li><p>无需运行daemon进程：<code>Singularity</code>提供的完全是一个运行时的环境，在不使用时不需要单独的进程，不占用任何资源。不由daemon进程代为执行指令，资源限制和权限问题也得以解决。</p></li></ul><p>除了这些优势之外，<code>Singularity</code>还支持多种镜像和容器文件格式，甚至可以直接使用Docker提供的镜像，就像从Docker Hub去pull一个镜像一样简单。<code>Singularity</code>可以轻易的现有的HPC系统整合，几乎无需任何额外的开发就能让现有的HPC变成一个轻量级的容器云。</p><h2 id="Singularity的缺点"><a href="#Singularity的缺点" class="headerlink" title="Singularity的缺点"></a>Singularity的缺点</h2><p>上面提到了很多优势，但singularity也并非绝对完美的。</p><ul><li>缺少网络虚拟化的支持</li><li>目前未实现PID Namespace</li><li>认知度较低</li><li>由于众所周知的原因在国内下载镜像比较困难</li></ul><p><code>Singularity</code>应该是为了解决HPC环境下的软件不兼容而设计的应用容器，所以它并没有像<code>Docker</code>那样提供非常完善的隔离和虚拟化，例如没有PID namespace隔离、没有网络虚拟化。并且它的知名度远不如Docker，社区支持较少，在国内也没有镜像源导致下载镜像速度非常慢甚至失败。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说<code>Singularity</code>目前是绝佳的HPC环境下的容器解决方案，它的一些缺点也可以通过其他方式去克服，另外上面提到的<code>Docker</code>的缺点事实上也有一些特殊的方法去解决。我将在后续的文章中进行介绍。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o6sdpimwf.bkt.clouddn.com/vm_vs_container.png&quot; alt=&quot;vm_vs_container&quot;&gt;&lt;/p&gt;
&lt;p&gt;高性能计算可以应用在非常多的领域，例如科学计算、深度学习、视频渲染、气象预测等等，各个行业使用完全不同的应用环境，相关的配套软件又可能只存在于各种不同的平台之上，这样的场景在HPC应用环境下非常常见。如何解决这样的问题呢？容器技术肯定是不二之选。
    
    </summary>
    
      <category term="高性能计算" scheme="http://zxh.site/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/"/>
    
      <category term="虚拟化" scheme="http://zxh.site/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="容器" scheme="http://zxh.site/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/%E8%99%9A%E6%8B%9F%E5%8C%96/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="虚拟化" scheme="http://zxh.site/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="容器" scheme="http://zxh.site/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="高性能计算" scheme="http://zxh.site/tags/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/"/>
    
      <category term="Singularity" scheme="http://zxh.site/tags/Singularity/"/>
    
  </entry>
  
  <entry>
    <title>Docker in LXC踩坑</title>
    <link href="http://zxh.site/2018/02/28/Docker-in-LXC%E8%B8%A9%E5%9D%91/"/>
    <id>http://zxh.site/2018/02/28/Docker-in-LXC踩坑/</id>
    <published>2018-02-28T04:30:22.000Z</published>
    <updated>2018-05-27T02:02:03.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o6sdpimwf.bkt.clouddn.com/LXC-Docker.png" alt="LXC-Docker"></p><p>我们知道Docker是如今炙手可热的应用级容器，而LXC可以看作是系统级的容器。那么问题来了，是否可以在一个系统级的容器里面运行一个应用级的容器呢？答案是可以的，不过过程并没有想象的那么容易，百般折腾后部署成功了，在这个过程中也发现了一些问题。<a id="more"></a></p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ol><li>Docker无法启动</li><li>Docker中无法pull镜像</li><li>配置文件中配置项升级后不兼容</li><li>容器内Redis无法启动</li></ol><h3 id="Docker无法启动"><a href="#Docker无法启动" class="headerlink" title="Docker无法启动"></a>Docker无法启动</h3><p>在LXC容器中安装Docker后始终无法启动，最后发现是系统的问题，这里不是宿主机的系统有问题，而是LXC的系统。测试发现Ubuntu系统可以正常启动Docker，而CentOS则不行</p><h3 id="Docker中无法pull镜像"><a href="#Docker中无法pull镜像" class="headerlink" title="Docker中无法pull镜像"></a>Docker中无法pull镜像</h3><p>使用docker pull命令拉取镜像，当镜像下载完成后会提示<code>failed to register layer: ApplyLayer exit status 1 stdout:  stderr: permission denied</code>导致无法完成镜像的下载。造成这个问题的原因是没有解除apparmor限制，在启动lxc容器之后，需要执行下列命令：</p><blockquote><p>NOTE: $HOST修改为对应的容器主机名</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;&gt;/var/lib/lxc/<span class="variable">$HOST</span>/config &lt;&lt;EnD</span><br><span class="line">lxc.aa_profile = unconfined</span><br><span class="line">lxc.cgroup.devices.allow = a</span><br><span class="line">lxc.cap.drop =</span><br><span class="line">EnD</span><br></pre></td></tr></table></figure><blockquote><p>NOTE: lxc.aa_profile = unconfined应该更正为lxc.apparmor.profile = unconfined，下文会提到</p></blockquote><p>然后修改<code>/etc/pve/lxc/$HOST.conf</code>文件，在文件末尾加上以下内容:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lxc.hook.mount =</span><br><span class="line">lxc.hook.post-stop =</span><br></pre></td></tr></table></figure><h3 id="配置文件中配置项升级后不兼容"><a href="#配置文件中配置项升级后不兼容" class="headerlink" title="配置文件中配置项升级后不兼容"></a>配置文件中配置项升级后不兼容</h3><p>LXC配置文件中配置项名称发生了变化，导致启动报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The configuration file contains legacy configuration keys.</span><br><span class="line">Please update your configuration file!</span><br></pre></td></tr></table></figure><p>好在LXC为我们提供了自动升级配置文件的工具<code>lxc-update-config</code>，切换到容器对应的配置文件目录下: <code>cd /var/lib/lxc/$HOST</code>。使用命令对配置文件进行升级:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc-update-config -c config</span><br></pre></td></tr></table></figure><p>其中<code>lxc.aa_profile = unconfined</code>被自动更正为了<code>lxc.apparmor.profile = unconfined</code></p><h3 id="Redis无法启动"><a href="#Redis无法启动" class="headerlink" title="Redis无法启动"></a>Redis无法启动</h3><p>造成该问题的原因是redis的systemd启动脚本中试图使用一些高级权限，修改/etc/systemd/system/redis.service脚本中下列内容后即可正常使用：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PrivateTmp</span>=<span class="literal">no</span></span><br><span class="line"><span class="attr">PrivateDevices</span>=<span class="literal">no</span></span><br><span class="line"><span class="attr">ProtectHome</span>=<span class="literal">no</span></span><br></pre></td></tr></table></figure><hr><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>那在LXC中运行docker性能如何呢？找了几个常见的工具进行性能测试，UnixBench综合测试性能几乎完全一致，fio磁盘测试性能几乎无损耗，性能差距仅1%，Redis-benchmark数据降低约10%（结果仅供参考）</p><h3 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h3><ul><li>UnixBench:</li></ul><p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/05/UnixBench.png" alt="UnixBench"></p><ul><li>fio</li></ul><p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/05/FIO.png" alt="FIO"></p><ul><li>redis-benchmark</li></ul><p><img src="http://o6sdpimwf.bkt.clouddn.com/2018/05/Redis-benchmark.png" alt="Redis-benchmark"></p><blockquote><p>性能测试方案参考：<a href="https://serverscope.io/trials/GdEN#network" target="_blank" rel="noopener">https://serverscope.io/trials/GdEN#network</a></p></blockquote><hr><h2 id="LXC的缺点"><a href="#LXC的缺点" class="headerlink" title="LXC的缺点"></a>LXC的缺点</h2><ul><li>LXC社区热度远不如Docker，这导致除了问题能查询的有效资料并不如Docker丰富，当然也没有像Docker那么丰富的镜像资源。</li><li>LXC还存在跨不同Linux发行版的功能支持不一致，LXC主要在Ubuntu平台上进行维护和开发。例如目前只有Ubuntu上通过<code>apt-get install docker.io</code>安装的Docker能无需加载任何内核补丁正常运行。</li><li>LXC的官方文档不够详细，学习成本比Docker高。</li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://github.com/moby/moby/issues/6783" target="_blank" rel="noopener">GitHub Issues - Unable to run Docker 1.0 inside LXC</a></li><li><a href="https://github.com/lxc/lxd/issues/3845" target="_blank" rel="noopener">GitHub Issues - All containers emit “The configuration file contains legacy configuration keys” after minor LXD upgrade</a></li><li><a href="https://github.com/lxc/lxd/issues/3799" target="_blank" rel="noopener">GitHub Issues - cant install redis-server on a debian/buster container</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o6sdpimwf.bkt.clouddn.com/LXC-Docker.png&quot; alt=&quot;LXC-Docker&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们知道Docker是如今炙手可热的应用级容器，而LXC可以看作是系统级的容器。那么问题来了，是否可以在一个系统级的容器里面运行一个应用级的容器呢？答案是可以的，不过过程并没有想象的那么容易，百般折腾后部署成功了，在这个过程中也发现了一些问题。
    
    </summary>
    
      <category term="虚拟化" scheme="http://zxh.site/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="容器" scheme="http://zxh.site/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="虚拟化" scheme="http://zxh.site/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="容器" scheme="http://zxh.site/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="LXC" scheme="http://zxh.site/tags/LXC/"/>
    
  </entry>
  
  <entry>
    <title>Linux定制化镜像制作指南</title>
    <link href="http://zxh.site/2018/02/16/Linux%E5%AE%9A%E5%88%B6%E5%8C%96%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%8C%87%E5%8D%97/"/>
    <id>http://zxh.site/2018/02/16/Linux定制化镜像制作指南/</id>
    <published>2018-02-16T13:29:09.000Z</published>
    <updated>2018-05-26T04:19:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o6sdpimwf.bkt.clouddn.com/customized-cd-3.png" alt="image3"></p><h2 id="为什么需要定制化？"><a href="#为什么需要定制化？" class="headerlink" title="为什么需要定制化？"></a>为什么需要定制化？</h2><p>一款软件的正式发布，往往需要完善各个细节。其中安装部署是否方便友好很大程度上会影响到用户对该产品的易用性的评价。所以我们往往会看到软件厂商会给用户提供安装包，用户只需要一股脑儿的下一步，就可以完成<del>垃圾</del>软件的安装了。但一套大型的系统软件往往会有很多依赖，所以我们不仅要封装软件，最好连运行环境都要进行打包。于是现在很流行给用户提供一个<code>Dockerfile</code>或者<code>docker-compose.yml</code>，让用户开箱即用。但是如果用户需要从裸机开始部署呢？既然连系统都没有，当然是做成安装光盘。系统、软件、依赖环境一股脑全部部署。我们从头说起。<a id="more"></a></p><h2 id="当我谈“定制化Linux安装镜像”，我在定制什么？"><a href="#当我谈“定制化Linux安装镜像”，我在定制什么？" class="headerlink" title="当我谈“定制化Linux安装镜像”，我在定制什么？"></a>当我谈“定制化Linux安装镜像”，我在定制什么？</h2><ul><li>安装界面定制化<ul><li>🎨  <code>Boot Menu</code>定制化</li><li>🎨  <code>Anaconda</code>图形界面定制化</li></ul></li><li>📃  自定义安装信息收集</li><li>📦  配套软件打包</li><li>🤖️  安装自动化</li></ul><h2 id="Linux安装光盘分析"><a href="#Linux安装光盘分析" class="headerlink" title="Linux安装光盘分析"></a>Linux安装光盘分析</h2><p>在网上下载一个Linux系统安装镜像，这里我用的是<code>CentOS-7-x86_64-Minimal-1511.iso</code>，将镜像挂载到开发环境中</p><ul><li>Linux:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/CentOS7</span><br><span class="line">mount -t iso9660 ./CentOS-7-x86_64-Minimal-1511.iso /tmp/CentOS7</span><br></pre></td></tr></table></figure><ul><li>Mac:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/CentOS7</span><br><span class="line">hdiutil attach -nomount ./CentOS-7-x86_64-Minimal-1511.iso</span><br><span class="line">mount -t cd9660 /dev/disk4 /tmp/CentOS7</span><br></pre></td></tr></table></figure><p><img src="http://o6sdpimwf.bkt.clouddn.com/customized-cd-1.png" alt="image1"></p><p>上图即该镜像包含的所有文件，分别介绍一下：</p><ul><li>EFI 负责引导的，包含bootloader</li><li>images PXE安装时需要的内核和引导程序（其实和isolinux中的内核及引导程序是相同的，不知道为啥放两个…）</li></ul><p><img src="http://o6sdpimwf.bkt.clouddn.com/customized-cd-2.png" alt="image2"></p><ul><li>isolinux 系统内核及引导程序</li><li>LiveOS 包含了压缩的rootfs.img</li><li>Packages rpm包</li><li>repodata 安装包源信息</li></ul><p>对于光盘的定制化，我们通常不需要对EFI/images进行任何操作，需要定制的是isolinux、LiveOS中的rootfs.img以及Packages，isolinux影响到进入安装的第一步，rootfs中包含的文件影响安装过程，Packages则是放我们所需要的第三方软件rpm安装包。</p><hr><h2 id="Linux安装流程分析"><a href="#Linux安装流程分析" class="headerlink" title="Linux安装流程分析"></a>Linux安装流程分析</h2><blockquote><p>以下实验环境为CentOS(7.2.1511)，其他发行版本可能略有区别</p></blockquote><p>当我们启动安装光盘时，我们看到的是什么？<br>首先是ISOLINUX Boot Menu</p><p><img src="http://o6sdpimwf.bkt.clouddn.com/customized-cd-3.png" alt="image3"></p><p>然后是Anaconda</p><blockquote><p>Anaconda is the installer used by Red Hat Enterprise Linux, Fedora, and their derivatives.</p></blockquote><p><img src="http://o6sdpimwf.bkt.clouddn.com/customized-cd-4.png" alt="image"></p><p>从光盘加载到系统安装完成经历了什么呢？</p><ol><li>开机</li><li>BIOS检测（硬件检测、引导顺序等）</li><li>读取并运行装置内 MBR 的 boot Loader</li><li>加载内核</li><li>启动liveCD或Anaconda</li><li>由用户配置安装选项或解析kickstart配置</li><li>分区并挂载文件系统</li><li>完成安装，重启</li></ol><blockquote><p>NOTE: 步骤7时的rootfs是LiveOS/squashfs.img中的rootfs.img，而完成安装后的rootfs目前在/mnt/sysimage中</p></blockquote><p>⚠️ <strong>但是我们缺少了重要的“定制化安装信息收集”</strong>，从上面的流程分析可知，可以在Boot Menu和Anaconda之间插一脚（4～5步骤中增加一步），额外收集一些用户提供的安装信息。</p><p>我们需要先找到Anaconda的启动入口，上面已经介绍了如何挂载光盘，接下来我们需要把光盘里面的文件继续展开。因为挂载的ISO是只读的，所以我们需要将文件复制出来，分析修改完文件之后，再重新打包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 挂载光盘💿</span></span><br><span class="line">mkdir /tmp/CentOS7</span><br><span class="line">hdiutil attach -nomount ./CentOS-7-x86_64-Minimal-1511.iso</span><br><span class="line">mount -t cd9660 /dev/disk4 /tmp/CentOS7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制文件</span></span><br><span class="line">mkdir CentOS-7-x86_64-Minimal-1511</span><br><span class="line">rsync -avz /tmp/CentOS7/ CentOS-7-x86_64-Minimal-1511</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制LiveOS</span></span><br><span class="line">cp -r CentOS-7-x86_64-Minimal-1511/LiveOS ./LiveOS</span><br></pre></td></tr></table></figure><p>现在得到了一个包含了squashfs.img的LiveOS文件夹，squashfs.img是干啥的？简单的说它是一个高压缩率的压缩文件，压缩了整个rootfs，看上去只有200多MB，实际上有2GB</p><blockquote><p>Squashfs is a compressed read-only file system for Linux. Squashfs compresses files, inodes and directories, and supports block sizes up to 1 MB for greater compression. Several compression algorithms are supported. Squashfs is also the name of free software, licensed under the GPL, for accessing Squashfs filesystems.</p></blockquote><p>执行命令解压开，你会得到一个包含了<code>LiveOS/rootfs.img</code>的名为<code>squashfs-root</code>的文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsquashfs squashfs.img</span><br></pre></td></tr></table></figure><p><img src="http://o6sdpimwf.bkt.clouddn.com/customized-cd-5.png" alt="image"><br>可以看到该文件其实是<code>ext4</code>的文件系统，启动一个Linux环境，挂载该文件，就能看到里面的所有东西了。这里我用docker启动了一个centos7环境<br><img src="http://o6sdpimwf.bkt.clouddn.com/customized-cd-6.png" alt="image"><br>是不是跟Linux的根目录文件一样？这就是在安装时系统加载的rootfs，而Anaconda的入口文件就是usr/sbin/anaconda，这是一个Python脚本。我们打开它找到它的入口，在这里调用其他的脚本或者程序，就可以在Anaconda之前插一脚了。这里我自己写了一个小程序来收集用户的信息，在anaconda的入口处先调用这个程序。<br><img src="http://o6sdpimwf.bkt.clouddn.com/customized-cd-7.png" alt="image"></p><p>修改完毕之后，我们需要重新压缩squashfs.img</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mksquashfs squashfs-root squashfs.img -b 1024k -comp xz</span><br></pre></td></tr></table></figure><p>把新的squashfs.img替换复制出来的光盘镜像文件中的squashfs.img。用dd命令将原来的iso引导信息导出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo cp squashfs.img CentOS-7-x86_64-Minimal-1511/LiveOS/</span><br><span class="line">dd <span class="keyword">if</span>=CentOS-7-x86_64-Minimal-1511.iso bs=512 count=1 of=boot.mbr</span><br></pre></td></tr></table></figure><p>最后重新制作iso镜像，这里我用的是<code>xorriso</code>，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xorriso -pathspecs as_mkisofs -as mkisofs -iso-level 3 -full-iso9660-filenames -volid <span class="string">"CentOS 7 x86_64"</span> -appid  -publisher  -preparer <span class="string">"prepared by me"</span> -eltorito-boot isolinux/isolinux.bin -eltorito-catalog isolinux/boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table -isohybrid-mbr ../boot.mbr -eltorito-alt-boot -e images/efiboot.img -no-emul-boot -isohybrid-gpt-basdat -output ../repacked.iso .</span><br></pre></td></tr></table></figure><p>现在让我们看看repacked.iso运行起来是什么样的吧：<br><img src="http://o6sdpimwf.bkt.clouddn.com/customized-cd-8.png" alt="image"></p><hr><h2 id="界面定制化"><a href="#界面定制化" class="headerlink" title="界面定制化"></a>界面定制化</h2><h3 id="Boot-Menu定制"><a href="#Boot-Menu定制" class="headerlink" title="Boot Menu定制"></a>Boot Menu定制</h3><p>只需要修改isolinux/isolinux.cfg文件，文档参考：<a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/anaconda_customization_guide/sect-boot-menu-customization" target="_blank" rel="noopener">boot-menu-customization</a> </p><h3 id="Anaconda界面定制"><a href="#Anaconda界面定制" class="headerlink" title="Anaconda界面定制"></a>Anaconda界面定制</h3><p>Anaconda界面定制的修改稍微复杂一些，需要修改css文件，文档参考：<a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/anaconda_customization_guide/sect-anaconda-visuals#sect-anaconda-visuals-graphics" target="_blank" rel="noopener">customized-anaconda</a></p><hr><h2 id="自动化脚本（未完待续）"><a href="#自动化脚本（未完待续）" class="headerlink" title="自动化脚本（未完待续）"></a>自动化脚本（未完待续）</h2><h3 id="kickstart"><a href="#kickstart" class="headerlink" title="kickstart"></a>kickstart</h3><h3 id="程序部署脚本"><a href="#程序部署脚本" class="headerlink" title="程序部署脚本"></a>程序部署脚本</h3><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/anaconda_customization_guide/" target="_blank" rel="noopener">ANACONDA CUSTOMIZATION GUIDE</a> </li><li><a href="https://anaconda-installer.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">anaconda文档</a></li><li><a href="http://blog.csdn.net/trochiluses/article/details/17674415" target="_blank" rel="noopener">Linux安装过程分析</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/1306_qinzl_squashfs/" target="_blank" rel="noopener">基于 SquashFS 构建 Linux 可读写文件系统</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o6sdpimwf.bkt.clouddn.com/customized-cd-3.png&quot; alt=&quot;image3&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;为什么需要定制化？&quot;&gt;&lt;a href=&quot;#为什么需要定制化？&quot; class=&quot;headerlink&quot; title=&quot;为什么需要定制化？&quot;&gt;&lt;/a&gt;为什么需要定制化？&lt;/h2&gt;&lt;p&gt;一款软件的正式发布，往往需要完善各个细节。其中安装部署是否方便友好很大程度上会影响到用户对该产品的易用性的评价。所以我们往往会看到软件厂商会给用户提供安装包，用户只需要一股脑儿的下一步，就可以完成&lt;del&gt;垃圾&lt;/del&gt;软件的安装了。但一套大型的系统软件往往会有很多依赖，所以我们不仅要封装软件，最好连运行环境都要进行打包。于是现在很流行给用户提供一个&lt;code&gt;Dockerfile&lt;/code&gt;或者&lt;code&gt;docker-compose.yml&lt;/code&gt;，让用户开箱即用。但是如果用户需要从裸机开始部署呢？既然连系统都没有，当然是做成安装光盘。系统、软件、依赖环境一股脑全部部署。我们从头说起。
    
    </summary>
    
      <category term="Linux" scheme="http://zxh.site/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://zxh.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>简单聊聊元编程</title>
    <link href="http://zxh.site/2018/02/01/meta-programming/"/>
    <id>http://zxh.site/2018/02/01/meta-programming/</id>
    <published>2018-02-01T13:48:10.000Z</published>
    <updated>2018-05-26T04:19:54.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o6sdpimwf.bkt.clouddn.com/blog/2017-02-01/code.png" alt="auto"></p><h2 id="什么是元编程"><a href="#什么是元编程" class="headerlink" title="什么是元编程"></a>什么是元编程</h2><p>编程，字面意思即编写程序。</p><p>那什么是元编程呢？广义的看，我认为让任何事物按照特定的指令执行特定的动作，就可以算作编程。如果我是一个教官，组织一百号人军训，我让所有人报数，其实也算编程。不过因为人很聪明，所以我只需要一个简单的指令，就完成了这次“编程”。每一个人，我们都可以认为是一个元，Ta能够自动生成剩余的指令。元编程，其实就是一种高级抽象，让代码去写代码，让指令自动转化成代码。<a id="more"></a>实际上我们绝大多数人写的代码都是高级语言，编译器或者解释器会翻译代码，生成大量的机器指令，让电脑去做正确的事。再以前端开发来说，现在炙手可热的各大框架，实际上都有元编程的思想。模版、组件化等等技术其实都是利用了这个思想。所以可以说元编程就在我们身边。</p><hr><h2 id="了解元编程有什么用？"><a href="#了解元编程有什么用？" class="headerlink" title="了解元编程有什么用？"></a>了解元编程有什么用？</h2><p>简单的说就四个字——“少写代码”。</p><h2 id="如何进行元编程？"><a href="#如何进行元编程？" class="headerlink" title="如何进行元编程？"></a>如何进行元编程？</h2><p>其实我们也许在不经意间用过很多次，但是我们没有重视。我想起一本名为《写给大家看的设计书》中提到的“约书亚树”，其中有一段话是这么说的：</p><blockquote><p>一旦能够说出什么东西的名字，就会很容易注意到它。你就会掌握它，拥有它，让它受你所控。</p></blockquote><p>这两天我自己写了一个用来收集用户提供的配置信息的小程序，由于我们的运维工程师不懂代码，但是这个东西又需要由他来完善，于是我将那部分代码提出来，做成了一个JSON文件，当他希望这个程序收集更多用户信息时，只需要改这个文件，我的程序就会自动生成相应的交互。这里贴一点点代码。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run starts the installer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ......</span><br><span class="line">data, err := ioutil.ReadFile(*optionsJSON)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"can't read options.json file: %v"</span>, err))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dataJSON []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">err = json.Unmarshal(data, &amp;dataJSON)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"can't parse JSON file: %v"</span>, err))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, d := <span class="keyword">range</span> dataJSON &#123;</span><br><span class="line">option, err := parseOption(d)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"can't parse JSON file: %v"</span>, err))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> opt, ok := option.(Option); ok &#123;</span><br><span class="line">m.GetInput(opt)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> opt, ok := option.(Options); ok &#123;</span><br><span class="line">m.GetSelect(opt)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetSelect gets users select in given options.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">GetSelect</span><span class="params">(opts Options)</span></span> &#123;</span><br><span class="line">printOptionsHint(opts)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Scanf(<span class="string">"%d"</span>, &amp;opts.Index)</span><br><span class="line"><span class="keyword">if</span> opts.Index &gt; <span class="built_in">len</span>(opts.Opts)+<span class="number">1</span> || opts.Index &lt;= <span class="number">0</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"invalid input(%d), retry please\n"</span>, opts.Index)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Selected: %s\n"</span>, opts.Opts[opts.Index<span class="number">-1</span>].Desc)</span><br><span class="line">m.result = <span class="built_in">append</span>(m.result, Configuration&#123;</span><br><span class="line">Desc:  opts.Desc,</span><br><span class="line">Key:   opts.Key,</span><br><span class="line">Value: opts.Opts[opts.Index<span class="number">-1</span>].Value,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printOptionsHint</span><span class="params">(opts Options)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Please select %s:\n"</span>, opts.Desc)</span><br><span class="line"><span class="keyword">for</span> index, opt := <span class="keyword">range</span> opts.Opts &#123;</span><br><span class="line">fmt.Printf(<span class="string">"[%d]: %s\n"</span>, index+<span class="number">1</span>, opt.Desc)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> opts.Index != <span class="number">0</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Default value is: %s\n"</span>, opts.Opts[opts.Index<span class="number">-1</span>].Desc)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printOptionHint</span><span class="params">(opt Option)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Please set %s:\n"</span>, opt.Desc)</span><br><span class="line"><span class="keyword">if</span> opt.Value != <span class="string">""</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Default value is: %s\n"</span>, opt.Value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetInput gets users input.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">GetInput</span><span class="params">(opt Option)</span></span> &#123;</span><br><span class="line">printOptionHint(opt)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> temp <span class="keyword">string</span></span><br><span class="line">fmt.Scanf(<span class="string">"%s"</span>, &amp;temp)</span><br><span class="line"><span class="keyword">if</span> temp != <span class="string">""</span> &#123;</span><br><span class="line">opt.Value = temp</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> opt.Tag != <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := valid.Var(opt.Value, opt.Tag); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"invalid input(%s), retry please\n"</span>, opt.Value)</span><br><span class="line">opt.Value = <span class="string">""</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Set %s:%s\n"</span>, opt.Desc, opt.Value)</span><br><span class="line">m.result = <span class="built_in">append</span>(m.result, Configuration&#123;</span><br><span class="line">Desc:  opt.Desc,</span><br><span class="line">Key:   opt.Key,</span><br><span class="line">Value: opt.Value,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部分JSON文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"Desc"</span>: <span class="string">"Authorization suite"</span>,</span><br><span class="line">        <span class="attr">"Key"</span>: <span class="string">"AuthProvider"</span>,</span><br><span class="line">        <span class="attr">"Index"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"Opts"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"Desc"</span>: <span class="string">"Basic (Standard Linux PAM)"</span>,</span><br><span class="line">                <span class="attr">"Value"</span>: <span class="string">"Basic"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"Desc"</span>: <span class="string">"NIS (Network Information Service)"</span>,</span><br><span class="line">                <span class="attr">"Value"</span>: <span class="string">"NIS"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"Desc"</span>: <span class="string">"LDAP (Lightweight Directory Access Protocol)"</span>,</span><br><span class="line">                <span class="attr">"Value"</span>: <span class="string">"LDAP"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line"><span class="attr">"Key"</span>:   <span class="string">"InterfaceHost"</span>,</span><br><span class="line"><span class="attr">"Desc"</span>:  <span class="string">"Host network interface name(eg: eth0)"</span>,</span><br><span class="line"><span class="attr">"Value"</span>: <span class="string">""</span>,</span><br><span class="line"><span class="attr">"Tag"</span>:   <span class="string">"required"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>运行效果：<br><img src="http://o6sdpimwf.bkt.clouddn.com/2017-02-01.png" alt="auto"></p><p>这里并不是要用代码来介绍元编程，而是在这里抛砖引玉让大家了解这个概念，记住这个概念，应用到自己的代码里。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o6sdpimwf.bkt.clouddn.com/blog/2017-02-01/code.png&quot; alt=&quot;auto&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是元编程&quot;&gt;&lt;a href=&quot;#什么是元编程&quot; class=&quot;headerlink&quot; title=&quot;什么是元编程&quot;&gt;&lt;/a&gt;什么是元编程&lt;/h2&gt;&lt;p&gt;编程，字面意思即编写程序。&lt;/p&gt;
&lt;p&gt;那什么是元编程呢？广义的看，我认为让任何事物按照特定的指令执行特定的动作，就可以算作编程。如果我是一个教官，组织一百号人军训，我让所有人报数，其实也算编程。不过因为人很聪明，所以我只需要一个简单的指令，就完成了这次“编程”。每一个人，我们都可以认为是一个元，Ta能够自动生成剩余的指令。元编程，其实就是一种高级抽象，让代码去写代码，让指令自动转化成代码。
    
    </summary>
    
      <category term="经验&amp;技巧" scheme="http://zxh.site/categories/%E7%BB%8F%E9%AA%8C-%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="经验&amp;技巧" scheme="http://zxh.site/tags/%E7%BB%8F%E9%AA%8C-%E6%8A%80%E5%B7%A7/"/>
    
      <category term="元编程" scheme="http://zxh.site/tags/%E5%85%83%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Golang实现并行命令</title>
    <link href="http://zxh.site/2017/06/24/parallel-command/"/>
    <id>http://zxh.site/2017/06/24/parallel-command/</id>
    <published>2017-06-24T06:16:08.000Z</published>
    <updated>2018-05-26T03:56:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o6sdpimwf.bkt.clouddn.com/uploads/2017/06/parallel.jpg" alt="Gotty"> </p><p>在集群中经常我们会需要在多个节点上执行相同的操作，有不少的软件能帮助我们实现这样的需求，例如大名鼎鼎的Salt，或者更加轻量级的dsh。但是一方面如果在我们自己编写的程序里面再调用这些软件获取并行命令的输出结果，这个命令的执行其实是阻塞的，需要一直等待salt/dsh命令执行完毕后获取输出。<a id="more"></a>另一方面引入salt这样的软件会给部署和维护带来更大的成本，而实际上我们用到的功能仅仅是salt的一小部分，实在是有些得不偿失。如果我们想不依赖其他软件，自己实现一个简单的并行命令的功能，难度会如何呢？这篇文章就为大家介绍一下我是如何利用Redis和共享存储实现简单的并行命令的。</p><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><ul><li>支持异步批量执行命令<ul><li>命令执行</li><li>权限控制</li></ul></li><li>能实时查询执行结果<ul><li>结果输出</li><li>对命令输出做限制</li></ul></li><li>支持命令终止</li></ul><h2 id="大体思路"><a href="#大体思路" class="headerlink" title="大体思路"></a>大体思路</h2><p>MySQL存储命令的基本信息并生成ID，利用Redis分发消息。在集群环境中通常都会有共享存储（这里我们假设所有节点的/home目录均是共享存储），我们只需将命令执行结果以文件形式重定向到共享存储下，文件以一定的编码规律存放，例如<code>/home/pcm/$CommandID/$hostname.out</code>、<code>/home/pcm/$CommandID/$hostname.err</code>.这样查询命令输出结果时只需要遍历该命令ID路径下的所有输出结果即可。（大名鼎鼎的集群调度软件Slurm其实也是采用了类似的做法）为了实现命令终止以及获得可靠的命令执行结果判断，我们需要将pid记录回Redis，另外将所有的<code>exit code</code>记录到文件中以备查询。</p><h3 id="支持异步批量执行命令"><a href="#支持异步批量执行命令" class="headerlink" title="支持异步批量执行命令"></a>支持异步批量执行命令</h3><h4 id="插入命令"><a href="#插入命令" class="headerlink" title="插入命令"></a>插入命令</h4><p>这一步很简单，利用MySQL生成一个自增的ID，然后将命令丢给agent，agent会将消息经过Redis分发到节点上。具体代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start starts run parallel command on nodes, it returns the command ID if</span></span><br><span class="line"><span class="comment">// start successfully.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PcmManager)</span> <span class="title">Start</span><span class="params">(req *Req)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">command := mdef.Pcm&#123;</span><br><span class="line">UID:       req.UID,</span><br><span class="line">StartTime: time.Now().Unix(),</span><br><span class="line">Command:   req.Command,</span><br><span class="line">Nodes:     strings.Join(req.Nodes, <span class="string">","</span>),</span><br><span class="line">&#125;</span><br><span class="line">err = p.db.Insert(&amp;command)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">&#125;</span><br><span class="line">err = p.agent.DoPcm(command.ID, command.UID, req.Command, req.Nodes)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> command.ID, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="下发命令"><a href="#下发命令" class="headerlink" title="下发命令"></a>下发命令</h4><p>前端请求参数包含命令内容以及一个由节点名(hostname)构成的字符数组，收到请求后，将命令经过Redis下发。这里有两种不同的方式：</p><ol><li>利用Redis的Pub/Sub机制，所有的节点都订阅一个消息，例如$hostname:pcm，主机往这个key上发布消息，所有的节点都会收到这个消息然后处理。</li><li>利用list做消息队列，内容放入Redis的消息队列中，例如key是$hostname:pcm，主机使用LPUSH命令将消息压入，所有节点均由一个goroutine利用BRPOP轮询。 </li></ol><p>两种方式没有优劣之分，只是根据需求来确定你需要的方式，方法1让所有在线的节点可以执行指令，但关机的节点不会执行。而方法二就算节点关机，一旦开机之后就可以执行之前的命令。这个根据自己需求选择即可。  </p><p>agent部分负责分发消息、监控消息，由于监控消息的方式有不同，具体大家自己去按自己的思路实现即可，这里只贴出分发的代码：  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DoPcm pushes command info into Redis, pcmExecutor will pop and execute it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">DoPcm</span><span class="params">(cid, uid <span class="keyword">int</span>, command <span class="keyword">string</span>, nodes []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">pcm := Pcm&#123;</span><br><span class="line">CID:     cid,</span><br><span class="line">UID:     uid,</span><br><span class="line">Command: command,</span><br><span class="line">Nodes:   nodes,</span><br><span class="line">&#125;</span><br><span class="line">data, err := json.Marshal(pcm)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(def.ErrGeneralJSONMarshal,</span><br><span class="line">fmt.Sprintf(<span class="string">"can't marshal JSON data:%v"</span>, err))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fails []<span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> _, node := <span class="keyword">range</span> nodes &#123;</span><br><span class="line">key := fmt.Sprintf(<span class="string">"agent:%s:pcm:todo"</span>, node)</span><br><span class="line">_, err := store.Do(<span class="string">"LPUSH"</span>, key, <span class="keyword">string</span>(data))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fails = <span class="built_in">append</span>(fails, node)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(fails) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(def.ErrAgentBatchExec,</span><br><span class="line">fmt.Sprintf(<span class="string">"failed to run cmd:%s on following nodes:%s"</span>,</span><br><span class="line">data, strings.Join(fails, <span class="string">","</span>)))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h4><p>节点拿到消息后调用exec.Command执行命令，但这里需要修改一下输出定向，记录pid以备终止命令时使用，将错误退出码记录到文件，以用户权限执行命令。具体范例代码如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">pcmExec</span><span class="params">(pcm *Pcm)</span></span> &#123;</span><br><span class="line">dir := fmt.Sprintf(<span class="string">"/home/pcm/%d"</span>, pcm.CID)</span><br><span class="line">hostName, err := os.Hostname()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logs.Error(<span class="string">"pcmExec can't get hostname: %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">err = os.MkdirAll(dir, <span class="number">0755</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logs.Error(<span class="string">"pcmExec can't create pcm execute directory: %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">stdoutFilename := fmt.Sprintf(<span class="string">"%s/%s.out"</span>, dir, hostName)</span><br><span class="line">stderrFilename := fmt.Sprintf(<span class="string">"%s/%s.err"</span>, dir, hostName)</span><br><span class="line">exitCodeFilename := fmt.Sprintf(<span class="string">"%s/%s.exit"</span>, dir, hostName)</span><br><span class="line">stdout, err := os.Create(stdoutFilename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logs.Error(<span class="string">"pcmExec can't create stdout file: %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">stderr, err := os.Create(stderrFilename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logs.Error(<span class="string">"pcmExec can't create stderr file: %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">exitFlag, err := os.Create(exitCodeFilename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logs.Error(<span class="string">"pcmExec can't create exit flag file: %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> exitFlag.Close()</span><br><span class="line">command, err := su.Command(pcm.UID, <span class="string">"bash"</span>, <span class="string">"-c"</span>, pcm.Command)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logs.Error(<span class="string">"pcmExec can't generate command in user's credential:%v"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">command.Stderr = stderr</span><br><span class="line">command.Stdout = stdout</span><br><span class="line">err = command.Start()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logs.Error(<span class="string">"pcmExec can't start command: %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">pid := command.Process.Pid</span><br><span class="line">c := m.redisPool.Get()</span><br><span class="line"><span class="keyword">defer</span> c.Close()</span><br><span class="line">key := fmt.Sprintf(<span class="string">"hpc:pcm:pids:%d"</span>, pcm.CID)</span><br><span class="line">_, err = c.Do(<span class="string">"HSET"</span>, key, hostName, pid)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logs.Error(<span class="string">"pcmExec can't write pid into Redis: %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := command.Wait(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> exiterr, ok := err.(*exec.ExitError); ok &#123;</span><br><span class="line"><span class="keyword">if</span> status, ok := exiterr.Sys().(syscall.WaitStatus); ok &#123;</span><br><span class="line">fmt.Fprintf(exitFlag, <span class="string">"%d"</span>, status.ExitStatus())</span><br><span class="line">logs.Error(<span class="string">"Pcm exit status: %d"</span>, status.ExitStatus())</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// unknown code 999</span></span><br><span class="line">fmt.Fprintf(exitFlag, <span class="string">"%d"</span>, <span class="number">999</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Fprintf(exitFlag, <span class="string">"%d"</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上内容中的<code>su.Command(pcm.UID, &quot;bash&quot;, &quot;-c&quot;, pcm.Command)</code>其实只是封装了一下Command命令，以特定的用户身份运行命令，具体代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Command creates a new exec.Cmd that will run with user privilege.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Command</span><span class="params">(uid <span class="keyword">int</span>, command <span class="keyword">string</span>, args ...<span class="keyword">string</span>)</span> <span class="params">(*exec.Cmd, error)</span></span> &#123;</span><br><span class="line">cred, err := getUserCred(uid)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">cmd := exec.Command(command, args...)</span><br><span class="line">cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;&#125;</span><br><span class="line">cmd.SysProcAttr.Credential = cred</span><br><span class="line"><span class="keyword">return</span> cmd, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="监控命令输出"><a href="#监控命令输出" class="headerlink" title="监控命令输出"></a>监控命令输出</h4><p>因为我们记录了pid到Redis，所以当命令执行完毕之后，应该清除掉这个pid。因为每条命令执行完毕之后，我都会将exit code记录到文件中，所以一旦有这个文件生成，则说明命令执行完毕了。这里我利用了’监听’共享存储的写入事件来确定一条命令执行完毕，而路径中已经包含了ID信息使得我可以方便的确定是哪条命令执行完毕了，使用到了<code>&quot;github.com/rjeczalik/notify&quot;</code>，大致代码如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Watch sets up a watchpoint on the cmdOutputDir, the command output will be</span></span><br><span class="line"><span class="comment">// redirected into cmdOutputDir as file, Watch catches the event, then deletes</span></span><br><span class="line"><span class="comment">// the pid which recorded in Redis.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PcmManager)</span> <span class="title">Watch</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> notify.EventInfo, p.chanBufferSize)</span><br><span class="line">err := notify.Watch(p.cmdOutputDir+<span class="string">"/..."</span>, c, notify.Write)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logs.Critical(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> notify.Stop(c)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">e := &lt;-c</span><br><span class="line">path := e.Path()</span><br><span class="line"><span class="keyword">if</span> !strings.Contains(path, <span class="string">".exit"</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">cid, hostname, err := p.parseHostnameAndCID(path)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logs.Error(<span class="string">"Pcm watcher catches an unexpected error: %v"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">key := fmt.Sprintf(<span class="string">"hpc:pcm:pids:%s"</span>, cid)</span><br><span class="line">_, err = store.Do(<span class="string">"HDEL"</span>, key, hostname)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logs.Error(<span class="string">"Pcm watcher can't remove pids cached in Redis: %v"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上则已经实现了一个并行命令的基本功能。接下来就是查询和终止命令。</p><h3 id="查询执行结果"><a href="#查询执行结果" class="headerlink" title="查询执行结果"></a>查询执行结果</h3><p>经过上面的步骤我们已经把各个节点的命令输出重定向到了特定的目录下，所以只需要知道命令ID，去遍历那个目录下的文件稍加解析，即可获取到这条命令的执行情况。这部分内容比较简单，大家自行实现即可。需要稍加注意的是有的命令可能输出内容很长，所以我们应该利用buffer读取特定长度的内容，而不是直接返回所有内容。大致代码如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PcmManager)</span> <span class="title">readOutputFile</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="params">(content <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">trimmed <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, p.maxOutput)</span><br><span class="line">f, err := os.Open(filename)</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">n, err := f.Read(buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != io.EOF &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> n &gt;= p.maxOutput &#123;</span><br><span class="line">trimmed = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">content = <span class="keyword">string</span>(buf[:n])</span><br><span class="line"><span class="keyword">return</span> content, trimmed, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="终止命令"><a href="#终止命令" class="headerlink" title="终止命令"></a>终止命令</h3><p>执行某些命令可能比较耗时，例如我执行一条命令<code>sleep 300 &amp;&amp; hostname</code>，即在300秒后输出节点的hostname，这时候我们想终止这条命令的执行怎么办呢？我们已经在Redis中以hash表（key：hostname，value：pid）记录过了每个节点上执行的那条命令的pid，所以我们只需要取出这条命令的所有的pid以及对应的主机名就好啦，然后就在各个节点上杀掉特定的进程即可。对了别忘记更新一下MySQL中命令的状态哦。这里有一点需要注意的是我们记录的pid有可能只是一个父进程ID，而<code>sleep 300 &amp;&amp; hostname</code>这样的命令其实会产生两个pid，所以我们要将他们一起杀掉。这里建议大家直接使用<code>pkill -TERM -P $pid</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好啦。具体就介绍到这里了，相信大家已经都能根据上述内容实现一个简单的并行命令需求啦！其实核心就是消息的分发以及命令重定向到共享存储，这也是在分布式系统开发中经常用到的技巧，灵活利用能实现很多实用又有趣的功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o6sdpimwf.bkt.clouddn.com/uploads/2017/06/parallel.jpg&quot; alt=&quot;Gotty&quot;&gt; &lt;/p&gt;
&lt;p&gt;在集群中经常我们会需要在多个节点上执行相同的操作，有不少的软件能帮助我们实现这样的需求，例如大名鼎鼎的Salt，或者更加轻量级的dsh。但是一方面如果在我们自己编写的程序里面再调用这些软件获取并行命令的输出结果，这个命令的执行其实是阻塞的，需要一直等待salt/dsh命令执行完毕后获取输出。
    
    </summary>
    
      <category term="后端" scheme="http://zxh.site/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Golang" scheme="http://zxh.site/categories/%E5%90%8E%E7%AB%AF/Golang/"/>
    
    
      <category term="Golang" scheme="http://zxh.site/tags/Golang/"/>
    
      <category term="后端" scheme="http://zxh.site/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Golang实现多节点Web终端</title>
    <link href="http://zxh.site/2017/04/01/web-tty/"/>
    <id>http://zxh.site/2017/04/01/web-tty/</id>
    <published>2017-04-01T10:07:04.000Z</published>
    <updated>2018-05-26T03:59:03.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o6sdpimwf.bkt.clouddn.com/uploads/2017/04/screenshot.gif" alt="Gotty"><br>熟悉Linux或MacOS的同学都应该对终端并不陌生，诸如XShell、PuTTY这样的工具大家也应该很熟悉。如今各种私有云、公有云、虚拟化技术正在蓬勃发展，工作在集群之上的Web应用程序如果能够提供可以执行命令的终端窗口，将大大改善用户的使用体验。这篇文章就跟大家介绍一下我是如何利用Golang实现支持多节点多用户的Web终端。<a id="more"></a></p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>假设一个用户拥有若干台机器的管理权限，如果能够直接在Web界面上直接登陆任意节点，将给用户带来更好的使用体验。而实现这一功能的几大难点在于：</p><ol><li>供用户访问的Web服务启动在管理节点上，其他节点与管理节点之间通过内网连接，不能被直接访问；</li><li>该系统支持多个用户同时操作；</li><li>每个用户应该以自己的用户身份登陆节点。  </li></ol><p>要实现上述需求，首先WebServer要支持代理请求，并且在计算节点上要能够动态的同时启动多个tty服务。本着“避免重复造轮子”的原则，我先上著名同性交友网站GayHub进行了一番搜寻，最后发现了两个不错的工具能够实现我的需求：</p><blockquote><p><a href="https://github.com/yudai/gotty" target="_blank" rel="noopener">GoTTY</a> is a simple command line tool that turns your CLI tools into web applications.<br><a href="https://github.com/koding/websocketproxy" target="_blank" rel="noopener">WebsocketProxy </a> is an http.Handler interface build on top of gorilla/websocket that you can plug into your existing Go webserver to provide WebSocket reverse proxy.  </p></blockquote><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="启动多个GoTTY实例"><a href="#启动多个GoTTY实例" class="headerlink" title="启动多个GoTTY实例"></a>启动多个GoTTY实例</h3><p>要支持多用户不同身份同时访问，显然我们必须启动多个GoTTY服务，因为无法预计用户的身份和规模，我们不能在每个节点上预先启动多个服务，而应该动态的接受管理节点的命令去启动服务。这一步很简单，最简单的方法是直接在管理节点上执行ssh命令，更好的方式则是在管理节点和计算节点之间实现消息队列的机制，计算节点上能获取到管理节点的命令并执行。这里我利用Redis在管理节点和计算节点之间实现了Agent，这不是这篇文章的重点，所以具体方法这里不赘述。<br>简而言之我已经实现了动态的在计算节点上接收命令以不同身份在不同的接口启动多个GoTTY。</p><h3 id="反向代理GoTTY接口"><a href="#反向代理GoTTY接口" class="headerlink" title="反向代理GoTTY接口"></a>反向代理GoTTY接口</h3><p>下载GoTTY运行后发现这个程序做得非常巧妙，它利用go-bindata将所有静态文件都打包到了二进制文件中，程序编译后只有一个可执行程序，但却能够提供web服务，我通过Chrome调试工具查看了它的网络请求，摸清了它的基本原理，其前端核心是一个websocket请求。前端没有秘密，我只需要将静态文件拆分出来单独提供文件服务就可以使用。于是我尝试在一台计算节点上启动gotty服务，将接口设置了代理，拆分出静态文件，发现服务能正常工作，这意味着成功了一半。</p><p>在Web服务中proxy是很常见的，但大都是通过专门的软件去实现，并且这还是一个Websocket的接口，而WebsocketProxy恰好提供了这样的功能。利用WebsocketProxy我们只需要添加几行简单的代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">agentURL := fmt.Sprintf(<span class="string">"ws://%s:%d/ws"</span>, nodeIP, ttyPort)</span><br><span class="line">u, err := url.Parse(agentURL)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line">proxyHandler := websocketproxy.NewProxy(u)</span><br></pre></td></tr></table></figure></p><p>接下来只需要动态新增这样一个Handler即可。</p><h3 id="动态新增HTTP-Handler"><a href="#动态新增HTTP-Handler" class="headerlink" title="动态新增HTTP Handler"></a>动态新增HTTP Handler</h3><p>我的Web Server采用了Beego框架，仔细阅读框架文档和代码后发现Beego的<a href="https://godoc.org/github.com/astaxie/beego#Handler" target="_blank" rel="noopener">App.Handler</a>能用来添加一个新的HTTP Handler,如果我在一个已有的HTTP Handler中调用该方法，则可以实现动态的增加一个Handler。我们只需要在上述代码的基础上再添加两行：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wsURL := fmt.Sprintf(<span class="string">"/ws_%s%d"</span>, nodeName, ttyPort)</span><br><span class="line">beego.Handler(wsURL, proxyHandler)</span><br></pre></td></tr></table></figure></p><p>如此一来我们就动态的新增了一个handler，并且它的url是根据节点名和端口号动态变化的，接下来我们只需要告诉前端去这个新的URL上建立websocket连接即可。</p><h3 id="修改GoTTY前端代码"><a href="#修改GoTTY前端代码" class="headerlink" title="修改GoTTY前端代码"></a>修改GoTTY前端代码</h3><p>简单分析一下GoTTY的前端代码，发现作者真的具备很强的工具整合能力，自己手写的代码只有寥寥数行，其余均是直接采用第三方库。上面我们已经成功的在计算节点上启动了GoTTY并且动态的新增了Handler，但前端代码中请求的地址是不会变的，所以我们要对它进行修改，让前端知道应该去访问哪个接口。<br>原理很简单，我们让Golang的HTTP Handler跳转到GoTTY的静态文件上，并且带上参数，让前端能获取并使用这个参数就行了，在Go中新增:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redirectURL := fmt.Sprintf(<span class="string">"/tty/index.html?NodeName=%s%d"</span>, nodeName, ttyPort)</span><br><span class="line">n.Redirect(redirectURL, <span class="number">302</span>)</span><br></pre></td></tr></table></figure></p><p>在gotty.js中新增：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nodeName = getQueryString(<span class="string">"NodeName"</span>)</span><br><span class="line"><span class="keyword">var</span> url = (httpsEnabled ? <span class="string">'wss://'</span> : <span class="string">'ws://'</span>) + <span class="built_in">window</span>.location.host + <span class="string">'/ws_'</span> + nodeName;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryString</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"(^|&amp;)"</span> + name + <span class="string">"=([^&amp;]*)(&amp;|$)"</span>, <span class="string">"i"</span>);</span><br><span class="line">    <span class="keyword">var</span> r = <span class="built_in">window</span>.location.search.substr(<span class="number">1</span>).match(reg);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">unescape</span>(r[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>大功告成~试试神奇的体验吧</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>虽然上述代码已经比较完美的实现了一个多用户多节点的Web终端，但是还有一些小问题比如HTTP新增的路由没有动态的得到释放，在用户规模极大的情况下会影响WebServer的性能，查看Beego源码后发现没有提供删除Handler的功能，后续有时间我会尝试解决该问题后向Beego提交Pull Request。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o6sdpimwf.bkt.clouddn.com/uploads/2017/04/screenshot.gif&quot; alt=&quot;Gotty&quot;&gt;&lt;br&gt;熟悉Linux或MacOS的同学都应该对终端并不陌生，诸如XShell、PuTTY这样的工具大家也应该很熟悉。如今各种私有云、公有云、虚拟化技术正在蓬勃发展，工作在集群之上的Web应用程序如果能够提供可以执行命令的终端窗口，将大大改善用户的使用体验。这篇文章就跟大家介绍一下我是如何利用Golang实现支持多节点多用户的Web终端。
    
    </summary>
    
      <category term="后端" scheme="http://zxh.site/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Golang" scheme="http://zxh.site/categories/%E5%90%8E%E7%AB%AF/Golang/"/>
    
    
      <category term="Golang" scheme="http://zxh.site/tags/Golang/"/>
    
      <category term="后端" scheme="http://zxh.site/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7自动部署(PXE+Kickstart)</title>
    <link href="http://zxh.site/2017/03/06/CentOS7AutoDeploy/"/>
    <id>http://zxh.site/2017/03/06/CentOS7AutoDeploy/</id>
    <published>2017-03-06T08:07:04.000Z</published>
    <updated>2018-05-26T04:14:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o6sdpimwf.bkt.clouddn.com/uploads/2017/03/auto.jpg" alt="AutoDeploy"><br>在程序部署的过程中我们经常需要批量部署操作系统，本着“能自动化的绝不手动做”的原则，显然重复部署操作系统这种活儿，我们应该交给脚本去完成。这篇文章就跟大家分享一下如何基于<code>PXE</code>、<code>Kickstart</code>以及<code>dnsmasq</code>实现CentOS7自动部署。<a id="more"></a></p><hr><h2 id="什么是PXE"><a href="#什么是PXE" class="headerlink" title="什么是PXE"></a>什么是PXE</h2><p>PXE(Pre-boot Execution Environment，预启动执行环境)其实是一种算得上“古老”的技术，Intel和Systemsoft早在1999年对外发布了<a href="http://download.intel.com/design/archives/wfm/downloads/pxespec.pdf" target="_blank" rel="noopener">PXE2.1规范</a>，而PXE背后的概念起源于BOOTP/DHCP/TFTP协议的早期阶段，所以严格来说它的历史可以追溯到1985年之前。这项技术诞生的主要目的就是通过网络进行操作系统的自动化部署。  </p><p>简单来说，PXE就是用来通过网络进行操作系统的自动化部署的一种技术集合，它依赖于DHCP以及TFTP服务，每一台支持PXE启动的机器都可以看作一台PXE Client(PXE Client的ROM中包含TFTP Client)，PXE Client会向其所在网络中的DHCP服务索取IP地址以及PXE文件位置，之后经过TFTP服务器获取并执行pxelinux.0、pxelinux.cfg、vmlinuz、initrd.img等文件，实现系统的下载、引导以及安装。其具体原理可以参考<a href="https://en.wikipedia.org/wiki/Preboot_Execution_Environment" target="_blank" rel="noopener">维基百科</a>。 </p><p><img src="http://o6sdpimwf.bkt.clouddn.com/uploads/2017/03/PXE.jpg" alt="原理图"></p><h2 id="那什么是Kickstart呢"><a href="#那什么是Kickstart呢" class="headerlink" title="那什么是Kickstart呢"></a>那什么是Kickstart呢</h2><p>手动安装操作系统的时候，往往有很多选项需要进行配置，我们想要实现自动化，就需要一个工具来代替我们做出选择，我们只需要把这个工具配置好，剩下的都交给它。Kickstart就是这样的一个工具，它是<a href="https://en.wikipedia.org/wiki/Red_Hat_Enterprise_Linux" target="_blank" rel="noopener">Red Hat Enterprise Linux</a>操作系统自动执行无人值守的操作系统安装和配置的一种常用方法。  </p><p>Kickstart安装系统时需要有相应的配置文件才能正常工作，这个文件中记录了我们需要安装的操作系统的各种配置、依赖的软件包、安装过程以及安装完成后要执行的脚本等等，它是安装过程的核心文件。我们有很多方式去生成这个配置文件：</p><ol><li>如果你对Kickstart很熟悉，你可以手动编写或者基于系统中已经存在的kickstart文件进行改写。</li><li>你可以使用配套的GUI程序<code>system-config-kickstart</code>傻瓜式生成配置文件。</li><li>你还可以使用系统安装程序<code>Anaconda</code>来生成配置文件。  </li></ol><p>除此之外如果你有兴趣，还可以了解一下<a href="https://en.wikipedia.org/wiki/Cobbler_(software" target="_blank" rel="noopener">Cobbler</a>)这款安装部署软件。</p><p>找一张图来说明一下完整过程(实际情况中OS Server、install/boot Server以及DHCP Server可以在一台机器上)：<br><img src="http://o6sdpimwf.bkt.clouddn.com/uploads/2017/03/PXEAndKickstart.jpg" alt="原理图"></p><h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><p>下面简单的记录一下我的安装步骤，为了方便我采用了GUI工具配置kickstart配置文件，具体步骤如下：</p><h3 id="安装所需要的服务于平台"><a href="#安装所需要的服务于平台" class="headerlink" title="安装所需要的服务于平台"></a>安装所需要的服务于平台</h3><pre><code>[root@localhost file]# yum -y install tftp tftp-server dnsmasq syslinux nfs-* rpc* vim xinetd system-config-kickstart</code></pre><h3 id="配置tftp"><a href="#配置tftp" class="headerlink" title="配置tftp"></a>配置tftp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost file]# vim /etc/xinetd.d/tftp </span><br><span class="line"># default: off</span><br><span class="line"># description: The tftp server serves files using the trivial file transfer \</span><br><span class="line">#       protocol.  The tftp protocol is often used to boot diskless \</span><br><span class="line">#       workstations, download configuration files to network-aware printers, \</span><br><span class="line">#       and to start the installation process for some operating systems.</span><br><span class="line">service tftp</span><br><span class="line">&#123;</span><br><span class="line">        socket_type             = dgram</span><br><span class="line">        protocol                = udp</span><br><span class="line">        wait                    = yes</span><br><span class="line">        user                    = root</span><br><span class="line">        server                  = /usr/sbin/in.tftpd</span><br><span class="line">        server_args             = -s /var/lib/tftpboot #tftp的工作目录</span><br><span class="line">        disable                 = yes                  #将这一行改为no</span><br><span class="line">        per_source              = 11</span><br><span class="line">        cps                     = 100 2</span><br><span class="line">        flags                   = IPv4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置NFS"><a href="#配置NFS" class="headerlink" title="配置NFS"></a>配置NFS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost file]# cat /etc/exports</span><br><span class="line">/base/file   192.168.195.0/24(rw,sync,no_root_squash)  #ks.cfg文件的存放位置</span><br><span class="line">/base/repo   192.168.195.0/24(rw,sync,no_root_squash)  #ISO镜像文件存放位置</span><br></pre></td></tr></table></figure><h3 id="配置dnsmasq（支持dhcp-和pxe文件）"><a href="#配置dnsmasq（支持dhcp-和pxe文件）" class="headerlink" title="配置dnsmasq（支持dhcp/和pxe文件）:"></a>配置dnsmasq（支持dhcp/和pxe文件）:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost file]# egrep -v &quot;^#|^$&quot; /etc/dnsmasq.conf </span><br><span class="line">dhcp-range=192.168.195.50,192.168.195.150,12h  #设置分配的地址池</span><br><span class="line">dhcp-option=3,192.168.195.1  #设置默认网关</span><br><span class="line">dhcp-boot=pxelinux.0  </span><br><span class="line">enable-tftp    #支持tftp</span><br><span class="line">tftp-root=/var/lib/tftpboot  #设置访问目录</span><br><span class="line">dhcp-authoritative    </span><br><span class="line">conf-dir=/etc/dnsmasq.d</span><br></pre></td></tr></table></figure><h3 id="配置default"><a href="#配置default" class="headerlink" title="配置default"></a>配置default</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost file]# mkdir /var/lib/tftpboot/pxelinux.cfg</span><br><span class="line">[root@localhost file]# mount /dev/cdrom /mnt/</span><br><span class="line">[root@localhost file]#cp -rf /mnt/isolinux/isolinux.cfg  /var/lib/tftpboot/pxelinux.cfg/default</span><br><span class="line">[root@localhost file]# cat /var/lib/tftpboot/pxelinux.cfg/default  #文件修改如下</span><br><span class="line">default ks</span><br><span class="line">prompt 1</span><br><span class="line">timeout 6</span><br><span class="line">display boot.msg</span><br><span class="line">F1 boot.msg</span><br><span class="line">F2 options.msg </span><br><span class="line">F3 general.msg </span><br><span class="line">F4 param.msg </span><br><span class="line">F5 rescue.msg </span><br><span class="line">label text </span><br><span class="line">  kernel vmlinuz </span><br><span class="line">  append initrd=initrd.img text </span><br><span class="line">label ks </span><br><span class="line">  kernel vmlinuz </span><br><span class="line">  append ks=nfs:192.168.195.131:/base/file/ks.cfg initrd=initrd.img  #NFS地址和路径</span><br><span class="line">label local </span><br><span class="line">  localboot 1 </span><br><span class="line">label memtest86 </span><br><span class="line">  kernel memtest </span><br><span class="line">  append -</span><br></pre></td></tr></table></figure><h3 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost tftpboot]# cp -rf /mnt/isolinux/&#123;boot.msg,initrd.img,vmlinuz&#125; /var/lib/tftpboot/</span><br><span class="line">[root@localhost tftpboot]# cp -rf /usr/share/syslinux/pxelinux.0  /var/lib/tftpboot/</span><br><span class="line">[root@localhost tftpboot]# cp –rf /mnt/* /base/repo/</span><br></pre></td></tr></table></figure><h3 id="配置kicksatrt"><a href="#配置kicksatrt" class="headerlink" title="配置kicksatrt"></a>配置kicksatrt</h3><p><strong>此步骤采用桌面环境下的Kickstart工具进行辅助配置，实际可根据需求手动修改ks.cfg文件</strong></p><ol><li>设置基本配置：<br>配置时区、键盘、密码等信息，<strong>勾选安装后重启</strong></li><li>设置安装方法：<br><img src="http://o6sdpimwf.bkt.clouddn.com/uploads/2017/03/method.png" alt="设置安装方法"></li><li>设置是否加载引导程序：<br><img src="http://o6sdpimwf.bkt.clouddn.com/uploads/2017/03/bootloader.png" alt="引导程序"></li><li>设置分区信息：<br><img src="http://o6sdpimwf.bkt.clouddn.com/uploads/2017/03/Partition.png" alt="设置分区信息"></li><li><p>设置网络：<br>默认即可</p></li><li><p>设置验证信息：<br>默认即可</p></li><li><p>设置防火墙：<br>关闭防火墙</p></li><li><p>设置安装软件包： 根据需要选择安装包</p></li></ol><blockquote><p>NOTE: 当出现错误“由于下载软件包信息失败，软件包选择被禁止”的错误时，需要将/etc/yum.repos.d/CentOS-Base.repo 中的[base]修改为[development],否则<code>kickstart</code>找不到yum源</p></blockquote><ol><li>编写安装后的脚本：<br>以下脚本用于修改修改主机名和网卡名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">for lines in $(seq 0 `find /etc/sysconfig/network-scripts/ -name &quot;ifcfg-*&quot;| grep -v &quot;ifcfg-lo&quot;| wc -l`);do</span><br><span class="line">for dev_name in `find /etc/sysconfig/network-scripts/ -name &quot;ifcfg-*&quot; | awk -F &apos;-&apos; &apos;&#123;if($NF !~ /eth/)&#123;print &#125;&#125;&apos; | grep -v &quot;ifcfg-lo&quot;`;d</span><br><span class="line">o</span><br><span class="line">    dev[$lines]=$dev_name</span><br><span class="line">    mv $&#123;dev[$lines]&#125;  /etc/sysconfig/network-scripts/ifcfg-eth$lines #修改网卡名</span><br><span class="line">    sed -i &quot;s#NAME=.*#NAME=eth$lines#&quot; /etc/sysconfig/network-scripts/ifcfg-eth$lines</span><br><span class="line">    sed -i &quot;s#DEVICE=.*#DEVICE=eth$lines#&quot; /etc/sysconfig/network-scripts/ifcfg-eth$lines</span><br><span class="line">done</span><br><span class="line">done</span><br><span class="line">sed -i &apos;/GRUB_CMDLINE_LINUX/ s/quiet/quiet net.ifnames=0 biosdevname=0/g&apos; /etc/sysconfig/grub</span><br><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br><span class="line">sed -i &apos;s/quiet/quiet net.ifnames=0 biosdevname=0/g&apos; /boot/grub2/grub.cfg</span><br><span class="line">rm -rf /etc/hostname #修改主机名</span><br><span class="line">echo Node`ip addr show  | grep eno   | awk -F &apos;[/ ]+&apos; &apos;&#123;print $3&#125;&apos; | grep -v [A-Za-z]  | head -1  | awk -F &apos;.&apos; &apos;&#123;print $NF&#125;&apos;` &gt; /etc/ho</span><br><span class="line">stname</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure></li></ol><p><strong>将ks.cfg文件保存在/base/file下</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl  start nfs</span><br><span class="line">systemctl  start xinetd</span><br><span class="line">dnsmasq --addn-host=/var/dnsmasq.hosts --log-facility /tmp/dnsmasq.log --log-queries</span><br></pre></td></tr></table></figure></p><p>至此结束，启动开启一台新的机器进行测试</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o6sdpimwf.bkt.clouddn.com/uploads/2017/03/auto.jpg&quot; alt=&quot;AutoDeploy&quot;&gt;&lt;br&gt;在程序部署的过程中我们经常需要批量部署操作系统，本着“能自动化的绝不手动做”的原则，显然重复部署操作系统这种活儿，我们应该交给脚本去完成。这篇文章就跟大家分享一下如何基于&lt;code&gt;PXE&lt;/code&gt;、&lt;code&gt;Kickstart&lt;/code&gt;以及&lt;code&gt;dnsmasq&lt;/code&gt;实现CentOS7自动部署。
    
    </summary>
    
      <category term="Linux" scheme="http://zxh.site/categories/Linux/"/>
    
      <category term="经验&amp;技巧" scheme="http://zxh.site/categories/Linux/%E7%BB%8F%E9%AA%8C-%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Linux" scheme="http://zxh.site/tags/Linux/"/>
    
      <category term="PXE" scheme="http://zxh.site/tags/PXE/"/>
    
      <category term="Kickstart" scheme="http://zxh.site/tags/Kickstart/"/>
    
  </entry>
  
  <entry>
    <title>Phabricator仓库配置</title>
    <link href="http://zxh.site/2016/12/01/phabricator-2/"/>
    <id>http://zxh.site/2016/12/01/phabricator-2/</id>
    <published>2016-12-01T14:19:17.000Z</published>
    <updated>2018-05-26T04:20:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o6sdpimwf.bkt.clouddn.com/uploads/2016/11/hero.png" alt="CLI"><br><a href="http://blog.zxh.site/2016/11/26/phabricator-configure/#more" target="_blank" rel="noopener">上一篇博客</a>中介绍了如何安装部署<code>Phabricator</code>，本以为安装完成之后就可以愉快的使用了，但是没想到只是完成了一半，打算迁徙几个代码库进来试试，结果又踩了不少坑<a id="more"></a>，在安装部署完成的基础之上还需要配置不少东西才能真正的用起来，<code>Phabricator</code>看起来是很不错，但是作为一个工具，不得不说使用门槛还是偏高（可能是我太菜了[/捂脸]），最后终于用上了，简单总结分享一下吧</p><h2 id="Repository-Hosting"><a href="#Repository-Hosting" class="headerlink" title="Repository Hosting"></a>Repository Hosting</h2><p><code>Phabricator</code>支持Git、SVN以及Mercurial在SSH以及HTTP(Mercurial不支持HTTP)协议下进行代码托管，具体可以参见<a href="https://secure.phabricator.com/book/phabricator/article/diffusion_hosting/" target="_blank" rel="noopener">官方文档</a>，这里只介绍Git+SSH的方式，文档比较长，但是简化翻译后一共要进行如下几步操作：</p><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>Phabricator需要设置三个账户：</p><ol><li><code>daemon-user</code>用于启动phd守护进程，这里我直接用了<code>root</code></li><li><code>www-user</code>作为WEB服务运行的用户，安装部署的时候已经默认了<code>apache</code>无需手动设置</li><li><code>vcs-user</code>Git操作相关的用户，这里我用了<code>git</code>  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 添加git用户</span><br><span class="line">useradd git</span><br><span class="line"></span><br><span class="line"># 修改shadow文件，将git用户的第二项该为NP，类似：git:NP:0:99999:7:::</span><br><span class="line">vim /etc/shadow</span><br><span class="line"># 修改passwd文件，将git用户的最后一项改为/usr/bin/bash</span><br><span class="line">vim /etc/passwd</span><br><span class="line"></span><br><span class="line">visudo</span><br><span class="line"># 在97行附近，加入如下内容：</span><br><span class="line">git  ALL=(ALL) SETENV: NOPASSWD: /bin/ls, /usr/bin/git, </span><br><span class="line">/usr/bin/git-upload-pack, /usr/bin/git-receive-pack, /usr/bin/ssh</span><br><span class="line"></span><br><span class="line"># 注释掉Defaults    requiretty</span><br></pre></td></tr></table></figure><p>修改配置，启动服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[phabricator]#  ./bin/config set phd.user root</span><br><span class="line">[phabricator]#  ./bin/phd start</span><br><span class="line">[phabricator]#  ./bin/config set diffusion.ssh-user git</span><br></pre></td></tr></table></figure></p><blockquote><p>注：<br>1.The second field (which is the password field) must not be set to !!. This value will prevent login. If it is set to !!, edit it and set it to NP (“no password”) instead<br>2.务必注释掉sudoer中的Defaults    requiretty  </p></blockquote><h3 id="配置SSHD"><a href="#配置SSHD" class="headerlink" title="配置SSHD"></a>配置SSHD</h3><p>为Phabricator单独配置一个sshd到2222端口上，当然你可以放到任意一个端口，如果你觉得很不爽，也可以阅读<a href="https://secure.phabricator.com/book/phabricator/article/diffusion_hosting/" target="_blank" rel="noopener">官方文档</a>进行一些特殊的设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 设置端口号为2222</span><br><span class="line">./bin/config set diffusion.ssh-port 2222</span><br><span class="line"></span><br><span class="line"># 编辑脚本</span><br><span class="line">cd ~your/phabricator/path</span><br><span class="line">cp ./resources/sshd/phabricator-ssh-hook.sh /usr/libexec/phabricator-ssh-hook.sh</span><br><span class="line">chmod 0755 /usr/libexec/phabricator-ssh-hook.sh</span><br><span class="line">vim /usr/libexec/phabricator-ssh-hook.sh</span><br></pre></td></tr></table></figure></p><p>看起来大概这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line"># NOTE: Replace this with the username that you expect users to connect with.</span><br><span class="line">VCSUSER=&quot;git&quot;</span><br><span class="line"></span><br><span class="line"># NOTE: Replace this with the path to your Phabricator directory.</span><br><span class="line">ROOT=&quot;/var/www/html/phabricator&quot;</span><br><span class="line"></span><br><span class="line">if [ &quot;$1&quot; != &quot;$VCSUSER&quot; ];</span><br><span class="line">then</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">exec &quot;$ROOT/bin/ssh-auth&quot; $@</span><br></pre></td></tr></table></figure></p><p>创建编辑sshd配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config.phabricator</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># NOTE: You must have OpenSSHD 6.2 or newer; support for AuthorizedKeysCommand</span><br><span class="line"># was added in this version.</span><br><span class="line"></span><br><span class="line"># NOTE: Edit these to the correct values for your setup.</span><br><span class="line"></span><br><span class="line">AuthorizedKeysCommand /usr/libexec/phabricator-ssh-hook.sh</span><br><span class="line">AuthorizedKeysCommandUser git </span><br><span class="line">AllowUsers git </span><br><span class="line"></span><br><span class="line"># You may need to tweak these options, but mostly they just turn off everything</span><br><span class="line"># dangerous.</span><br><span class="line"></span><br><span class="line">Port 2222</span><br><span class="line">Protocol 2</span><br><span class="line">PermitRootLogin no</span><br><span class="line">AllowAgentForwarding no</span><br><span class="line">AllowTcpForwarding no</span><br><span class="line">PrintMotd no</span><br><span class="line">PrintLastLog no</span><br><span class="line">PasswordAuthentication yes </span><br><span class="line">AuthorizedKeysFile none</span><br><span class="line"></span><br><span class="line">PidFile /var/run/sshd-phabricator.pid</span><br></pre></td></tr></table></figure><p>执行<code>/usr/sbin/sshd -f /etc/ssh/sshd_config.phabricator</code>启动<code>sshd</code>  </p><blockquote><p>注：<br>Both the script(phabricator-ssh-hook.sh) itself and the parent directory the script resides in must be owned by root, and the script must have 755 permissions</p></blockquote><h2 id="Import-repository"><a href="#Import-repository" class="headerlink" title="Import repository"></a>Import repository</h2><p>完成上面的步骤之后，就可以自己新建仓库了，创建仓库很简单就不啰嗦了，这里讲一下如何导入一个现有的代码库到<code>Phabricator</code>中，步骤如下：</p><h3 id="添加Credentials"><a href="#添加Credentials" class="headerlink" title="添加Credentials"></a>添加Credentials</h3><p>进入<code>Application</code>-&gt;<code>Passphrase</code>-&gt;<code>Create Credential</code>,添加一个<code>SSH Private Key</code>将本机的SSH密钥对加入系统，同时将<code>Public Key</code>放到需要克隆的远程仓库中例如<code>GitHub</code>或者原来<code>Gerrit</code>所在的机器</p><h3 id="导入代码"><a href="#导入代码" class="headerlink" title="导入代码"></a>导入代码</h3><ol><li>进入<code>Diffusion</code>-&gt;<code>Create Repository</code>-&gt;<code>Create Git Repository</code>创建一个仓库</li><li>找到新建的仓库，点击<code>Manage Repository</code>-&gt;<code>URIs</code>-&gt;<code>Add New URI</code>，将远程仓库地址填写到<code>URI</code>中，设置<code>I/O Type</code>为<code>Observe</code>模式</li><li><code>Set Credentials</code>选中刚才添加的<code>Credentials</code></li><li>回到<code>Basics</code>中<code>Activate Repository</code>，此时可以在状态中看到正在导入，等待导入完成</li><li>在导入完成之后，编辑刚才<code>Observe</code>模式的那个URI，设置<code>I/O Type</code>为<code>No I/O</code>  </li></ol><blockquote><p>注：<br>官方文档中写的是Disable掉Observe的那个URI，实际上应该是设置<code>I/O Type</code>为<code>No I/O</code></p></blockquote><h2 id="Clone-amp-Commit"><a href="#Clone-amp-Commit" class="headerlink" title="Clone &amp; Commit"></a>Clone &amp; Commit</h2><p>进入<code>Settings</code>-&gt;<code>Personal Settings</code>-&gt;<code>Edit</code>-&gt;<code>SSH Public Keys</code>把平时开发用的机器的Public Key放进去，到这里，就可以用<code>git clone</code>指定的代码库了。不过还没完，你还得安装学习一下如何用<code>Arcanist</code>提交代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 下载到任何目录</span><br><span class="line">mdkir cd /usr/local/phabricator</span><br><span class="line">cd /usr/local/phabricator</span><br><span class="line">git clone https://github.com/phacility/libphutil.git</span><br><span class="line">git clone https://github.com/phacility/arcanist.git</span><br></pre></td></tr></table></figure></p><p>第一次使用的时候，会提示输入一个Token，直接根据提示从你的Phabricator URL中就能获取到，另外别忘了设置一下环境变量，vim /etc/profile.d/pha.sh<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/phabricator/arcanist/bin</span><br></pre></td></tr></table></figure></p><p>顺便可以设置一下开机启动啥的这里就不写了，<code>Arcanist</code>我简单的使用了一下，大概有这些好处：</p><ul><li>让你的提交信息变得更规范</li><li>提交时就能设置好review相关的参数</li><li>直接用命令行就可以查看多个提交review的进度（这个很爽）</li><li>命令行直接合并代码</li></ul><p>简而言之就是更加快捷高效，命令并不难掌握，可以参考一下<a href="https://www.5288z.com/?p=1478" target="_blank" rel="noopener">这个链接</a>学习一下，如果用过git上手这个应该很快。  </p><p>最后，如果你只是自己玩玩或者在一个个人项目中使用<code>Phabricator</code>,别忘了设置<code>differential.allow-self-accept</code>为<code>true</code> ，下一篇我打算试试集成一个合适的CI系统进来，敬请期待~</p><hr><p>EOF</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o6sdpimwf.bkt.clouddn.com/uploads/2016/11/hero.png&quot; alt=&quot;CLI&quot;&gt;&lt;br&gt;&lt;a href=&quot;http://blog.zxh.site/2016/11/26/phabricator-configure/#more&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上一篇博客&lt;/a&gt;中介绍了如何安装部署&lt;code&gt;Phabricator&lt;/code&gt;，本以为安装完成之后就可以愉快的使用了，但是没想到只是完成了一半，打算迁徙几个代码库进来试试，结果又踩了不少坑
    
    </summary>
    
      <category term="工具" scheme="http://zxh.site/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://zxh.site/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Phabricator" scheme="http://zxh.site/tags/Phabricator/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 7 Phabricator安装配置</title>
    <link href="http://zxh.site/2016/11/26/phabricator-configure/"/>
    <id>http://zxh.site/2016/11/26/phabricator-configure/</id>
    <published>2016-11-26T14:16:24.000Z</published>
    <updated>2018-05-26T04:20:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o6sdpimwf.bkt.clouddn.com/uploads/2016/11/hero.png" alt="CLI"></p><p>Phabricator是一套完整的软件开发工具集，包含了任务管理、代码审查、类MarkDown的文档编辑、开发沟通等等，相较于Gerrit这样的代码审核软件，它显得更加现代化，并且集成的其他工具也能很好的和代码审核配合提高生产效率。<a id="more"></a><br>我在CentOS 7下部署这套工具的时候遇到不少问题，不断摸索花了几个小时终于全部搞定了，整理了一下跟大家分享经验。</p><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 切换到任意目录下，这里以/opt/software为例</span><br><span class="line"></span><br><span class="line">cd /opt/software</span><br><span class="line">wget https://raw.githubusercontent.com/phacility/phabricator/master/scripts/install/install_rhel-derivs.sh</span><br><span class="line">chmod +x install_rhel-derivs.sh</span><br><span class="line">./install_rhel-derivs.sh</span><br><span class="line"></span><br><span class="line"># 因为众所周知的原因，代码clone速度较慢，并且核心代码库比较大，加上clone时不支持断点续传</span><br><span class="line"># 建议在科学上网的环境下进行以上操作，如果不具备科学上网的条件，可以考虑去github上下载zip包</span><br></pre></td></tr></table></figure><p><strong>注</strong>：</p><ul><li><strong>如果将克隆后的仓库拷贝到远程主机上安装，用scp复制到远程主机后部分文件会出问题，应该执行<code>git reset --hard HEAD</code>恢复文件到最新版本，否则PHP脚本会报错</strong></li></ul><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>在完整执行过<code>install_rhel-derivs.sh</code>脚本后，系统应该已经有完整的<code>LAMP</code>环境了，执行如下操作进行Web服务器配置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 将clone下来的代码放置到/var/www/html文件夹下</span><br><span class="line">mv /opt/software/* /var/www/html</span><br><span class="line"></span><br><span class="line"># 配置httpd服务</span><br><span class="line">vim /etc/httpd/conf/httpd.conf </span><br><span class="line"></span><br><span class="line"># 在119行附近修改（加入）以下内容</span><br><span class="line">DocumentRoot &quot;/var/www/html/phabricator/webroot&quot;</span><br><span class="line">DirectoryIndex index.php index.html index.html.var</span><br><span class="line"></span><br><span class="line">&lt;VirtualHost *&gt;</span><br><span class="line">  RewriteEngine on</span><br><span class="line">  RewriteRule ^/rsrc/(.*)     -                       [L,QSA]</span><br><span class="line">  RewriteRule ^/favicon.ico   -                       [L,QSA]</span><br><span class="line">  RewriteRule ^(.*)$          /index.php?__path__=$1  [B,L,QSA]</span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line"></span><br><span class="line"># 重启并设置开机启动httpd服务</span><br><span class="line">systemctl restart httpd</span><br><span class="line">systemctl enable httpd</span><br><span class="line"></span><br><span class="line"># 配置Phabricator域名</span><br><span class="line">./phabricator/bin/config set phabricator.base-uri &apos;http://example.com/&apos;</span><br><span class="line"></span><br><span class="line"># 初始化数据库</span><br><span class="line">./phabricator/bin/storage upgrade</span><br></pre></td></tr></table></figure></p><p><strong>注</strong>：</p><ul><li>必须设置一个完整域名，否则会报错或者影响部分功能使用，没有公网域名可以修改客户机hosts文件配置主机域名 </li><li>必须执行数据库初始化操作否则会报错</li></ul><h2 id="Phabricator配置"><a href="#Phabricator配置" class="headerlink" title="Phabricator配置"></a>Phabricator配置</h2><p>完成上述步骤后，输入配置的域名应该就能看到Phabricator的管理员注册界面了，完成注册后进入主界面会看到还有十多个issues提醒，根据提示逐项修改<code>/etc/php.ini</code>和<code>/etc/my.cnf.d/server.cnf</code>,然后重启mariadb和httpd服务，这里提供一下我自己的配置文件供大家参考，环境相同且没有其他软件导致配置冲突的话可以考虑直接替换文件重启服务。</p><ul><li><a href="http://o6sdpimwf.bkt.clouddn.com/uploads/2016/11/php.ini" target="_blank" rel="noopener">php.ini</a></li><li><a href="http://o6sdpimwf.bkt.clouddn.com/uploads/2016/11/server.cnf" target="_blank" rel="noopener">server.cnf</a>  </li></ul><p><strong>注</strong>：</p><ul><li>issues列表中提到的启用<code>pygments</code>以开启代码高亮，使用<code>yum install python-pygments</code>即可安装</li><li><code>Large File Storage</code>建议保留mysql的同时设置一个localpath，系统默认会将小于1M的文件存数据库</li><li><code>Alternate File Domain Not Configured</code>没有CDN的可以忽略</li><li><code>PHP Extension &#39;APC&#39; Not Installed</code>可以忽略，这个我已经配置了但是提示没有，希望知道怎么配置的同学帮忙补充  </li></ul><p>大功告成！尽情探索一下吧~</p><hr><p>EOF</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o6sdpimwf.bkt.clouddn.com/uploads/2016/11/hero.png&quot; alt=&quot;CLI&quot;&gt;&lt;/p&gt;
&lt;p&gt;Phabricator是一套完整的软件开发工具集，包含了任务管理、代码审查、类MarkDown的文档编辑、开发沟通等等，相较于Gerrit这样的代码审核软件，它显得更加现代化，并且集成的其他工具也能很好的和代码审核配合提高生产效率。
    
    </summary>
    
      <category term="工具" scheme="http://zxh.site/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://zxh.site/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Phabricator" scheme="http://zxh.site/tags/Phabricator/"/>
    
  </entry>
  
  <entry>
    <title>如何变得更高效</title>
    <link href="http://zxh.site/2016/10/21/efficient/"/>
    <id>http://zxh.site/2016/10/21/efficient/</id>
    <published>2016-10-21T14:33:07.000Z</published>
    <updated>2018-05-26T03:51:19.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o6sdpimwf.bkt.clouddn.com/uploads/2016/10/efficiency.jpg" alt="efficiency">  </p><p>最近发现如何使自己的效率最大化是很值得研究的问题，尤其是在开发的时候如何提高专注度提高效率？每天的时间都是有限的，如何发挥时间的最大价值？所以最近收集了一些小技巧和工具来提高效率。<a id="more"></a>平时我都是在Windows10+Linux(CentOS 7为主)虚拟机的环境下进行开发的，分享一些经验和技巧吧  </p><hr><h3 id="提高效率的软件"><a href="#提高效率的软件" class="headerlink" title="提高效率的软件"></a>提高效率的软件</h3><h4 id="Wox"><a href="#Wox" class="headerlink" title="Wox"></a>Wox</h4><p><a href="https://github.com/Wox-launcher/Wox" target="_blank" rel="noopener">Wox</a>是一款快速启动程序的小工具，它的特点是足够轻便小巧，并且还挺美观。安装软件之后直接Alt+space就可以在任意界面呼出这个小工具，直接输入你想打开的程序回车就好了，再也不用鼠标点击开始菜单去搜寻了。类似的工具还有<code>Launchy</code>,但是Wox更强大的地方在于可以拓展各种插件，例如执行<code>wpm install 有道词典</code>，软件就集成了翻译功能，输入<code>yd 要查询的单词</code>就能迅速得到结果，还有更多的插件让你事半功倍。</p><h4 id="Everything"><a href="#Everything" class="headerlink" title="Everything"></a>Everything</h4><p><a href="https://www.voidtools.com/" target="_blank" rel="noopener">Everything</a>是一款快速检索文件的工具，建立索引之后搜索速度极快，Wox默认就是用它作为本地文件检索引擎，配合Wox工作起来效率倍增。</p><h4 id="OneNote"><a href="#OneNote" class="headerlink" title="OneNote"></a>OneNote</h4><p>如果要问我最喜欢Windows10的哪个特性的话，我一定毫不犹豫的回答：原生支持OneNote！在Window10中将右侧菜单激活之后会看到一些快捷方式，其中有一个“便签”，这就是UWP版的OneNote，启动迅速、云端同步、完全免费、跨各种平台，非常好用！从此再也不用“印象笔记”、“有道云笔记”之类的软件了。</p><h4 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h4><p><a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">oh-my-zsh</a>是zsh的扩展，zsh是比bash易用性更好的shell，MacOS就使用zsh作为默认shell，说明zsh确实有它的过人之处，而oh-my-zsh更是极大的提高了zsh的效率。插件丰富、自动补齐变得更强大、主题美观并且完全兼容bash、git特殊加持……GitHub上Star 4w+，总之就是特别赞</p><h4 id="Xshell-Xftp"><a href="#Xshell-Xftp" class="headerlink" title="Xshell + Xftp"></a>Xshell + Xftp</h4><p>虽然Windows上的终端软件不少，比如短小精悍的Putty、大名鼎鼎的SecureCRT等，我觉得Putty很棒，适合放到U盘中随身携带即开即用，但是很遗憾的是它对于彩色的支持度不是很好，oh-my-zsh的主题在Putty下显示不正常，SecureCRT又是收费软件，99刀的价格并不算便宜，而XShell却提供了<code>Free for Home/School</code>的许可，加上它强大的功能以及Xftp的整合，可谓是全能型的终端软件了。</p><hr><h3 id="关于Windows"><a href="#关于Windows" class="headerlink" title="关于Windows"></a>关于Windows</h3><p>一帮买了MacBook的程序员鼓吹Mac各种好、效率高、码农必备；一帮Linux高手鼓吹Linux各种帅气的命令行操作、各种奇技淫巧狂拽炫酷吊炸天……很少见到有人夸Windows好，其实主要原因就是：</p><blockquote><p><strong>你的硬件配置不够好</strong>  </p></blockquote><p>相信我，一块SSD能让你对Windows有新的认识，哪怕只是128G的金士顿也能让你飞起来。另外内存一定要大一些，反正已经白菜价了建议8GB或者更大。在这个基础上再去对比各个系统的优劣吧，不然怎么公平呢。</p><blockquote><p>Windows上安装软件需要去网上各种搜索下载安装配置  </p></blockquote><p>Windows上其实也有类似apt-get/yum之类的包管理软件————<a href="https://chocolatey.org/" target="_blank" rel="noopener">Chocolatey</a>，有兴趣的话可以研究一下。另外Windows10周年更新之后，悄悄在系统中加入了一个Sub-System，实际上是整合了一个ubuntu的系统，感兴趣的同学可以google搜索一下具体开启这个子系统的方法，不过这还是一个Beta功能，所以并不能完全达到Linux系统的效果，但是多数Linux命令和软件已经完美支持了。  </p><p>不过我个人觉得更好的方式是弄个虚拟机，运行一个<strong>非桌面版</strong>的Linux系统，新手建议CentOS或者Ubuntu，CentOS在社区使用范围较广，遇到问题能很便捷地获取到解决方法。学会Linux之后效率会得到极大的提升，从此开发相关的所有工具、环境、代码放到Linux中，其他日常应用程序在Windows上。</p><blockquote><p>Windows没有高效通用的Shell  </p></blockquote><p>开启“适用于Linux的Windows子系统”吧，直接运行bash就可以了，就是Linux中一模一样的bash。或者彻底一点，装虚拟机吧！</p><hr><h3 id="生活习惯"><a href="#生活习惯" class="headerlink" title="生活习惯"></a><strong>生活习惯</strong></h3><h4 id="在地铁上看书"><a href="#在地铁上看书" class="headerlink" title="在地铁上看书"></a>在地铁上看书</h4><p>据说北上广的上班族平均通勤时间接近1个小时，来回就是2个小时，大多数人会选择在地铁上玩手机度过。如果把这些时间利用起来读一点儿书，按每天一个小时计算，平均一个周就能看完一本书，就算看得慢一些一个月总是能看完一本书的，一年就是12本，虽然这个数量据说还不到发达国家的最低平均阅读量，但是总算是有收获的。别说了，赶紧买个Kindle吧。</p><h4 id="记录每天做了什么"><a href="#记录每天做了什么" class="headerlink" title="记录每天做了什么"></a>记录每天做了什么</h4><blockquote><p>Make a Done List to Drive Your Productivity</p></blockquote><p>小时候在每学期开学的时候都会给自己制定一个“开学计划”，事实证明完全是三分钟热度持续不了几天一切就全都抛掷脑后了。后来长大了也没改掉这个毛病，总是在制定计划、重新制定计划。其实计划赶不上变化，每天都会发生各种事情可能干扰你的计划，任何计划都不可能详尽的排除各种意外情况的发生，与其使用<code>Todo List</code>不如从现在开始每天记录<code>Done List</code>。  </p><p>只记录今天做了什么，花了多少时间，慢慢地会发现这种习惯的神奇之处。如果知道自己每天都在做什么，自然能根据自己的<code>Done List</code>去自然制定<code>Todo List</code>，一段时间后会发现自己的效率因为这么一个简单的小习惯得到了极大的提高。  </p><p>就到这里吧，希望看到这篇文章的人会觉得有用~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o6sdpimwf.bkt.clouddn.com/uploads/2016/10/efficiency.jpg&quot; alt=&quot;efficiency&quot;&gt;  &lt;/p&gt;
&lt;p&gt;最近发现如何使自己的效率最大化是很值得研究的问题，尤其是在开发的时候如何提高专注度提高效率？每天的时间都是有限的，如何发挥时间的最大价值？所以最近收集了一些小技巧和工具来提高效率。
    
    </summary>
    
      <category term="生活" scheme="http://zxh.site/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="http://zxh.site/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="经验&amp;技巧" scheme="http://zxh.site/tags/%E7%BB%8F%E9%AA%8C-%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
</feed>
